/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.4.2.3, Date: 10-Sep-2020.
 */
#include "NGAP-IEs.h"
#include "NGAP-Constants.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PD_AdditionalQosFlowInformation (OSCTXT* pctxt, AdditionalQosFlowInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalQosFlowInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_AdditionalQosFlowInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = more_likely; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AdditionalQosFlowInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFName (OSCTXT* pctxt, AMFName* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFName");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFName: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(150), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFName: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFPointer (OSCTXT* pctxt, AMFPointer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFPointer");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFPointer: start\n");

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(6), OSUINTCONST(6));

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFPointer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFRegionID (OSCTXT* pctxt, AMFRegionID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFRegionID");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFRegionID: start\n");

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(8), OSUINTCONST(8));

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFRegionID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFSetID (OSCTXT* pctxt, AMFSetID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFSetID");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFSetID: start\n");

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(10), OSUINTCONST(10));

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFSetID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMF_UE_NGAP_ID (OSCTXT* pctxt, AMF_UE_NGAP_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AMF-UE-NGAP-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_UE_NGAP_ID: start\n");

   stat = pd_ConsUInt64 (pctxt, pvalue, 0, OSI64CONST(1099511627775));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_UE_NGAP_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AveragingWindow (OSCTXT* pctxt, AveragingWindow* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AveragingWindow");

   RTDIAGSTRM2 (pctxt,"asn1PD_AveragingWindow: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 4095);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AveragingWindow: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_BitRate (OSCTXT* pctxt, BitRate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "BitRate");

   RTDIAGSTRM2 (pctxt,"asn1PD_BitRate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUInt64 (pctxt, pvalue, 0, OSI64CONST(4000000000000));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUInt64 (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BitRate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CancelAllWarningMessages (OSCTXT* pctxt, CancelAllWarningMessages* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CancelAllWarningMessages");

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelAllWarningMessages: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = true_; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelAllWarningMessages: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CauseMisc (OSCTXT* pctxt, CauseMisc* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseMisc");

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseMisc: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseMisc: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CauseNas (OSCTXT* pctxt, CauseNas* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseNas");

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseNas: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseNas: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CauseProtocol (OSCTXT* pctxt, CauseProtocol* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseProtocol");

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseProtocol: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseProtocol: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CauseRadioNetwork (OSCTXT* pctxt, CauseRadioNetwork* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseRadioNetwork");

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseRadioNetwork: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      switch (ui) {
         case 0: *pvalue = n26_interface_not_available; break;
         case 1: *pvalue = release_due_to_pre_emption; break;
         case 2: *pvalue = multiple_location_reporting_reference_ID_instances; break;
         default: *pvalue = ASN_K_EXTENUM;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(44));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseRadioNetwork: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CauseTransport (OSCTXT* pctxt, CauseTransport* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CauseTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellSize (OSCTXT* pctxt, CellSize* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CellSize");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSize: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellSize: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CNTypeRestrictionsForServing (OSCTXT* pctxt, CNTypeRestrictionsForServing* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CNTypeRestrictionsForServing");

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForServing: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = epc_forbidden_1; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForServing: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CommonNetworkInstance (OSCTXT* pctxt, CommonNetworkInstance* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CommonNetworkInstance");

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonNetworkInstance: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_CommonNetworkInstance: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ConcurrentWarningMessageInd (OSCTXT* pctxt, ConcurrentWarningMessageInd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ConcurrentWarningMessageInd");

   RTDIAGSTRM2 (pctxt,"asn1PD_ConcurrentWarningMessageInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = true__1; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConcurrentWarningMessageInd: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ConfidentialityProtectionIndication (OSCTXT* pctxt, ConfidentialityProtectionIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ConfidentialityProtectionIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_ConfidentialityProtectionIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConfidentialityProtectionIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ConfidentialityProtectionResult (OSCTXT* pctxt, ConfidentialityProtectionResult* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ConfidentialityProtectionResult");

   RTDIAGSTRM2 (pctxt,"asn1PD_ConfidentialityProtectionResult: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConfidentialityProtectionResult: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DataCodingScheme (OSCTXT* pctxt, DataCodingScheme* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DataCodingScheme");

   RTDIAGSTRM2 (pctxt,"asn1PD_DataCodingScheme: start\n");

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(8), OSUINTCONST(8));

   RTDIAGSTRM2 (pctxt,"asn1PD_DataCodingScheme: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DataForwardingAccepted (OSCTXT* pctxt, DataForwardingAccepted* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DataForwardingAccepted");

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingAccepted: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = data_forwarding_accepted; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingAccepted: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DataForwardingNotPossible (OSCTXT* pctxt, DataForwardingNotPossible* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DataForwardingNotPossible");

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingNotPossible: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = data_forwarding_not_possible; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingNotPossible: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DelayCritical (OSCTXT* pctxt, DelayCritical* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DelayCritical");

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayCritical: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DelayCritical: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DLForwarding (OSCTXT* pctxt, DLForwarding* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DLForwarding");

   RTDIAGSTRM2 (pctxt,"asn1PD_DLForwarding: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = dl_forwarding_proposed; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DLForwarding: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DL_NGU_TNLInformationReused (OSCTXT* pctxt, DL_NGU_TNLInformationReused* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-NGU-TNLInformationReused");

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_NGU_TNLInformationReused: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = true__2; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DL_NGU_TNLInformationReused: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DirectForwardingPathAvailability (OSCTXT* pctxt, DirectForwardingPathAvailability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectForwardingPathAvailability");

   RTDIAGSTRM2 (pctxt,"asn1PD_DirectForwardingPathAvailability: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = direct_path_available; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DirectForwardingPathAvailability: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRB_ID (OSCTXT* pctxt, DRB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DRB-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRB_ID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 32);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRB_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaID (OSCTXT* pctxt, EmergencyAreaID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaID");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaID: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 3, 24);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyFallbackRequestIndicator (OSCTXT* pctxt, EmergencyFallbackRequestIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyFallbackRequestIndicator");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyFallbackRequestIndicator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = emergency_fallback_requested; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyFallbackRequestIndicator: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyServiceTargetCN (OSCTXT* pctxt, EmergencyServiceTargetCN* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyServiceTargetCN");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyServiceTargetCN: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyServiceTargetCN: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EN_DCSONConfigurationTransfer (OSCTXT* pctxt, EN_DCSONConfigurationTransfer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EN-DCSONConfigurationTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_EN_DCSONConfigurationTransfer: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_EN_DCSONConfigurationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EPS_TAC (OSCTXT* pctxt, EPS_TAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EPS-TAC");

   RTDIAGSTRM2 (pctxt,"asn1PD_EPS_TAC: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 2, 16);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_EPS_TAC: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_E_RAB_ID (OSCTXT* pctxt, E_RAB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-RAB-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RAB_ID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 15);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RAB_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EUTRACellIdentity (OSCTXT* pctxt, EUTRACellIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EUTRACellIdentity");

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRACellIdentity: start\n");

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(28), OSUINTCONST(28));

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRACellIdentity: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EUTRAencryptionAlgorithms (OSCTXT* pctxt, EUTRAencryptionAlgorithms* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EUTRAencryptionAlgorithms");

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRAencryptionAlgorithms: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_DynBitString (pctxt, pvalue);

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRAencryptionAlgorithms: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EUTRAintegrityProtectionAlgorithms (OSCTXT* pctxt, EUTRAintegrityProtectionAlgorithms* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EUTRAintegrityProtectionAlgorithms");

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRAintegrityProtectionAlgorithms: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_DynBitString (pctxt, pvalue);

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRAintegrityProtectionAlgorithms: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EventType (OSCTXT* pctxt, EventType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EventType");

   RTDIAGSTRM2 (pctxt,"asn1PD_EventType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EventType: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ExpectedActivityPeriod (OSCTXT* pctxt, ExpectedActivityPeriod* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ExpectedActivityPeriod");

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedActivityPeriod: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 181);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedActivityPeriod: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ExpectedHOInterval (OSCTXT* pctxt, ExpectedHOInterval* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ExpectedHOInterval");

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedHOInterval: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedHOInterval: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ExpectedIdlePeriod (OSCTXT* pctxt, ExpectedIdlePeriod* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ExpectedIdlePeriod");

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedIdlePeriod: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 181);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedIdlePeriod: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ExpectedUEMobility (OSCTXT* pctxt, ExpectedUEMobility* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ExpectedUEMobility");

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEMobility: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEMobility: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_FiveG_TMSI (OSCTXT* pctxt, FiveG_TMSI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FiveG-TMSI");

   RTDIAGSTRM2 (pctxt,"asn1PD_FiveG_TMSI: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 4, 32);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_FiveG_TMSI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_FiveQI (OSCTXT* pctxt, FiveQI* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "FiveQI");

   RTDIAGSTRM2 (pctxt,"asn1PD_FiveQI: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 255);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FiveQI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_GTP_TEID (OSCTXT* pctxt, GTP_TEID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GTP-TEID");

   RTDIAGSTRM2 (pctxt,"asn1PD_GTP_TEID: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 4, 32);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_GTP_TEID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFlag (OSCTXT* pctxt, HandoverFlag* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFlag");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFlag: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = handover_preparation; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFlag: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverType (OSCTXT* pctxt, HandoverType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverType");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverType: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_IMSVoiceSupportIndicator (OSCTXT* pctxt, IMSVoiceSupportIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "IMSVoiceSupportIndicator");

   RTDIAGSTRM2 (pctxt,"asn1PD_IMSVoiceSupportIndicator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IMSVoiceSupportIndicator: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_IndexToRFSP (OSCTXT* pctxt, IndexToRFSP* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "IndexToRFSP");

   RTDIAGSTRM2 (pctxt,"asn1PD_IndexToRFSP: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 256);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IndexToRFSP: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_IntegrityProtectionIndication (OSCTXT* pctxt, IntegrityProtectionIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "IntegrityProtectionIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_IntegrityProtectionIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntegrityProtectionIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_IntegrityProtectionResult (OSCTXT* pctxt, IntegrityProtectionResult* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "IntegrityProtectionResult");

   RTDIAGSTRM2 (pctxt,"asn1PD_IntegrityProtectionResult: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntegrityProtectionResult: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_IntendedNumberOfPagingAttempts (OSCTXT* pctxt, IntendedNumberOfPagingAttempts* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "IntendedNumberOfPagingAttempts");

   RTDIAGSTRM2 (pctxt,"asn1PD_IntendedNumberOfPagingAttempts: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 16);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_IntendedNumberOfPagingAttempts: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_InterfacesToTrace (OSCTXT* pctxt, InterfacesToTrace* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InterfacesToTrace");

   RTDIAGSTRM2 (pctxt,"asn1PD_InterfacesToTrace: start\n");

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(8), OSUINTCONST(8));

   RTDIAGSTRM2 (pctxt,"asn1PD_InterfacesToTrace: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LastVisitedEUTRANCellInformation (OSCTXT* pctxt, LastVisitedEUTRANCellInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LastVisitedEUTRANCellInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedEUTRANCellInformation: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedEUTRANCellInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LastVisitedGERANCellInformation (OSCTXT* pctxt, LastVisitedGERANCellInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LastVisitedGERANCellInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedGERANCellInformation: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedGERANCellInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LastVisitedUTRANCellInformation (OSCTXT* pctxt, LastVisitedUTRANCellInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LastVisitedUTRANCellInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedUTRANCellInformation: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedUTRANCellInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LocationReportingAdditionalInfo (OSCTXT* pctxt, LocationReportingAdditionalInfo* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingAdditionalInfo");

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingAdditionalInfo: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = includePSCell; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingAdditionalInfo: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LocationReportingReferenceID (OSCTXT* pctxt, LocationReportingReferenceID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingReferenceID");

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingReferenceID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 64);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingReferenceID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_MaskedIMEISV (OSCTXT* pctxt, MaskedIMEISV* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MaskedIMEISV");

   RTDIAGSTRM2 (pctxt,"asn1PD_MaskedIMEISV: start\n");

   PU_NEWFIELD (pctxt, "BitString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 8, 64);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_MaskedIMEISV: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_MaximumDataBurstVolume (OSCTXT* pctxt, MaximumDataBurstVolume* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MaximumDataBurstVolume");

   RTDIAGSTRM2 (pctxt,"asn1PD_MaximumDataBurstVolume: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 4095);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MaximumDataBurstVolume: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_MessageIdentifier (OSCTXT* pctxt, MessageIdentifier* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MessageIdentifier");

   RTDIAGSTRM2 (pctxt,"asn1PD_MessageIdentifier: start\n");

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(16), OSUINTCONST(16));

   RTDIAGSTRM2 (pctxt,"asn1PD_MessageIdentifier: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_MaximumIntegrityProtectedDataRate (OSCTXT* pctxt, MaximumIntegrityProtectedDataRate* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MaximumIntegrityProtectedDataRate");

   RTDIAGSTRM2 (pctxt,"asn1PD_MaximumIntegrityProtectedDataRate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MaximumIntegrityProtectedDataRate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_MICOModeIndication (OSCTXT* pctxt, MICOModeIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MICOModeIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_MICOModeIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = true__3; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MICOModeIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NAS_PDU (OSCTXT* pctxt, NAS_PDU* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS-PDU");

   RTDIAGSTRM2 (pctxt,"asn1PD_NAS_PDU: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_NAS_PDU: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NASSecurityParametersFromNGRAN (OSCTXT* pctxt, NASSecurityParametersFromNGRAN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NASSecurityParametersFromNGRAN");

   RTDIAGSTRM2 (pctxt,"asn1PD_NASSecurityParametersFromNGRAN: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_NASSecurityParametersFromNGRAN: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NetworkInstance (OSCTXT* pctxt, NetworkInstance* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NetworkInstance");

   RTDIAGSTRM2 (pctxt,"asn1PD_NetworkInstance: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 256);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NetworkInstance: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NewSecurityContextInd (OSCTXT* pctxt, NewSecurityContextInd* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NewSecurityContextInd");

   RTDIAGSTRM2 (pctxt,"asn1PD_NewSecurityContextInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = true__4; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NewSecurityContextInd: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NextHopChainingCount (OSCTXT* pctxt, NextHopChainingCount* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NextHopChainingCount");

   RTDIAGSTRM2 (pctxt,"asn1PD_NextHopChainingCount: start\n");

   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToByte (pctxt, pvalue, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NextHopChainingCount: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NextPagingAreaScope (OSCTXT* pctxt, NextPagingAreaScope* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NextPagingAreaScope");

   RTDIAGSTRM2 (pctxt,"asn1PD_NextPagingAreaScope: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NextPagingAreaScope: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGRANTraceID (OSCTXT* pctxt, NGRANTraceID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NGRANTraceID");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRANTraceID: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 8, 64);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRANTraceID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NotificationCause (OSCTXT* pctxt, NotificationCause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NotificationCause");

   RTDIAGSTRM2 (pctxt,"asn1PD_NotificationCause: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NotificationCause: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NotificationControl (OSCTXT* pctxt, NotificationControl* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NotificationControl");

   RTDIAGSTRM2 (pctxt,"asn1PD_NotificationControl: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = notification_requested; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NotificationControl: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NRCellIdentity (OSCTXT* pctxt, NRCellIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NRCellIdentity");

   RTDIAGSTRM2 (pctxt,"asn1PD_NRCellIdentity: start\n");

   PU_NEWFIELD (pctxt, "BitString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 5, 36);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NRCellIdentity: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NRencryptionAlgorithms (OSCTXT* pctxt, NRencryptionAlgorithms* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NRencryptionAlgorithms");

   RTDIAGSTRM2 (pctxt,"asn1PD_NRencryptionAlgorithms: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_DynBitString (pctxt, pvalue);

   RTDIAGSTRM2 (pctxt,"asn1PD_NRencryptionAlgorithms: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NRintegrityProtectionAlgorithms (OSCTXT* pctxt, NRintegrityProtectionAlgorithms* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NRintegrityProtectionAlgorithms");

   RTDIAGSTRM2 (pctxt,"asn1PD_NRintegrityProtectionAlgorithms: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_DynBitString (pctxt, pvalue);

   RTDIAGSTRM2 (pctxt,"asn1PD_NRintegrityProtectionAlgorithms: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NRPPa_PDU (OSCTXT* pctxt, NRPPa_PDU* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NRPPa-PDU");

   RTDIAGSTRM2 (pctxt,"asn1PD_NRPPa_PDU: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_NRPPa_PDU: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NumberOfBroadcasts (OSCTXT* pctxt, NumberOfBroadcasts* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfBroadcasts");

   RTDIAGSTRM2 (pctxt,"asn1PD_NumberOfBroadcasts: start\n");

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NumberOfBroadcasts: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NumberOfBroadcastsRequested (OSCTXT* pctxt, NumberOfBroadcastsRequested* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfBroadcastsRequested");

   RTDIAGSTRM2 (pctxt,"asn1PD_NumberOfBroadcastsRequested: start\n");

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NumberOfBroadcastsRequested: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_OverloadAction (OSCTXT* pctxt, OverloadAction* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OverloadAction");

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadAction: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadAction: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PacketDelayBudget (OSCTXT* pctxt, PacketDelayBudget* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PacketDelayBudget");

   RTDIAGSTRM2 (pctxt,"asn1PD_PacketDelayBudget: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 1023);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PacketDelayBudget: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PacketLossRate (OSCTXT* pctxt, PacketLossRate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PacketLossRate");

   RTDIAGSTRM2 (pctxt,"asn1PD_PacketLossRate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 1000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PacketLossRate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PagingAttemptCount (OSCTXT* pctxt, PagingAttemptCount* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingAttemptCount");

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingAttemptCount: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 16);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingAttemptCount: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PagingDRX (OSCTXT* pctxt, PagingDRX* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingDRX");

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingDRX: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingDRX: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PagingOrigin (OSCTXT* pctxt, PagingOrigin* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingOrigin");

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingOrigin: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = non_3gpp; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingOrigin: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PagingPriority (OSCTXT* pctxt, PagingPriority* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingPriority");

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingPriority: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingPriority: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionID (OSCTXT* pctxt, PDUSessionID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionID");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionID: start\n");

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionType (OSCTXT* pctxt, PDUSessionType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionType");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionType: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PeriodicRegistrationUpdateTimer (OSCTXT* pctxt, PeriodicRegistrationUpdateTimer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PeriodicRegistrationUpdateTimer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PeriodicRegistrationUpdateTimer: start\n");

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(8), OSUINTCONST(8));

   RTDIAGSTRM2 (pctxt,"asn1PD_PeriodicRegistrationUpdateTimer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PLMNIdentity (OSCTXT* pctxt, PLMNIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMNIdentity");

   RTDIAGSTRM2 (pctxt,"asn1PD_PLMNIdentity: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 3, 24);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PLMNIdentity: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PortNumber (OSCTXT* pctxt, PortNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PortNumber");

   RTDIAGSTRM2 (pctxt,"asn1PD_PortNumber: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 2, 16);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PortNumber: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_Pre_emptionCapability (OSCTXT* pctxt, Pre_emptionCapability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Pre-emptionCapability");

   RTDIAGSTRM2 (pctxt,"asn1PD_Pre_emptionCapability: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Pre_emptionCapability: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_Pre_emptionVulnerability (OSCTXT* pctxt, Pre_emptionVulnerability* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Pre-emptionVulnerability");

   RTDIAGSTRM2 (pctxt,"asn1PD_Pre_emptionVulnerability: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Pre_emptionVulnerability: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PriorityLevelARP (OSCTXT* pctxt, PriorityLevelARP* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PriorityLevelARP");

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityLevelARP: start\n");

   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToByte (pctxt, pvalue, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (*pvalue > 14){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, 15);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   *pvalue += 1;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityLevelARP: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PriorityLevelQos (OSCTXT* pctxt, PriorityLevelQos* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PriorityLevelQos");

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityLevelQos: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PriorityLevelQos: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowIdentifier (OSCTXT* pctxt, QosFlowIdentifier* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowIdentifier");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowIdentifier: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, 63);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowIdentifier: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RANNodeName (OSCTXT* pctxt, RANNodeName* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RANNodeName");

   RTDIAGSTRM2 (pctxt,"asn1PD_RANNodeName: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(150), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_ConstrainedStringEx (pctxt, pvalue, 0, 8, 7, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RANNodeName: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RANPagingPriority (OSCTXT* pctxt, RANPagingPriority* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RANPagingPriority");

   RTDIAGSTRM2 (pctxt,"asn1PD_RANPagingPriority: start\n");

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToUInt16 (pctxt, pvalue, 8);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   *pvalue += 1;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RANPagingPriority: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RAN_UE_NGAP_ID (OSCTXT* pctxt, RAN_UE_NGAP_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAN-UE-NGAP-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_RAN_UE_NGAP_ID: start\n");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINT32_MAX);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RAN_UE_NGAP_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RATRestrictionInformation (OSCTXT* pctxt, RATRestrictionInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RATRestrictionInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_RATRestrictionInformation: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_DynBitString (pctxt, pvalue);

   RTDIAGSTRM2 (pctxt,"asn1PD_RATRestrictionInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RedirectionVoiceFallback (OSCTXT* pctxt, RedirectionVoiceFallback* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RedirectionVoiceFallback");

   RTDIAGSTRM2 (pctxt,"asn1PD_RedirectionVoiceFallback: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RedirectionVoiceFallback: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReflectiveQosAttribute (OSCTXT* pctxt, ReflectiveQosAttribute* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReflectiveQosAttribute");

   RTDIAGSTRM2 (pctxt,"asn1PD_ReflectiveQosAttribute: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = subject_to; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReflectiveQosAttribute: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReferenceID (OSCTXT* pctxt, ReferenceID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReferenceID");

   RTDIAGSTRM2 (pctxt,"asn1PD_ReferenceID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 64);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReferenceID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RelativeAMFCapacity (OSCTXT* pctxt, RelativeAMFCapacity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RelativeAMFCapacity");

   RTDIAGSTRM2 (pctxt,"asn1PD_RelativeAMFCapacity: start\n");

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RelativeAMFCapacity: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ReportArea (OSCTXT* pctxt, ReportArea* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportArea");

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportArea: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = cell; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ReportArea: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RepetitionPeriod (OSCTXT* pctxt, RepetitionPeriod* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RepetitionPeriod");

   RTDIAGSTRM2 (pctxt,"asn1PD_RepetitionPeriod: start\n");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, 131071);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RepetitionPeriod: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ResetAll (OSCTXT* pctxt, ResetAll* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetAll");

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetAll: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = reset_all; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetAll: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RoutingID (OSCTXT* pctxt, RoutingID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RoutingID");

   RTDIAGSTRM2 (pctxt,"asn1PD_RoutingID: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RoutingID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCContainer (OSCTXT* pctxt, RRCContainer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCContainer");

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCContainer: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCContainer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCEstablishmentCause (OSCTXT* pctxt, RRCEstablishmentCause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCEstablishmentCause");

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCEstablishmentCause: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      switch (ui) {
         case 0: *pvalue = notAvailable; break;
         default: *pvalue = ASN_K_EXTENUM;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(9));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCEstablishmentCause: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCInactiveTransitionReportRequest (OSCTXT* pctxt, RRCInactiveTransitionReportRequest* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCInactiveTransitionReportRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReportRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReportRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCState (OSCTXT* pctxt, RRCState* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCState");

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCState: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCState: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SD (OSCTXT* pctxt, SD* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SD");

   RTDIAGSTRM2 (pctxt,"asn1PD_SD: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 3, 24);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SD: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityKey (OSCTXT* pctxt, SecurityKey* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityKey");

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityKey: start\n");

   PU_NEWFIELD (pctxt, "BitString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 32, 256);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityKey: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SerialNumber (OSCTXT* pctxt, SerialNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SerialNumber");

   RTDIAGSTRM2 (pctxt,"asn1PD_SerialNumber: start\n");

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(16), OSUINTCONST(16));

   RTDIAGSTRM2 (pctxt,"asn1PD_SerialNumber: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SONInformationRequest (OSCTXT* pctxt, SONInformationRequest* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SONInformationRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformationRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = xn_TNL_configuration_info; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformationRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SourceOfUEActivityBehaviourInformation (OSCTXT* pctxt, SourceOfUEActivityBehaviourInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceOfUEActivityBehaviourInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceOfUEActivityBehaviourInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceOfUEActivityBehaviourInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SourceToTarget_TransparentContainer (OSCTXT* pctxt, SourceToTarget_TransparentContainer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceToTarget-TransparentContainer");

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceToTarget_TransparentContainer: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceToTarget_TransparentContainer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ConfiguredNSSAI (OSCTXT* pctxt, ConfiguredNSSAI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ConfiguredNSSAI");

   RTDIAGSTRM2 (pctxt,"asn1PD_ConfiguredNSSAI: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 128, 1024);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ConfiguredNSSAI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RejectedNSSAIinPLMN (OSCTXT* pctxt, RejectedNSSAIinPLMN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RejectedNSSAIinPLMN");

   RTDIAGSTRM2 (pctxt,"asn1PD_RejectedNSSAIinPLMN: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 32, 256);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RejectedNSSAIinPLMN: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RejectedNSSAIinTA (OSCTXT* pctxt, RejectedNSSAIinTA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RejectedNSSAIinTA");

   RTDIAGSTRM2 (pctxt,"asn1PD_RejectedNSSAIinTA: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 32, 256);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RejectedNSSAIinTA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SST (OSCTXT* pctxt, SST* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SST");

   RTDIAGSTRM2 (pctxt,"asn1PD_SST: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 1, 8);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SST: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAC (OSCTXT* pctxt, TAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAC");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAC: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 3, 24);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TAC: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TargetToSource_TransparentContainer (OSCTXT* pctxt, TargetToSource_TransparentContainer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetToSource-TransparentContainer");

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetToSource_TransparentContainer: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetToSource_TransparentContainer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TimerApproachForGUAMIRemoval (OSCTXT* pctxt, TimerApproachForGUAMIRemoval* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TimerApproachForGUAMIRemoval");

   RTDIAGSTRM2 (pctxt,"asn1PD_TimerApproachForGUAMIRemoval: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = apply_timer; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimerApproachForGUAMIRemoval: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TimeStamp (OSCTXT* pctxt, TimeStamp* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeStamp");

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeStamp: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 4, 32);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeStamp: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TimeToWait (OSCTXT* pctxt, TimeToWait* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeToWait");

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeToWait: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeToWait: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TimeUEStayedInCell (OSCTXT* pctxt, TimeUEStayedInCell* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeUEStayedInCell");

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeUEStayedInCell: start\n");

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (*pvalue > 4095){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, 4095);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeUEStayedInCell: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TimeUEStayedInCellEnhancedGranularity (OSCTXT* pctxt, TimeUEStayedInCellEnhancedGranularity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeUEStayedInCellEnhancedGranularity");

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeUEStayedInCellEnhancedGranularity: start\n");

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToUInt16 (pctxt, pvalue, pctxt->buffer.aligned ? 16 : 16);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (*pvalue > 40950){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, 40950);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TimeUEStayedInCellEnhancedGranularity: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TNLAddressWeightFactor (OSCTXT* pctxt, TNLAddressWeightFactor* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TNLAddressWeightFactor");

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAddressWeightFactor: start\n");

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToByte (pctxt, pvalue, 8);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAddressWeightFactor: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TNLAssociationUsage (OSCTXT* pctxt, TNLAssociationUsage* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TNLAssociationUsage");

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAssociationUsage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAssociationUsage: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TraceDepth (OSCTXT* pctxt, TraceDepth* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceDepth");

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceDepth: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceDepth: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TrafficLoadReductionIndication (OSCTXT* pctxt, TrafficLoadReductionIndication* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TrafficLoadReductionIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_TrafficLoadReductionIndication: start\n");

   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToByte (pctxt, pvalue, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (*pvalue > 98){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, 99);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   *pvalue += 1;

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TrafficLoadReductionIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TransportLayerAddress (OSCTXT* pctxt, TransportLayerAddress* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TransportLayerAddress");

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportLayerAddress: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(160), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_DynBitString (pctxt, pvalue);

   RTDIAGSTRM2 (pctxt,"asn1PD_TransportLayerAddress: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TypeOfError (OSCTXT* pctxt, TypeOfError* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TypeOfError");

   RTDIAGSTRM2 (pctxt,"asn1PD_TypeOfError: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TypeOfError: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextRequest (OSCTXT* pctxt, UEContextRequest* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = requested; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEPresence (OSCTXT* pctxt, UEPresence* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEPresence");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPresence: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPresence: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapability (OSCTXT* pctxt, UERadioCapability* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapability");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapability: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapability: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityForPagingOfNR (OSCTXT* pctxt, UERadioCapabilityForPagingOfNR* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityForPagingOfNR");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityForPagingOfNR: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityForPagingOfNR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityForPagingOfEUTRA (OSCTXT* pctxt, UERadioCapabilityForPagingOfEUTRA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityForPagingOfEUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityForPagingOfEUTRA: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityForPagingOfEUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERetentionInformation (OSCTXT* pctxt, UERetentionInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERetentionInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERetentionInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ues_retained; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERetentionInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ULForwarding (OSCTXT* pctxt, ULForwarding* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ULForwarding");

   RTDIAGSTRM2 (pctxt,"asn1PD_ULForwarding: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ul_forwarding_proposed; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ULForwarding: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_WarningAreaCoordinates (OSCTXT* pctxt, WarningAreaCoordinates* pvalue)
{
   int stat = 0;
   OSUINT32 numocts;

   RTXCTXTPUSHTYPENAME (pctxt, "WarningAreaCoordinates");

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningAreaCoordinates: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_OctetString (pctxt, &numocts, pvalue->data, sizeof(pvalue->data));

   pvalue->numocts = (OSUINT16) numocts;

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningAreaCoordinates: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_WarningMessageContents (OSCTXT* pctxt, WarningMessageContents* pvalue)
{
   int stat = 0;
   OSUINT32 numocts;

   RTXCTXTPUSHTYPENAME (pctxt, "WarningMessageContents");

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningMessageContents: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9600), 0, 0);

   stat = pd_OctetString (pctxt, &numocts, pvalue->data, sizeof(pvalue->data));

   pvalue->numocts = (OSUINT16) numocts;

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningMessageContents: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_WarningSecurityInfo (OSCTXT* pctxt, WarningSecurityInfo* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "WarningSecurityInfo");

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningSecurityInfo: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 50, 400);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningSecurityInfo: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_WarningType (OSCTXT* pctxt, WarningType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "WarningType");

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningType: start\n");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = rtxDecBitsToByteArray (pctxt, pvalue->data, 2, 16);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningType: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD__PDUSessionResourceItemCxtRelCpl_ExtIEs_Extension (OSCTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _PDUSessionResourceItemCxtRelCpl_ExtIEs_Extension *pvalue = (_PDUSessionResourceItemCxtRelCpl_ExtIEs_Extension*) pvalue_;
   RTDIAGSTRM2 (pctxt,"asn1PD__PDUSessionResourceItemCxtRelCpl_ExtIEs_Extension: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD__PDUSessionResourceItemCxtRelCpl_ExtIEs_Extension: end\n");

   return (stat);
}

EXTERN int asn1PD_AssociatedQosFlowItem_qosFlowMappingIndication (OSCTXT* pctxt, AssociatedQosFlowItem_qosFlowMappingIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_AssociatedQosFlowItem_qosFlowMappingIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AssociatedQosFlowItem_qosFlowMappingIndication: end\n");

   return (stat);
}

EXTERN int asn1PD_CNTypeRestrictionsForEquivalentItem_cn_Type (OSCTXT* pctxt, CNTypeRestrictionsForEquivalentItem_cn_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForEquivalentItem_cn_Type: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForEquivalentItem_cn_Type: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusUL12_receiveStatusOfUL_PDCP_SDUs (OSCTXT* pctxt, DRBStatusUL12_receiveStatusOfUL_PDCP_SDUs* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL12_receiveStatusOfUL_PDCP_SDUs: start\n");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2048), 0, 0);

   {
      OSUINT32 numbits;
      stat = pd_BitString (pctxt, &numbits, pvalue->data, sizeof(pvalue->
         data));
      pvalue->numbits = (OSUINT16) numbits;
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL12_receiveStatusOfUL_PDCP_SDUs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionUsageReport_rATType (OSCTXT* pctxt, PDUSessionUsageReport_rATType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionUsageReport_rATType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionUsageReport_rATType: end\n");

   return (stat);
}

EXTERN int asn1PD_QoSFlowsUsageReport_Item_rATType (OSCTXT* pctxt, QoSFlowsUsageReport_Item_rATType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTDIAGSTRM2 (pctxt,"asn1PD_QoSFlowsUsageReport_Item_rATType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit) {
      PU_NEWFIELD (pctxt, "extension value");

      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      *pvalue = ASN_K_EXTENUM;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QoSFlowsUsageReport_Item_rATType: end\n");

   return (stat);
}

EXTERN int asn1PD_GTPTunnel_iE_Extensions_element (OSCTXT* pctxt, GTPTunnel_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GTPTunnel_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_GTPTunnel_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_GTPTunnel_iE_Extensions (OSCTXT* pctxt, GTPTunnel_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GTPTunnel_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GTPTunnel_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, GTPTunnel_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GTPTunnel_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GTPTunnel_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GTPTunnel_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_GTPTunnel (OSCTXT* pctxt, GTPTunnel* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GTPTunnel");

   RTDIAGSTRM2 (pctxt,"asn1PD_GTPTunnel: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode transportLayerAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode gTP_TEID */
   RTXCTXTPUSHELEMNAME (pctxt, "gTP-TEID");

   stat = asn1PD_GTP_TEID (pctxt, &pvalue->gTP_TEID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_GTPTunnel_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GTPTunnel: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UPTransportLayerInformation_choice_Extensions (OSCTXT* pctxt, UPTransportLayerInformation_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformation_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformation_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UPTransportLayerInformation (OSCTXT* pctxt, UPTransportLayerInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UPTransportLayerInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformation: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* gTPTunnel */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "gTPTunnel");

         pvalue->u.gTPTunnel = rtxMemAllocType (pctxt, GTPTunnel);

         if (pvalue->u.gTPTunnel == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GTPTunnel (pvalue->u.gTPTunnel);

         stat = asn1PD_GTPTunnel (pctxt, pvalue->u.gTPTunnel);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            UPTransportLayerInformation_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UPTransportLayerInformation_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_UPTransportLayerInformation_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowItemWithDataForwarding_iE_Extensions_element (OSCTXT* pctxt, QosFlowItemWithDataForwarding_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowItemWithDataForwarding_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowItemWithDataForwarding_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowItemWithDataForwarding_iE_Extensions (OSCTXT* pctxt, QosFlowItemWithDataForwarding_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowItemWithDataForwarding_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowItemWithDataForwarding_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowItemWithDataForwarding_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowItemWithDataForwarding_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowItemWithDataForwarding_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowItemWithDataForwarding_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowItemWithDataForwarding (OSCTXT* pctxt, QosFlowItemWithDataForwarding* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowItemWithDataForwarding");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowItemWithDataForwarding: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataForwardingAccepted */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataForwardingAccepted");

      pvalue->m.dataForwardingAcceptedPresent = 1;

      stat = asn1PD_DataForwardingAccepted (pctxt, &pvalue->dataForwardingAccepted);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowItemWithDataForwarding_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowItemWithDataForwarding: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowListWithDataForwarding (OSCTXT* pctxt, QosFlowListWithDataForwarding* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowListWithDataForwarding");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowListWithDataForwarding: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowItemWithDataForwarding* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowItemWithDataForwarding", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowItemWithDataForwarding, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowItemWithDataForwarding (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowItemWithDataForwarding (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowListWithDataForwarding: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AdditionalDLUPTNLInformationForHOItem_iE_Extensions_element (OSCTXT* pctxt, AdditionalDLUPTNLInformationForHOItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AdditionalDLUPTNLInformationForHOItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AdditionalDLUPTNLInformationForHOItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AdditionalDLUPTNLInformationForHOItem_iE_Extensions (OSCTXT* pctxt, AdditionalDLUPTNLInformationForHOItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AdditionalDLUPTNLInformationForHOItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AdditionalDLUPTNLInformationForHOItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AdditionalDLUPTNLInformationForHOItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AdditionalDLUPTNLInformationForHOItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AdditionalDLUPTNLInformationForHOItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AdditionalDLUPTNLInformationForHOItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AdditionalDLUPTNLInformationForHOItem (OSCTXT* pctxt, AdditionalDLUPTNLInformationForHOItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalDLUPTNLInformationForHOItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_AdditionalDLUPTNLInformationForHOItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode additionalDL_NGU_UP_TNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "additionalDL-NGU-UP-TNLInformation");

   stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->additionalDL_NGU_UP_TNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode additionalQosFlowSetupResponseList */
   RTXCTXTPUSHELEMNAME (pctxt, "additionalQosFlowSetupResponseList");

   stat = asn1PD_QosFlowListWithDataForwarding (pctxt, &pvalue->additionalQosFlowSetupResponseList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode additionalDLForwardingUPTNLInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalDLForwardingUPTNLInformation");

      pvalue->m.additionalDLForwardingUPTNLInformationPresent = 1;

      stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->additionalDLForwardingUPTNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AdditionalDLUPTNLInformationForHOItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AdditionalDLUPTNLInformationForHOItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AdditionalDLUPTNLInformationForHOList (OSCTXT* pctxt, AdditionalDLUPTNLInformationForHOList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AdditionalDLUPTNLInformationForHOList");

   RTDIAGSTRM2 (pctxt,"asn1PD_AdditionalDLUPTNLInformationForHOList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(3), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AdditionalDLUPTNLInformationForHOItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AdditionalDLUPTNLInformationForHOItem", xx1);

      rtxDListAllocNodeAndData (pctxt, AdditionalDLUPTNLInformationForHOItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AdditionalDLUPTNLInformationForHOItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AdditionalDLUPTNLInformationForHOItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AdditionalDLUPTNLInformationForHOList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AllocationAndRetentionPriority_iE_Extensions_element (OSCTXT* pctxt, AllocationAndRetentionPriority_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllocationAndRetentionPriority_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AllocationAndRetentionPriority_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AllocationAndRetentionPriority_iE_Extensions (OSCTXT* pctxt, AllocationAndRetentionPriority_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllocationAndRetentionPriority_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AllocationAndRetentionPriority_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AllocationAndRetentionPriority_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AllocationAndRetentionPriority_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AllocationAndRetentionPriority_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllocationAndRetentionPriority_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AllocationAndRetentionPriority (OSCTXT* pctxt, AllocationAndRetentionPriority* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AllocationAndRetentionPriority");

   RTDIAGSTRM2 (pctxt,"asn1PD_AllocationAndRetentionPriority: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode priorityLevelARP */
   RTXCTXTPUSHELEMNAME (pctxt, "priorityLevelARP");

   stat = asn1PD_PriorityLevelARP (pctxt, &pvalue->priorityLevelARP);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pre_emptionCapability */
   RTXCTXTPUSHELEMNAME (pctxt, "pre-emptionCapability");

   stat = asn1PD_Pre_emptionCapability (pctxt, &pvalue->pre_emptionCapability);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pre_emptionVulnerability */
   RTXCTXTPUSHELEMNAME (pctxt, "pre-emptionVulnerability");

   stat = asn1PD_Pre_emptionVulnerability (pctxt, &pvalue->pre_emptionVulnerability);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AllocationAndRetentionPriority_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllocationAndRetentionPriority: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_S_NSSAI_iE_Extensions_element (OSCTXT* pctxt, S_NSSAI_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_NSSAI_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_S_NSSAI_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_S_NSSAI_iE_Extensions (OSCTXT* pctxt, S_NSSAI_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_S_NSSAI_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      S_NSSAI_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, S_NSSAI_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_S_NSSAI_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_S_NSSAI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_S_NSSAI_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_S_NSSAI (OSCTXT* pctxt, S_NSSAI* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "S-NSSAI");

   RTDIAGSTRM2 (pctxt,"asn1PD_S_NSSAI: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode sST */
   RTXCTXTPUSHELEMNAME (pctxt, "sST");

   stat = asn1PD_SST (pctxt, &pvalue->sST);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sD */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sD");

      pvalue->m.sDPresent = 1;

      stat = asn1PD_SD (pctxt, &pvalue->sD);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_S_NSSAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_S_NSSAI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AllowedNSSAI_Item_iE_Extensions_element (OSCTXT* pctxt, AllowedNSSAI_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedNSSAI_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedNSSAI_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AllowedNSSAI_Item_iE_Extensions (OSCTXT* pctxt, AllowedNSSAI_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedNSSAI_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AllowedNSSAI_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AllowedNSSAI_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AllowedNSSAI_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AllowedNSSAI_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedNSSAI_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AllowedNSSAI_Item (OSCTXT* pctxt, AllowedNSSAI_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AllowedNSSAI-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedNSSAI_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode s_NSSAI */
   RTXCTXTPUSHELEMNAME (pctxt, "s-NSSAI");

   stat = asn1PD_S_NSSAI (pctxt, &pvalue->s_NSSAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AllowedNSSAI_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedNSSAI_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AllowedNSSAI (OSCTXT* pctxt, AllowedNSSAI* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AllowedNSSAI");

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedNSSAI: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AllowedNSSAI_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AllowedNSSAI-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, AllowedNSSAI_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AllowedNSSAI_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AllowedNSSAI_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedNSSAI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AllowedTACs (OSCTXT* pctxt, AllowedTACs* pvalue)
{
   int stat = 0;
   OSUINT8 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AllowedTACs");

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedTACs: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToByte (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 16){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAC", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (TAC));
      stat = asn1PD_TAC (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AllowedTACs: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_GNB_ID_choice_Extensions (OSCTXT* pctxt, GNB_ID_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GNB_ID_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_GNB_ID_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_GNB_ID (OSCTXT* pctxt, GNB_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "GNB-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_GNB_ID: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* gNB_ID */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "gNB-ID");

         pvalue->u.gNB_ID = rtxMemAllocType (pctxt, ASN1BitStr32);

         if (pvalue->u.gNB_ID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.gNB_ID->numbits = 0;

         PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(22), OSUINTCONST(32), 0, 0);

         stat = pd_BitString32 (pctxt, pvalue->u.gNB_ID
            , OSUINTCONST(22), OSUINTCONST(32));

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            GNB_ID_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GNB_ID_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_GNB_ID_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GNB_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_GlobalGNB_ID_iE_Extensions_element (OSCTXT* pctxt, GlobalGNB_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalGNB_ID_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalGNB_ID_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_GlobalGNB_ID_iE_Extensions (OSCTXT* pctxt, GlobalGNB_ID_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalGNB_ID_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GlobalGNB_ID_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, GlobalGNB_ID_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GlobalGNB_ID_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GlobalGNB_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalGNB_ID_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_GlobalGNB_ID (OSCTXT* pctxt, GlobalGNB_ID* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GlobalGNB-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalGNB_ID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode gNB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "gNB-ID");

   stat = asn1PD_GNB_ID (pctxt, &pvalue->gNB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_GlobalGNB_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalGNB_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NgENB_ID_choice_Extensions (OSCTXT* pctxt, NgENB_ID_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NgENB_ID_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NgENB_ID_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_NgENB_ID (OSCTXT* pctxt, NgENB_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "NgENB-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_NgENB_ID: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* macroNgENB_ID */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "macroNgENB-ID");

         pvalue->u.macroNgENB_ID = rtxMemAllocTypeZ (pctxt, ASN1BitStr32);

         if (pvalue->u.macroNgENB_ID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = pd_BitString32 (pctxt, pvalue->u.macroNgENB_ID
            , OSUINTCONST(20), OSUINTCONST(20));

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* shortMacroNgENB_ID */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "shortMacroNgENB-ID");

         pvalue->u.shortMacroNgENB_ID = rtxMemAllocTypeZ (pctxt, 
            ASN1BitStr32);

         if (pvalue->u.shortMacroNgENB_ID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = pd_BitString32 (pctxt, pvalue->u.shortMacroNgENB_ID
            , OSUINTCONST(18), OSUINTCONST(18));

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* longMacroNgENB_ID */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "longMacroNgENB-ID");

         pvalue->u.longMacroNgENB_ID = rtxMemAllocTypeZ (pctxt, ASN1BitStr32);

         if (pvalue->u.longMacroNgENB_ID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = pd_BitString32 (pctxt, pvalue->u.longMacroNgENB_ID
            , OSUINTCONST(21), OSUINTCONST(21));

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            NgENB_ID_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NgENB_ID_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_NgENB_ID_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NgENB_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_GlobalNgENB_ID_iE_Extensions_element (OSCTXT* pctxt, GlobalNgENB_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalNgENB_ID_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalNgENB_ID_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_GlobalNgENB_ID_iE_Extensions (OSCTXT* pctxt, GlobalNgENB_ID_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalNgENB_ID_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GlobalNgENB_ID_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, GlobalNgENB_ID_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GlobalNgENB_ID_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GlobalNgENB_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalNgENB_ID_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_GlobalNgENB_ID (OSCTXT* pctxt, GlobalNgENB_ID* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GlobalNgENB-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalNgENB_ID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ngENB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "ngENB-ID");

   stat = asn1PD_NgENB_ID (pctxt, &pvalue->ngENB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_GlobalNgENB_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalNgENB_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_N3IWF_ID_choice_Extensions (OSCTXT* pctxt, N3IWF_ID_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_N3IWF_ID_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_N3IWF_ID_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_N3IWF_ID (OSCTXT* pctxt, N3IWF_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "N3IWF-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_N3IWF_ID: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* n3IWF_ID */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "n3IWF-ID");

         pvalue->u.n3IWF_ID = rtxMemAllocTypeZ (pctxt, ASN1BitStr32);

         if (pvalue->u.n3IWF_ID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = pd_BitString32 (pctxt, pvalue->u.n3IWF_ID
            , OSUINTCONST(16), OSUINTCONST(16));

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            N3IWF_ID_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_N3IWF_ID_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_N3IWF_ID_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_N3IWF_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_GlobalN3IWF_ID_iE_Extensions_element (OSCTXT* pctxt, GlobalN3IWF_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalN3IWF_ID_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalN3IWF_ID_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_GlobalN3IWF_ID_iE_Extensions (OSCTXT* pctxt, GlobalN3IWF_ID_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalN3IWF_ID_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GlobalN3IWF_ID_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, GlobalN3IWF_ID_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GlobalN3IWF_ID_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GlobalN3IWF_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalN3IWF_ID_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_GlobalN3IWF_ID (OSCTXT* pctxt, GlobalN3IWF_ID* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GlobalN3IWF-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalN3IWF_ID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode n3IWF_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "n3IWF-ID");

   stat = asn1PD_N3IWF_ID (pctxt, &pvalue->n3IWF_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_GlobalN3IWF_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalN3IWF_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_GlobalRANNodeID_choice_Extensions (OSCTXT* pctxt, GlobalRANNodeID_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalRANNodeID_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalRANNodeID_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_GlobalRANNodeID (OSCTXT* pctxt, GlobalRANNodeID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "GlobalRANNodeID");

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalRANNodeID: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* globalGNB_ID */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "globalGNB-ID");

         pvalue->u.globalGNB_ID = rtxMemAllocType (pctxt, GlobalGNB_ID);

         if (pvalue->u.globalGNB_ID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GlobalGNB_ID (pvalue->u.globalGNB_ID);

         stat = asn1PD_GlobalGNB_ID (pctxt, pvalue->u.globalGNB_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* globalNgENB_ID */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "globalNgENB-ID");

         pvalue->u.globalNgENB_ID = rtxMemAllocType (pctxt, GlobalNgENB_ID);

         if (pvalue->u.globalNgENB_ID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GlobalNgENB_ID (pvalue->u.globalNgENB_ID);

         stat = asn1PD_GlobalNgENB_ID (pctxt, pvalue->u.globalNgENB_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* globalN3IWF_ID */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "globalN3IWF-ID");

         pvalue->u.globalN3IWF_ID = rtxMemAllocType (pctxt, GlobalN3IWF_ID);

         if (pvalue->u.globalN3IWF_ID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GlobalN3IWF_ID (pvalue->u.globalN3IWF_ID);

         stat = asn1PD_GlobalN3IWF_ID (pctxt, pvalue->u.globalN3IWF_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            GlobalRANNodeID_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GlobalRANNodeID_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_GlobalRANNodeID_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GlobalRANNodeID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAI_iE_Extensions_element (OSCTXT* pctxt, TAI_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAI_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TAI_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TAI_iE_Extensions (OSCTXT* pctxt, TAI_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAI_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAI_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TAI_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAI_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAI_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TAI (OSCTXT* pctxt, TAI* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TAI");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAI: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tAC */
   RTXCTXTPUSHELEMNAME (pctxt, "tAC");

   stat = asn1PD_TAC (pctxt, &pvalue->tAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFPagingTarget_choice_Extensions (OSCTXT* pctxt, AMFPagingTarget_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFPagingTarget_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFPagingTarget_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFPagingTarget (OSCTXT* pctxt, AMFPagingTarget* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFPagingTarget");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFPagingTarget: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* globalRANNodeID */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "globalRANNodeID");

         pvalue->u.globalRANNodeID = rtxMemAllocType (pctxt, GlobalRANNodeID);

         if (pvalue->u.globalRANNodeID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GlobalRANNodeID (pvalue->u.globalRANNodeID);

         stat = asn1PD_GlobalRANNodeID (pctxt, pvalue->u.globalRANNodeID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tAI */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tAI");

         pvalue->u.tAI = rtxMemAllocType (pctxt, TAI);

         if (pvalue->u.tAI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TAI (pvalue->u.tAI);

         stat = asn1PD_TAI (pctxt, pvalue->u.tAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            AMFPagingTarget_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AMFPagingTarget_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_AMFPagingTarget_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFPagingTarget: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EndpointIPAddressAndPort_iE_Extensions_element (OSCTXT* pctxt, EndpointIPAddressAndPort_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EndpointIPAddressAndPort_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_EndpointIPAddressAndPort_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_EndpointIPAddressAndPort_iE_Extensions (OSCTXT* pctxt, EndpointIPAddressAndPort_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EndpointIPAddressAndPort_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EndpointIPAddressAndPort_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, EndpointIPAddressAndPort_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EndpointIPAddressAndPort_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EndpointIPAddressAndPort_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EndpointIPAddressAndPort_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_EndpointIPAddressAndPort (OSCTXT* pctxt, EndpointIPAddressAndPort* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EndpointIPAddressAndPort");

   RTDIAGSTRM2 (pctxt,"asn1PD_EndpointIPAddressAndPort: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode endpointIPAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "endpointIPAddress");

   stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->endpointIPAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode portNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "portNumber");

   stat = asn1PD_PortNumber (pctxt, &pvalue->portNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_EndpointIPAddressAndPort_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EndpointIPAddressAndPort: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CPTransportLayerInformation_choice_Extensions (OSCTXT* pctxt, CPTransportLayerInformation_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CPTransportLayerInformation_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _CPTransportLayerInformation_ExtIEs_id_EndpointIPAddressAndPort */
   case ASN1V_id_EndpointIPAddressAndPort:
      pvalue->value.
         t = T_NGAP_IEs_CPTransportLayerInformation_ExtIEs_id_EndpointIPAddressAndPort;

      RTXCTXTPUSHELEMNAME (pctxt, "_CPTransportLayerInformation_ExtIEs_id_EndpointIPAddressAndPort");

      pvalue->value.
         u._CPTransportLayerInformation_ExtIEs_id_EndpointIPAddressAndPort
          = rtxMemAllocType (pctxt, EndpointIPAddressAndPort);

      if (pvalue->value.
         u._CPTransportLayerInformation_ExtIEs_id_EndpointIPAddressAndPort
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EndpointIPAddressAndPort (pvalue->value.
         u._CPTransportLayerInformation_ExtIEs_id_EndpointIPAddressAndPort);

      stat = asn1PD_EndpointIPAddressAndPort (pctxt, pvalue->value.
         u._CPTransportLayerInformation_ExtIEs_id_EndpointIPAddressAndPort);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_IEs_CPTransportLayerInformation_ExtIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CPTransportLayerInformation_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CPTransportLayerInformation (OSCTXT* pctxt, CPTransportLayerInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "CPTransportLayerInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_CPTransportLayerInformation: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* endpointIPAddress */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "endpointIPAddress");

         pvalue->u.endpointIPAddress = rtxMemAllocType (pctxt, 
            TransportLayerAddress);

         if (pvalue->u.endpointIPAddress == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TransportLayerAddress (pvalue->u.endpointIPAddress);

         stat = asn1PD_TransportLayerAddress (pctxt, pvalue->u.endpointIPAddress);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            CPTransportLayerInformation_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CPTransportLayerInformation_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_CPTransportLayerInformation_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CPTransportLayerInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationSetupItem_iE_Extensions_element (OSCTXT* pctxt, AMF_TNLAssociationSetupItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationSetupItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationSetupItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationSetupItem_iE_Extensions (OSCTXT* pctxt, AMF_TNLAssociationSetupItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationSetupItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMF_TNLAssociationSetupItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMF_TNLAssociationSetupItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationSetupItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMF_TNLAssociationSetupItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationSetupItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationSetupItem (OSCTXT* pctxt, AMF_TNLAssociationSetupItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AMF-TNLAssociationSetupItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationSetupItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode aMF_TNLAssociationAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "aMF-TNLAssociationAddress");

   stat = asn1PD_CPTransportLayerInformation (pctxt, &pvalue->aMF_TNLAssociationAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AMF_TNLAssociationSetupItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationSetupItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationSetupList (OSCTXT* pctxt, AMF_TNLAssociationSetupList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AMF-TNLAssociationSetupList");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationSetupList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMF_TNLAssociationSetupItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AMF-TNLAssociationSetupItem", xx1);

      rtxDListAllocNodeAndData (pctxt, AMF_TNLAssociationSetupItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationSetupItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMF_TNLAssociationSetupItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationSetupList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToAddItem_iE_Extensions_element (OSCTXT* pctxt, AMF_TNLAssociationToAddItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToAddItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToAddItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToAddItem_iE_Extensions (OSCTXT* pctxt, AMF_TNLAssociationToAddItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToAddItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMF_TNLAssociationToAddItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMF_TNLAssociationToAddItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationToAddItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMF_TNLAssociationToAddItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToAddItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToAddItem (OSCTXT* pctxt, AMF_TNLAssociationToAddItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "AMF-TNLAssociationToAddItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToAddItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode aMF_TNLAssociationAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "aMF-TNLAssociationAddress");

   stat = asn1PD_CPTransportLayerInformation (pctxt, &pvalue->aMF_TNLAssociationAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tNLAssociationUsage */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tNLAssociationUsage");

      pvalue->m.tNLAssociationUsagePresent = 1;

      stat = asn1PD_TNLAssociationUsage (pctxt, &pvalue->tNLAssociationUsage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tNLAddressWeightFactor */
   RTXCTXTPUSHELEMNAME (pctxt, "tNLAddressWeightFactor");

   stat = asn1PD_TNLAddressWeightFactor (pctxt, &pvalue->tNLAddressWeightFactor);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AMF_TNLAssociationToAddItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToAddItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToAddList (OSCTXT* pctxt, AMF_TNLAssociationToAddList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AMF-TNLAssociationToAddList");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToAddList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMF_TNLAssociationToAddItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AMF-TNLAssociationToAddItem", xx1);

      rtxDListAllocNodeAndData (pctxt, AMF_TNLAssociationToAddItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationToAddItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMF_TNLAssociationToAddItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToAddList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToRemoveItem_iE_Extensions_element (OSCTXT* pctxt, AMF_TNLAssociationToRemoveItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToRemoveItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _AMF_TNLAssociationToRemoveItem_ExtIEs_id_TNLAssociationTransportLayerAddressNGRAN */
   case ASN1V_id_TNLAssociationTransportLayerAddressNGRAN:
      pvalue->extensionValue.
         t = T_NGAP_IEs_AMF_TNLAssociationToRemoveItem_ExtIEs_id_TNLAssociationTransportLayerAddressNGRAN;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMF_TNLAssociationToRemoveItem_ExtIEs_id_TNLAssociationTransportLayerAddressNGRAN");

      pvalue->extensionValue.
         u._AMF_TNLAssociationToRemoveItem_ExtIEs_id_TNLAssociationTransportLayerAddressNGRAN
          = rtxMemAllocType (pctxt, CPTransportLayerInformation);

      if (pvalue->extensionValue.
         u._AMF_TNLAssociationToRemoveItem_ExtIEs_id_TNLAssociationTransportLayerAddressNGRAN
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CPTransportLayerInformation (pvalue->extensionValue.
         u._AMF_TNLAssociationToRemoveItem_ExtIEs_id_TNLAssociationTransportLayerAddressNGRAN
         );

      stat = asn1PD_CPTransportLayerInformation (pctxt, pvalue->extensionValue.
         u._AMF_TNLAssociationToRemoveItem_ExtIEs_id_TNLAssociationTransportLayerAddressNGRAN
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_AMF_TNLAssociationToRemoveItem_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToRemoveItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToRemoveItem_iE_Extensions (OSCTXT* pctxt, AMF_TNLAssociationToRemoveItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToRemoveItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMF_TNLAssociationToRemoveItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMF_TNLAssociationToRemoveItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationToRemoveItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMF_TNLAssociationToRemoveItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToRemoveItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToRemoveItem (OSCTXT* pctxt, AMF_TNLAssociationToRemoveItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AMF-TNLAssociationToRemoveItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToRemoveItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode aMF_TNLAssociationAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "aMF-TNLAssociationAddress");

   stat = asn1PD_CPTransportLayerInformation (pctxt, &pvalue->aMF_TNLAssociationAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AMF_TNLAssociationToRemoveItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToRemoveItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToRemoveList (OSCTXT* pctxt, AMF_TNLAssociationToRemoveList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AMF-TNLAssociationToRemoveList");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToRemoveList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMF_TNLAssociationToRemoveItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AMF-TNLAssociationToRemoveItem", xx1);

      rtxDListAllocNodeAndData (pctxt, AMF_TNLAssociationToRemoveItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationToRemoveItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMF_TNLAssociationToRemoveItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToRemoveList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToUpdateItem_iE_Extensions_element (OSCTXT* pctxt, AMF_TNLAssociationToUpdateItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToUpdateItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToUpdateItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToUpdateItem_iE_Extensions (OSCTXT* pctxt, AMF_TNLAssociationToUpdateItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToUpdateItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMF_TNLAssociationToUpdateItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMF_TNLAssociationToUpdateItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationToUpdateItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMF_TNLAssociationToUpdateItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToUpdateItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToUpdateItem (OSCTXT* pctxt, AMF_TNLAssociationToUpdateItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "AMF-TNLAssociationToUpdateItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToUpdateItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode aMF_TNLAssociationAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "aMF-TNLAssociationAddress");

   stat = asn1PD_CPTransportLayerInformation (pctxt, &pvalue->aMF_TNLAssociationAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tNLAssociationUsage */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tNLAssociationUsage");

      pvalue->m.tNLAssociationUsagePresent = 1;

      stat = asn1PD_TNLAssociationUsage (pctxt, &pvalue->tNLAssociationUsage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tNLAddressWeightFactor */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tNLAddressWeightFactor");

      pvalue->m.tNLAddressWeightFactorPresent = 1;

      stat = asn1PD_TNLAddressWeightFactor (pctxt, &pvalue->tNLAddressWeightFactor);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AMF_TNLAssociationToUpdateItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToUpdateItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMF_TNLAssociationToUpdateList (OSCTXT* pctxt, AMF_TNLAssociationToUpdateList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AMF-TNLAssociationToUpdateList");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToUpdateList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMF_TNLAssociationToUpdateItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AMF-TNLAssociationToUpdateItem", xx1);

      rtxDListAllocNodeAndData (pctxt, AMF_TNLAssociationToUpdateItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationToUpdateItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMF_TNLAssociationToUpdateItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMF_TNLAssociationToUpdateList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestTAIItem_iE_Extensions_element (OSCTXT* pctxt, AreaOfInterestTAIItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestTAIItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestTAIItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestTAIItem_iE_Extensions (OSCTXT* pctxt, AreaOfInterestTAIItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestTAIItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AreaOfInterestTAIItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AreaOfInterestTAIItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AreaOfInterestTAIItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AreaOfInterestTAIItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestTAIItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestTAIItem (OSCTXT* pctxt, AreaOfInterestTAIItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AreaOfInterestTAIItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestTAIItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode tAI */
   RTXCTXTPUSHELEMNAME (pctxt, "tAI");

   stat = asn1PD_TAI (pctxt, &pvalue->tAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AreaOfInterestTAIItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestTAIItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestTAIList (OSCTXT* pctxt, AreaOfInterestTAIList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AreaOfInterestTAIList");

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestTAIList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AreaOfInterestTAIItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AreaOfInterestTAIItem", xx1);

      rtxDListAllocNodeAndData (pctxt, AreaOfInterestTAIItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AreaOfInterestTAIItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AreaOfInterestTAIItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestTAIList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NR_CGI_iE_Extensions_element (OSCTXT* pctxt, NR_CGI_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NR_CGI_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NR_CGI_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NR_CGI_iE_Extensions (OSCTXT* pctxt, NR_CGI_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NR_CGI_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NR_CGI_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NR_CGI_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NR_CGI_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NR_CGI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NR_CGI_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_NR_CGI (OSCTXT* pctxt, NR_CGI* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "NR-CGI");

   RTDIAGSTRM2 (pctxt,"asn1PD_NR_CGI: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nRCellIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "nRCellIdentity");

   stat = asn1PD_NRCellIdentity (pctxt, &pvalue->nRCellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_NR_CGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NR_CGI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EUTRA_CGI_iE_Extensions_element (OSCTXT* pctxt, EUTRA_CGI_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRA_CGI_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRA_CGI_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_EUTRA_CGI_iE_Extensions (OSCTXT* pctxt, EUTRA_CGI_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRA_CGI_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EUTRA_CGI_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, EUTRA_CGI_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EUTRA_CGI_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EUTRA_CGI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRA_CGI_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_EUTRA_CGI (OSCTXT* pctxt, EUTRA_CGI* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EUTRA-CGI");

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRA_CGI: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eUTRACellIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRACellIdentity");

   stat = asn1PD_EUTRACellIdentity (pctxt, &pvalue->eUTRACellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_EUTRA_CGI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRA_CGI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGRAN_CGI_choice_Extensions (OSCTXT* pctxt, NGRAN_CGI_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_CGI_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_CGI_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_NGRAN_CGI (OSCTXT* pctxt, NGRAN_CGI* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "NGRAN-CGI");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_CGI: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* nR_CGI */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "nR-CGI");

         pvalue->u.nR_CGI = rtxMemAllocType (pctxt, NR_CGI);

         if (pvalue->u.nR_CGI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NR_CGI (pvalue->u.nR_CGI);

         stat = asn1PD_NR_CGI (pctxt, pvalue->u.nR_CGI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* eUTRA_CGI */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGI");

         pvalue->u.eUTRA_CGI = rtxMemAllocType (pctxt, EUTRA_CGI);

         if (pvalue->u.eUTRA_CGI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EUTRA_CGI (pvalue->u.eUTRA_CGI);

         stat = asn1PD_EUTRA_CGI (pctxt, pvalue->u.eUTRA_CGI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            NGRAN_CGI_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NGRAN_CGI_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_NGRAN_CGI_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_CGI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestCellItem_iE_Extensions_element (OSCTXT* pctxt, AreaOfInterestCellItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestCellItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestCellItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestCellItem_iE_Extensions (OSCTXT* pctxt, AreaOfInterestCellItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestCellItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AreaOfInterestCellItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AreaOfInterestCellItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AreaOfInterestCellItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AreaOfInterestCellItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestCellItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestCellItem (OSCTXT* pctxt, AreaOfInterestCellItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AreaOfInterestCellItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestCellItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nGRAN_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "nGRAN-CGI");

   stat = asn1PD_NGRAN_CGI (pctxt, &pvalue->nGRAN_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AreaOfInterestCellItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestCellItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestCellList (OSCTXT* pctxt, AreaOfInterestCellList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AreaOfInterestCellList");

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestCellList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AreaOfInterestCellItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AreaOfInterestCellItem", xx1);

      rtxDListAllocNodeAndData (pctxt, AreaOfInterestCellItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AreaOfInterestCellItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AreaOfInterestCellItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestCellList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestRANNodeItem_iE_Extensions_element (OSCTXT* pctxt, AreaOfInterestRANNodeItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestRANNodeItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestRANNodeItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestRANNodeItem_iE_Extensions (OSCTXT* pctxt, AreaOfInterestRANNodeItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestRANNodeItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AreaOfInterestRANNodeItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AreaOfInterestRANNodeItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AreaOfInterestRANNodeItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AreaOfInterestRANNodeItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestRANNodeItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestRANNodeItem (OSCTXT* pctxt, AreaOfInterestRANNodeItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AreaOfInterestRANNodeItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestRANNodeItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode globalRANNodeID */
   RTXCTXTPUSHELEMNAME (pctxt, "globalRANNodeID");

   stat = asn1PD_GlobalRANNodeID (pctxt, &pvalue->globalRANNodeID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AreaOfInterestRANNodeItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestRANNodeItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestRANNodeList (OSCTXT* pctxt, AreaOfInterestRANNodeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AreaOfInterestRANNodeList");

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestRANNodeList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AreaOfInterestRANNodeItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AreaOfInterestRANNodeItem", xx1);

      rtxDListAllocNodeAndData (pctxt, AreaOfInterestRANNodeItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AreaOfInterestRANNodeItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AreaOfInterestRANNodeItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestRANNodeList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AreaOfInterest_iE_Extensions_element (OSCTXT* pctxt, AreaOfInterest_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterest_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterest_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AreaOfInterest_iE_Extensions (OSCTXT* pctxt, AreaOfInterest_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterest_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AreaOfInterest_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AreaOfInterest_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AreaOfInterest_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AreaOfInterest_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterest_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AreaOfInterest (OSCTXT* pctxt, AreaOfInterest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "AreaOfInterest");

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode areaOfInterestTAIList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "areaOfInterestTAIList");

      pvalue->m.areaOfInterestTAIListPresent = 1;

      stat = asn1PD_AreaOfInterestTAIList (pctxt, &pvalue->areaOfInterestTAIList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode areaOfInterestCellList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "areaOfInterestCellList");

      pvalue->m.areaOfInterestCellListPresent = 1;

      stat = asn1PD_AreaOfInterestCellList (pctxt, &pvalue->areaOfInterestCellList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode areaOfInterestRANNodeList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "areaOfInterestRANNodeList");

      pvalue->m.areaOfInterestRANNodeListPresent = 1;

      stat = asn1PD_AreaOfInterestRANNodeList (pctxt, &pvalue->areaOfInterestRANNodeList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AreaOfInterest_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestItem_iE_Extensions_element (OSCTXT* pctxt, AreaOfInterestItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestItem_iE_Extensions (OSCTXT* pctxt, AreaOfInterestItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AreaOfInterestItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AreaOfInterestItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AreaOfInterestItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AreaOfInterestItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestItem (OSCTXT* pctxt, AreaOfInterestItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AreaOfInterestItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode areaOfInterest */
   RTXCTXTPUSHELEMNAME (pctxt, "areaOfInterest");

   stat = asn1PD_AreaOfInterest (pctxt, &pvalue->areaOfInterest);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode locationReportingReferenceID */
   RTXCTXTPUSHELEMNAME (pctxt, "locationReportingReferenceID");

   stat = asn1PD_LocationReportingReferenceID (pctxt, &pvalue->locationReportingReferenceID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AreaOfInterestItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AreaOfInterestList (OSCTXT* pctxt, AreaOfInterestList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AreaOfInterestList");

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AreaOfInterestItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AreaOfInterestItem", xx1);

      rtxDListAllocNodeAndData (pctxt, AreaOfInterestItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AreaOfInterestItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AreaOfInterestItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AreaOfInterestList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RecommendedCellItem_iE_Extensions_element (OSCTXT* pctxt, RecommendedCellItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RecommendedCellItem_iE_Extensions (OSCTXT* pctxt, RecommendedCellItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RecommendedCellItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RecommendedCellItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RecommendedCellItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RecommendedCellItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_RecommendedCellItem (OSCTXT* pctxt, RecommendedCellItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RecommendedCellItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nGRAN_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "nGRAN-CGI");

   stat = asn1PD_NGRAN_CGI (pctxt, &pvalue->nGRAN_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeStayedInCell */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timeStayedInCell");

      pvalue->m.timeStayedInCellPresent = 1;

      if (pctxt->buffer.aligned) {
         int stat2 = PD_BYTE_ALIGN (pctxt);
         if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
      }
      PU_NEWFIELD (pctxt, "constrainted int");

      stat = rtxDecBitsToUInt16 (pctxt, &pvalue->timeStayedInCell, pctxt->buffer.aligned ? 16 : 12);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      if (pvalue->timeStayedInCell > 4095){
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, 4095);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      PU_SETBITCOUNT (pctxt);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_RecommendedCellItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RecommendedCellList (OSCTXT* pctxt, RecommendedCellList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RecommendedCellList");

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RecommendedCellItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RecommendedCellItem", xx1);

      rtxDListAllocNodeAndData (pctxt, RecommendedCellItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RecommendedCellItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RecommendedCellItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RecommendedCellsForPaging_iE_Extensions_element (OSCTXT* pctxt, RecommendedCellsForPaging_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellsForPaging_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellsForPaging_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RecommendedCellsForPaging_iE_Extensions (OSCTXT* pctxt, RecommendedCellsForPaging_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellsForPaging_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RecommendedCellsForPaging_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RecommendedCellsForPaging_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RecommendedCellsForPaging_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RecommendedCellsForPaging_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellsForPaging_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_RecommendedCellsForPaging (OSCTXT* pctxt, RecommendedCellsForPaging* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RecommendedCellsForPaging");

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellsForPaging: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode recommendedCellList */
   RTXCTXTPUSHELEMNAME (pctxt, "recommendedCellList");

   stat = asn1PD_RecommendedCellList (pctxt, &pvalue->recommendedCellList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_RecommendedCellsForPaging_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedCellsForPaging: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AssistanceDataForRecommendedCells_iE_Extensions_element (OSCTXT* pctxt, AssistanceDataForRecommendedCells_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForRecommendedCells_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForRecommendedCells_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AssistanceDataForRecommendedCells_iE_Extensions (OSCTXT* pctxt, AssistanceDataForRecommendedCells_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForRecommendedCells_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AssistanceDataForRecommendedCells_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AssistanceDataForRecommendedCells_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AssistanceDataForRecommendedCells_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AssistanceDataForRecommendedCells_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForRecommendedCells_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AssistanceDataForRecommendedCells (OSCTXT* pctxt, AssistanceDataForRecommendedCells* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AssistanceDataForRecommendedCells");

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForRecommendedCells: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode recommendedCellsForPaging */
   RTXCTXTPUSHELEMNAME (pctxt, "recommendedCellsForPaging");

   stat = asn1PD_RecommendedCellsForPaging (pctxt, &pvalue->recommendedCellsForPaging);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AssistanceDataForRecommendedCells_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForRecommendedCells: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PagingAttemptInformation_iE_Extensions_element (OSCTXT* pctxt, PagingAttemptInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingAttemptInformation_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingAttemptInformation_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PagingAttemptInformation_iE_Extensions (OSCTXT* pctxt, PagingAttemptInformation_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingAttemptInformation_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PagingAttemptInformation_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PagingAttemptInformation_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PagingAttemptInformation_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PagingAttemptInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingAttemptInformation_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PagingAttemptInformation (OSCTXT* pctxt, PagingAttemptInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PagingAttemptInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingAttemptInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pagingAttemptCount */
   RTXCTXTPUSHELEMNAME (pctxt, "pagingAttemptCount");

   stat = asn1PD_PagingAttemptCount (pctxt, &pvalue->pagingAttemptCount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode intendedNumberOfPagingAttempts */
   RTXCTXTPUSHELEMNAME (pctxt, "intendedNumberOfPagingAttempts");

   stat = asn1PD_IntendedNumberOfPagingAttempts (pctxt, &pvalue->intendedNumberOfPagingAttempts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nextPagingAreaScope */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nextPagingAreaScope");

      pvalue->m.nextPagingAreaScopePresent = 1;

      stat = asn1PD_NextPagingAreaScope (pctxt, &pvalue->nextPagingAreaScope);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PagingAttemptInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PagingAttemptInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AssistanceDataForPaging_iE_Extensions_element (OSCTXT* pctxt, AssistanceDataForPaging_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForPaging_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForPaging_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AssistanceDataForPaging_iE_Extensions (OSCTXT* pctxt, AssistanceDataForPaging_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForPaging_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AssistanceDataForPaging_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AssistanceDataForPaging_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AssistanceDataForPaging_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AssistanceDataForPaging_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForPaging_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AssistanceDataForPaging (OSCTXT* pctxt, AssistanceDataForPaging* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "AssistanceDataForPaging");

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForPaging: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode assistanceDataForRecommendedCells */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "assistanceDataForRecommendedCells");

      pvalue->m.assistanceDataForRecommendedCellsPresent = 1;

      stat = asn1PD_AssistanceDataForRecommendedCells (pctxt, &pvalue->assistanceDataForRecommendedCells);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pagingAttemptInformation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pagingAttemptInformation");

      pvalue->m.pagingAttemptInformationPresent = 1;

      stat = asn1PD_PagingAttemptInformation (pctxt, &pvalue->pagingAttemptInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AssistanceDataForPaging_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AssistanceDataForPaging: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AssociatedQosFlowItem_iE_Extensions_element (OSCTXT* pctxt, AssociatedQosFlowItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AssociatedQosFlowItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AssociatedQosFlowItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AssociatedQosFlowItem_iE_Extensions (OSCTXT* pctxt, AssociatedQosFlowItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AssociatedQosFlowItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AssociatedQosFlowItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AssociatedQosFlowItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AssociatedQosFlowItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AssociatedQosFlowItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AssociatedQosFlowItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_AssociatedQosFlowItem (OSCTXT* pctxt, AssociatedQosFlowItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "AssociatedQosFlowItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_AssociatedQosFlowItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode qosFlowMappingIndication */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowMappingIndication");

      pvalue->m.qosFlowMappingIndicationPresent = 1;

      stat = asn1PD_AssociatedQosFlowItem_qosFlowMappingIndication (pctxt, &pvalue->qosFlowMappingIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_AssociatedQosFlowItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AssociatedQosFlowItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AssociatedQosFlowList (OSCTXT* pctxt, AssociatedQosFlowList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AssociatedQosFlowList");

   RTDIAGSTRM2 (pctxt,"asn1PD_AssociatedQosFlowList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AssociatedQosFlowItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AssociatedQosFlowItem", xx1);

      rtxDListAllocNodeAndData (pctxt, AssociatedQosFlowItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AssociatedQosFlowItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AssociatedQosFlowItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AssociatedQosFlowList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIDCancelledEUTRA_Item_iE_Extensions_element (OSCTXT* pctxt, CellIDCancelledEUTRA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledEUTRA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledEUTRA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CellIDCancelledEUTRA_Item_iE_Extensions (OSCTXT* pctxt, CellIDCancelledEUTRA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledEUTRA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellIDCancelledEUTRA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CellIDCancelledEUTRA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellIDCancelledEUTRA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellIDCancelledEUTRA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledEUTRA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CellIDCancelledEUTRA_Item (OSCTXT* pctxt, CellIDCancelledEUTRA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CellIDCancelledEUTRA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledEUTRA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode eUTRA_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGI");

   stat = asn1PD_EUTRA_CGI (pctxt, &pvalue->eUTRA_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfBroadcasts */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfBroadcasts");

   stat = asn1PD_NumberOfBroadcasts (pctxt, &pvalue->numberOfBroadcasts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CellIDCancelledEUTRA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledEUTRA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIDCancelledEUTRA (OSCTXT* pctxt, CellIDCancelledEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIDCancelledEUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledEUTRA: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellIDCancelledEUTRA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellIDCancelledEUTRA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CellIDCancelledEUTRA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellIDCancelledEUTRA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellIDCancelledEUTRA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledEUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInTAI_EUTRA_Item_iE_Extensions_element (OSCTXT* pctxt, CancelledCellsInTAI_EUTRA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_EUTRA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_EUTRA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInTAI_EUTRA_Item_iE_Extensions (OSCTXT* pctxt, CancelledCellsInTAI_EUTRA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_EUTRA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CancelledCellsInTAI_EUTRA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CancelledCellsInTAI_EUTRA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CancelledCellsInTAI_EUTRA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CancelledCellsInTAI_EUTRA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_EUTRA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInTAI_EUTRA_Item (OSCTXT* pctxt, CancelledCellsInTAI_EUTRA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CancelledCellsInTAI-EUTRA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_EUTRA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode eUTRA_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGI");

   stat = asn1PD_EUTRA_CGI (pctxt, &pvalue->eUTRA_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfBroadcasts */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfBroadcasts");

   stat = asn1PD_NumberOfBroadcasts (pctxt, &pvalue->numberOfBroadcasts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CancelledCellsInTAI_EUTRA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_EUTRA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInTAI_EUTRA (OSCTXT* pctxt, CancelledCellsInTAI_EUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CancelledCellsInTAI-EUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_EUTRA: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CancelledCellsInTAI_EUTRA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CancelledCellsInTAI-EUTRA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CancelledCellsInTAI_EUTRA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CancelledCellsInTAI_EUTRA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CancelledCellsInTAI_EUTRA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_EUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAICancelledEUTRA_Item_iE_Extensions_element (OSCTXT* pctxt, TAICancelledEUTRA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledEUTRA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledEUTRA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TAICancelledEUTRA_Item_iE_Extensions (OSCTXT* pctxt, TAICancelledEUTRA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledEUTRA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAICancelledEUTRA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TAICancelledEUTRA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAICancelledEUTRA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAICancelledEUTRA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledEUTRA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TAICancelledEUTRA_Item (OSCTXT* pctxt, TAICancelledEUTRA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TAICancelledEUTRA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledEUTRA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode tAI */
   RTXCTXTPUSHELEMNAME (pctxt, "tAI");

   stat = asn1PD_TAI (pctxt, &pvalue->tAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cancelledCellsInTAI_EUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "cancelledCellsInTAI-EUTRA");

   stat = asn1PD_CancelledCellsInTAI_EUTRA (pctxt, &pvalue->cancelledCellsInTAI_EUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TAICancelledEUTRA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledEUTRA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAICancelledEUTRA (OSCTXT* pctxt, TAICancelledEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAICancelledEUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledEUTRA: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAICancelledEUTRA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAICancelledEUTRA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, TAICancelledEUTRA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAICancelledEUTRA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAICancelledEUTRA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledEUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInEAI_EUTRA_Item_iE_Extensions_element (OSCTXT* pctxt, CancelledCellsInEAI_EUTRA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_EUTRA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_EUTRA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInEAI_EUTRA_Item_iE_Extensions (OSCTXT* pctxt, CancelledCellsInEAI_EUTRA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_EUTRA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CancelledCellsInEAI_EUTRA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CancelledCellsInEAI_EUTRA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CancelledCellsInEAI_EUTRA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CancelledCellsInEAI_EUTRA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_EUTRA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInEAI_EUTRA_Item (OSCTXT* pctxt, CancelledCellsInEAI_EUTRA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CancelledCellsInEAI-EUTRA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_EUTRA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode eUTRA_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGI");

   stat = asn1PD_EUTRA_CGI (pctxt, &pvalue->eUTRA_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfBroadcasts */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfBroadcasts");

   stat = asn1PD_NumberOfBroadcasts (pctxt, &pvalue->numberOfBroadcasts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CancelledCellsInEAI_EUTRA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_EUTRA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInEAI_EUTRA (OSCTXT* pctxt, CancelledCellsInEAI_EUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CancelledCellsInEAI-EUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_EUTRA: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CancelledCellsInEAI_EUTRA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CancelledCellsInEAI-EUTRA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CancelledCellsInEAI_EUTRA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CancelledCellsInEAI_EUTRA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CancelledCellsInEAI_EUTRA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_EUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions_element (OSCTXT* pctxt, EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions (OSCTXT* pctxt, EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDCancelledEUTRA_Item (OSCTXT* pctxt, EmergencyAreaIDCancelledEUTRA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaIDCancelledEUTRA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledEUTRA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode emergencyAreaID */
   RTXCTXTPUSHELEMNAME (pctxt, "emergencyAreaID");

   stat = asn1PD_EmergencyAreaID (pctxt, &pvalue->emergencyAreaID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cancelledCellsInEAI_EUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "cancelledCellsInEAI-EUTRA");

   stat = asn1PD_CancelledCellsInEAI_EUTRA (pctxt, &pvalue->cancelledCellsInEAI_EUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_EmergencyAreaIDCancelledEUTRA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledEUTRA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDCancelledEUTRA (OSCTXT* pctxt, EmergencyAreaIDCancelledEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaIDCancelledEUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledEUTRA: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EmergencyAreaIDCancelledEUTRA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "EmergencyAreaIDCancelledEUTRA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, EmergencyAreaIDCancelledEUTRA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyAreaIDCancelledEUTRA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EmergencyAreaIDCancelledEUTRA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledEUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIDCancelledNR_Item_iE_Extensions_element (OSCTXT* pctxt, CellIDCancelledNR_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledNR_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledNR_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CellIDCancelledNR_Item_iE_Extensions (OSCTXT* pctxt, CellIDCancelledNR_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledNR_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellIDCancelledNR_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CellIDCancelledNR_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellIDCancelledNR_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellIDCancelledNR_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledNR_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CellIDCancelledNR_Item (OSCTXT* pctxt, CellIDCancelledNR_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CellIDCancelledNR-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledNR_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nR_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "nR-CGI");

   stat = asn1PD_NR_CGI (pctxt, &pvalue->nR_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfBroadcasts */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfBroadcasts");

   stat = asn1PD_NumberOfBroadcasts (pctxt, &pvalue->numberOfBroadcasts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CellIDCancelledNR_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledNR_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIDCancelledNR (OSCTXT* pctxt, CellIDCancelledNR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIDCancelledNR");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledNR: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellIDCancelledNR_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellIDCancelledNR-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CellIDCancelledNR_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellIDCancelledNR_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellIDCancelledNR_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDCancelledNR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInTAI_NR_Item_iE_Extensions_element (OSCTXT* pctxt, CancelledCellsInTAI_NR_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_NR_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_NR_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInTAI_NR_Item_iE_Extensions (OSCTXT* pctxt, CancelledCellsInTAI_NR_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_NR_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CancelledCellsInTAI_NR_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CancelledCellsInTAI_NR_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CancelledCellsInTAI_NR_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CancelledCellsInTAI_NR_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_NR_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInTAI_NR_Item (OSCTXT* pctxt, CancelledCellsInTAI_NR_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CancelledCellsInTAI-NR-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_NR_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nR_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "nR-CGI");

   stat = asn1PD_NR_CGI (pctxt, &pvalue->nR_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfBroadcasts */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfBroadcasts");

   stat = asn1PD_NumberOfBroadcasts (pctxt, &pvalue->numberOfBroadcasts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CancelledCellsInTAI_NR_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_NR_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInTAI_NR (OSCTXT* pctxt, CancelledCellsInTAI_NR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CancelledCellsInTAI-NR");

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_NR: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CancelledCellsInTAI_NR_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CancelledCellsInTAI-NR-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CancelledCellsInTAI_NR_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CancelledCellsInTAI_NR_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CancelledCellsInTAI_NR_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInTAI_NR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAICancelledNR_Item_iE_Extensions_element (OSCTXT* pctxt, TAICancelledNR_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledNR_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledNR_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TAICancelledNR_Item_iE_Extensions (OSCTXT* pctxt, TAICancelledNR_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledNR_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAICancelledNR_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TAICancelledNR_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAICancelledNR_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAICancelledNR_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledNR_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TAICancelledNR_Item (OSCTXT* pctxt, TAICancelledNR_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TAICancelledNR-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledNR_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode tAI */
   RTXCTXTPUSHELEMNAME (pctxt, "tAI");

   stat = asn1PD_TAI (pctxt, &pvalue->tAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cancelledCellsInTAI_NR */
   RTXCTXTPUSHELEMNAME (pctxt, "cancelledCellsInTAI-NR");

   stat = asn1PD_CancelledCellsInTAI_NR (pctxt, &pvalue->cancelledCellsInTAI_NR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TAICancelledNR_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledNR_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAICancelledNR (OSCTXT* pctxt, TAICancelledNR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAICancelledNR");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledNR: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAICancelledNR_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAICancelledNR-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, TAICancelledNR_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAICancelledNR_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAICancelledNR_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAICancelledNR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInEAI_NR_Item_iE_Extensions_element (OSCTXT* pctxt, CancelledCellsInEAI_NR_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_NR_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_NR_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInEAI_NR_Item_iE_Extensions (OSCTXT* pctxt, CancelledCellsInEAI_NR_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_NR_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CancelledCellsInEAI_NR_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CancelledCellsInEAI_NR_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CancelledCellsInEAI_NR_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CancelledCellsInEAI_NR_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_NR_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInEAI_NR_Item (OSCTXT* pctxt, CancelledCellsInEAI_NR_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CancelledCellsInEAI-NR-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_NR_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nR_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "nR-CGI");

   stat = asn1PD_NR_CGI (pctxt, &pvalue->nR_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfBroadcasts */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfBroadcasts");

   stat = asn1PD_NumberOfBroadcasts (pctxt, &pvalue->numberOfBroadcasts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CancelledCellsInEAI_NR_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_NR_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CancelledCellsInEAI_NR (OSCTXT* pctxt, CancelledCellsInEAI_NR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CancelledCellsInEAI-NR");

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_NR: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CancelledCellsInEAI_NR_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CancelledCellsInEAI-NR-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CancelledCellsInEAI_NR_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CancelledCellsInEAI_NR_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CancelledCellsInEAI_NR_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CancelledCellsInEAI_NR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDCancelledNR_Item_iE_Extensions_element (OSCTXT* pctxt, EmergencyAreaIDCancelledNR_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledNR_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledNR_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDCancelledNR_Item_iE_Extensions (OSCTXT* pctxt, EmergencyAreaIDCancelledNR_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledNR_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EmergencyAreaIDCancelledNR_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, EmergencyAreaIDCancelledNR_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyAreaIDCancelledNR_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EmergencyAreaIDCancelledNR_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledNR_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDCancelledNR_Item (OSCTXT* pctxt, EmergencyAreaIDCancelledNR_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaIDCancelledNR-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledNR_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode emergencyAreaID */
   RTXCTXTPUSHELEMNAME (pctxt, "emergencyAreaID");

   stat = asn1PD_EmergencyAreaID (pctxt, &pvalue->emergencyAreaID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cancelledCellsInEAI_NR */
   RTXCTXTPUSHELEMNAME (pctxt, "cancelledCellsInEAI-NR");

   stat = asn1PD_CancelledCellsInEAI_NR (pctxt, &pvalue->cancelledCellsInEAI_NR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_EmergencyAreaIDCancelledNR_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledNR_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDCancelledNR (OSCTXT* pctxt, EmergencyAreaIDCancelledNR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaIDCancelledNR");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledNR: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EmergencyAreaIDCancelledNR_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "EmergencyAreaIDCancelledNR-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, EmergencyAreaIDCancelledNR_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyAreaIDCancelledNR_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EmergencyAreaIDCancelledNR_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDCancelledNR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_BroadcastCancelledAreaList_choice_Extensions (OSCTXT* pctxt, BroadcastCancelledAreaList_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastCancelledAreaList_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastCancelledAreaList_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_BroadcastCancelledAreaList (OSCTXT* pctxt, BroadcastCancelledAreaList* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "BroadcastCancelledAreaList");

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastCancelledAreaList: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* cellIDCancelledEUTRA */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "cellIDCancelledEUTRA");

         pvalue->u.cellIDCancelledEUTRA = rtxMemAllocType (pctxt, 
            CellIDCancelledEUTRA);

         if (pvalue->u.cellIDCancelledEUTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellIDCancelledEUTRA (pvalue->u.cellIDCancelledEUTRA);

         stat = asn1PD_CellIDCancelledEUTRA (pctxt, pvalue->u.cellIDCancelledEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tAICancelledEUTRA */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tAICancelledEUTRA");

         pvalue->u.tAICancelledEUTRA = rtxMemAllocType (pctxt, 
            TAICancelledEUTRA);

         if (pvalue->u.tAICancelledEUTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TAICancelledEUTRA (pvalue->u.tAICancelledEUTRA);

         stat = asn1PD_TAICancelledEUTRA (pctxt, pvalue->u.tAICancelledEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* emergencyAreaIDCancelledEUTRA */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "emergencyAreaIDCancelledEUTRA");

         pvalue->u.emergencyAreaIDCancelledEUTRA = rtxMemAllocType (pctxt, 
            EmergencyAreaIDCancelledEUTRA);

         if (pvalue->u.emergencyAreaIDCancelledEUTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EmergencyAreaIDCancelledEUTRA (pvalue->u.emergencyAreaIDCancelledEUTRA);

         stat = asn1PD_EmergencyAreaIDCancelledEUTRA (pctxt, pvalue->u.emergencyAreaIDCancelledEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* cellIDCancelledNR */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "cellIDCancelledNR");

         pvalue->u.cellIDCancelledNR = rtxMemAllocType (pctxt, 
            CellIDCancelledNR);

         if (pvalue->u.cellIDCancelledNR == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellIDCancelledNR (pvalue->u.cellIDCancelledNR);

         stat = asn1PD_CellIDCancelledNR (pctxt, pvalue->u.cellIDCancelledNR);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tAICancelledNR */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "tAICancelledNR");

         pvalue->u.tAICancelledNR = rtxMemAllocType (pctxt, TAICancelledNR);

         if (pvalue->u.tAICancelledNR == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TAICancelledNR (pvalue->u.tAICancelledNR);

         stat = asn1PD_TAICancelledNR (pctxt, pvalue->u.tAICancelledNR);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* emergencyAreaIDCancelledNR */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "emergencyAreaIDCancelledNR");

         pvalue->u.emergencyAreaIDCancelledNR = rtxMemAllocType (pctxt, 
            EmergencyAreaIDCancelledNR);

         if (pvalue->u.emergencyAreaIDCancelledNR == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EmergencyAreaIDCancelledNR (pvalue->u.emergencyAreaIDCancelledNR);

         stat = asn1PD_EmergencyAreaIDCancelledNR (pctxt, pvalue->u.emergencyAreaIDCancelledNR);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            BroadcastCancelledAreaList_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BroadcastCancelledAreaList_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_BroadcastCancelledAreaList_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastCancelledAreaList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIDBroadcastEUTRA_Item_iE_Extensions_element (OSCTXT* pctxt, CellIDBroadcastEUTRA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastEUTRA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastEUTRA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CellIDBroadcastEUTRA_Item_iE_Extensions (OSCTXT* pctxt, CellIDBroadcastEUTRA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastEUTRA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellIDBroadcastEUTRA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CellIDBroadcastEUTRA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellIDBroadcastEUTRA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellIDBroadcastEUTRA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastEUTRA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CellIDBroadcastEUTRA_Item (OSCTXT* pctxt, CellIDBroadcastEUTRA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CellIDBroadcastEUTRA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastEUTRA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode eUTRA_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGI");

   stat = asn1PD_EUTRA_CGI (pctxt, &pvalue->eUTRA_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CellIDBroadcastEUTRA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastEUTRA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIDBroadcastEUTRA (OSCTXT* pctxt, CellIDBroadcastEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIDBroadcastEUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastEUTRA: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellIDBroadcastEUTRA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellIDBroadcastEUTRA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CellIDBroadcastEUTRA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellIDBroadcastEUTRA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellIDBroadcastEUTRA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastEUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInTAI_EUTRA_Item_iE_Extensions_element (OSCTXT* pctxt, CompletedCellsInTAI_EUTRA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_EUTRA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_EUTRA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInTAI_EUTRA_Item_iE_Extensions (OSCTXT* pctxt, CompletedCellsInTAI_EUTRA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_EUTRA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CompletedCellsInTAI_EUTRA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CompletedCellsInTAI_EUTRA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CompletedCellsInTAI_EUTRA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CompletedCellsInTAI_EUTRA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_EUTRA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInTAI_EUTRA_Item (OSCTXT* pctxt, CompletedCellsInTAI_EUTRA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CompletedCellsInTAI-EUTRA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_EUTRA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode eUTRA_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGI");

   stat = asn1PD_EUTRA_CGI (pctxt, &pvalue->eUTRA_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CompletedCellsInTAI_EUTRA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_EUTRA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInTAI_EUTRA (OSCTXT* pctxt, CompletedCellsInTAI_EUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CompletedCellsInTAI-EUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_EUTRA: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CompletedCellsInTAI_EUTRA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CompletedCellsInTAI-EUTRA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CompletedCellsInTAI_EUTRA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CompletedCellsInTAI_EUTRA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CompletedCellsInTAI_EUTRA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_EUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAIBroadcastEUTRA_Item_iE_Extensions_element (OSCTXT* pctxt, TAIBroadcastEUTRA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastEUTRA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastEUTRA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TAIBroadcastEUTRA_Item_iE_Extensions (OSCTXT* pctxt, TAIBroadcastEUTRA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastEUTRA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAIBroadcastEUTRA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TAIBroadcastEUTRA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAIBroadcastEUTRA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAIBroadcastEUTRA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastEUTRA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TAIBroadcastEUTRA_Item (OSCTXT* pctxt, TAIBroadcastEUTRA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TAIBroadcastEUTRA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastEUTRA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode tAI */
   RTXCTXTPUSHELEMNAME (pctxt, "tAI");

   stat = asn1PD_TAI (pctxt, &pvalue->tAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode completedCellsInTAI_EUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "completedCellsInTAI-EUTRA");

   stat = asn1PD_CompletedCellsInTAI_EUTRA (pctxt, &pvalue->completedCellsInTAI_EUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TAIBroadcastEUTRA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastEUTRA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAIBroadcastEUTRA (OSCTXT* pctxt, TAIBroadcastEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAIBroadcastEUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastEUTRA: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAIBroadcastEUTRA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAIBroadcastEUTRA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, TAIBroadcastEUTRA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAIBroadcastEUTRA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAIBroadcastEUTRA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastEUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInEAI_EUTRA_Item_iE_Extensions_element (OSCTXT* pctxt, CompletedCellsInEAI_EUTRA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_EUTRA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_EUTRA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInEAI_EUTRA_Item_iE_Extensions (OSCTXT* pctxt, CompletedCellsInEAI_EUTRA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_EUTRA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CompletedCellsInEAI_EUTRA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CompletedCellsInEAI_EUTRA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CompletedCellsInEAI_EUTRA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CompletedCellsInEAI_EUTRA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_EUTRA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInEAI_EUTRA_Item (OSCTXT* pctxt, CompletedCellsInEAI_EUTRA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CompletedCellsInEAI-EUTRA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_EUTRA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode eUTRA_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGI");

   stat = asn1PD_EUTRA_CGI (pctxt, &pvalue->eUTRA_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CompletedCellsInEAI_EUTRA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_EUTRA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInEAI_EUTRA (OSCTXT* pctxt, CompletedCellsInEAI_EUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CompletedCellsInEAI-EUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_EUTRA: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CompletedCellsInEAI_EUTRA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CompletedCellsInEAI-EUTRA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CompletedCellsInEAI_EUTRA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CompletedCellsInEAI_EUTRA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CompletedCellsInEAI_EUTRA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_EUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions_element (OSCTXT* pctxt, EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions (OSCTXT* pctxt, EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDBroadcastEUTRA_Item (OSCTXT* pctxt, EmergencyAreaIDBroadcastEUTRA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaIDBroadcastEUTRA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastEUTRA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode emergencyAreaID */
   RTXCTXTPUSHELEMNAME (pctxt, "emergencyAreaID");

   stat = asn1PD_EmergencyAreaID (pctxt, &pvalue->emergencyAreaID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode completedCellsInEAI_EUTRA */
   RTXCTXTPUSHELEMNAME (pctxt, "completedCellsInEAI-EUTRA");

   stat = asn1PD_CompletedCellsInEAI_EUTRA (pctxt, &pvalue->completedCellsInEAI_EUTRA);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_EmergencyAreaIDBroadcastEUTRA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastEUTRA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDBroadcastEUTRA (OSCTXT* pctxt, EmergencyAreaIDBroadcastEUTRA* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaIDBroadcastEUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastEUTRA: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EmergencyAreaIDBroadcastEUTRA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "EmergencyAreaIDBroadcastEUTRA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, EmergencyAreaIDBroadcastEUTRA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyAreaIDBroadcastEUTRA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EmergencyAreaIDBroadcastEUTRA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastEUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIDBroadcastNR_Item_iE_Extensions_element (OSCTXT* pctxt, CellIDBroadcastNR_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastNR_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastNR_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CellIDBroadcastNR_Item_iE_Extensions (OSCTXT* pctxt, CellIDBroadcastNR_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastNR_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellIDBroadcastNR_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CellIDBroadcastNR_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellIDBroadcastNR_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellIDBroadcastNR_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastNR_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CellIDBroadcastNR_Item (OSCTXT* pctxt, CellIDBroadcastNR_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CellIDBroadcastNR-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastNR_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nR_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "nR-CGI");

   stat = asn1PD_NR_CGI (pctxt, &pvalue->nR_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CellIDBroadcastNR_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastNR_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIDBroadcastNR (OSCTXT* pctxt, CellIDBroadcastNR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIDBroadcastNR");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastNR: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellIDBroadcastNR_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CellIDBroadcastNR-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CellIDBroadcastNR_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellIDBroadcastNR_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellIDBroadcastNR_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDBroadcastNR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInTAI_NR_Item_iE_Extensions_element (OSCTXT* pctxt, CompletedCellsInTAI_NR_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_NR_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_NR_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInTAI_NR_Item_iE_Extensions (OSCTXT* pctxt, CompletedCellsInTAI_NR_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_NR_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CompletedCellsInTAI_NR_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CompletedCellsInTAI_NR_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CompletedCellsInTAI_NR_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CompletedCellsInTAI_NR_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_NR_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInTAI_NR_Item (OSCTXT* pctxt, CompletedCellsInTAI_NR_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CompletedCellsInTAI-NR-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_NR_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nR_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "nR-CGI");

   stat = asn1PD_NR_CGI (pctxt, &pvalue->nR_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CompletedCellsInTAI_NR_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_NR_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInTAI_NR (OSCTXT* pctxt, CompletedCellsInTAI_NR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CompletedCellsInTAI-NR");

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_NR: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CompletedCellsInTAI_NR_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CompletedCellsInTAI-NR-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CompletedCellsInTAI_NR_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CompletedCellsInTAI_NR_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CompletedCellsInTAI_NR_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInTAI_NR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAIBroadcastNR_Item_iE_Extensions_element (OSCTXT* pctxt, TAIBroadcastNR_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastNR_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastNR_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TAIBroadcastNR_Item_iE_Extensions (OSCTXT* pctxt, TAIBroadcastNR_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastNR_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAIBroadcastNR_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TAIBroadcastNR_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAIBroadcastNR_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAIBroadcastNR_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastNR_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TAIBroadcastNR_Item (OSCTXT* pctxt, TAIBroadcastNR_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TAIBroadcastNR-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastNR_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode tAI */
   RTXCTXTPUSHELEMNAME (pctxt, "tAI");

   stat = asn1PD_TAI (pctxt, &pvalue->tAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode completedCellsInTAI_NR */
   RTXCTXTPUSHELEMNAME (pctxt, "completedCellsInTAI-NR");

   stat = asn1PD_CompletedCellsInTAI_NR (pctxt, &pvalue->completedCellsInTAI_NR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TAIBroadcastNR_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastNR_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAIBroadcastNR (OSCTXT* pctxt, TAIBroadcastNR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAIBroadcastNR");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastNR: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAIBroadcastNR_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAIBroadcastNR-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, TAIBroadcastNR_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAIBroadcastNR_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAIBroadcastNR_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIBroadcastNR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInEAI_NR_Item_iE_Extensions_element (OSCTXT* pctxt, CompletedCellsInEAI_NR_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_NR_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_NR_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInEAI_NR_Item_iE_Extensions (OSCTXT* pctxt, CompletedCellsInEAI_NR_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_NR_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CompletedCellsInEAI_NR_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CompletedCellsInEAI_NR_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CompletedCellsInEAI_NR_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CompletedCellsInEAI_NR_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_NR_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInEAI_NR_Item (OSCTXT* pctxt, CompletedCellsInEAI_NR_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CompletedCellsInEAI-NR-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_NR_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nR_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "nR-CGI");

   stat = asn1PD_NR_CGI (pctxt, &pvalue->nR_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CompletedCellsInEAI_NR_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_NR_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CompletedCellsInEAI_NR (OSCTXT* pctxt, CompletedCellsInEAI_NR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CompletedCellsInEAI-NR");

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_NR: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CompletedCellsInEAI_NR_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CompletedCellsInEAI-NR-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CompletedCellsInEAI_NR_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CompletedCellsInEAI_NR_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CompletedCellsInEAI_NR_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CompletedCellsInEAI_NR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDBroadcastNR_Item_iE_Extensions_element (OSCTXT* pctxt, EmergencyAreaIDBroadcastNR_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastNR_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastNR_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDBroadcastNR_Item_iE_Extensions (OSCTXT* pctxt, EmergencyAreaIDBroadcastNR_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastNR_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EmergencyAreaIDBroadcastNR_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, EmergencyAreaIDBroadcastNR_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyAreaIDBroadcastNR_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EmergencyAreaIDBroadcastNR_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastNR_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDBroadcastNR_Item (OSCTXT* pctxt, EmergencyAreaIDBroadcastNR_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaIDBroadcastNR-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastNR_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode emergencyAreaID */
   RTXCTXTPUSHELEMNAME (pctxt, "emergencyAreaID");

   stat = asn1PD_EmergencyAreaID (pctxt, &pvalue->emergencyAreaID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode completedCellsInEAI_NR */
   RTXCTXTPUSHELEMNAME (pctxt, "completedCellsInEAI-NR");

   stat = asn1PD_CompletedCellsInEAI_NR (pctxt, &pvalue->completedCellsInEAI_NR);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_EmergencyAreaIDBroadcastNR_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastNR_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDBroadcastNR (OSCTXT* pctxt, EmergencyAreaIDBroadcastNR* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaIDBroadcastNR");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastNR: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EmergencyAreaIDBroadcastNR_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "EmergencyAreaIDBroadcastNR-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, EmergencyAreaIDBroadcastNR_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyAreaIDBroadcastNR_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EmergencyAreaIDBroadcastNR_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDBroadcastNR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_BroadcastCompletedAreaList_choice_Extensions (OSCTXT* pctxt, BroadcastCompletedAreaList_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastCompletedAreaList_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastCompletedAreaList_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_BroadcastCompletedAreaList (OSCTXT* pctxt, BroadcastCompletedAreaList* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "BroadcastCompletedAreaList");

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastCompletedAreaList: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* cellIDBroadcastEUTRA */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "cellIDBroadcastEUTRA");

         pvalue->u.cellIDBroadcastEUTRA = rtxMemAllocType (pctxt, 
            CellIDBroadcastEUTRA);

         if (pvalue->u.cellIDBroadcastEUTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellIDBroadcastEUTRA (pvalue->u.cellIDBroadcastEUTRA);

         stat = asn1PD_CellIDBroadcastEUTRA (pctxt, pvalue->u.cellIDBroadcastEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tAIBroadcastEUTRA */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "tAIBroadcastEUTRA");

         pvalue->u.tAIBroadcastEUTRA = rtxMemAllocType (pctxt, 
            TAIBroadcastEUTRA);

         if (pvalue->u.tAIBroadcastEUTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TAIBroadcastEUTRA (pvalue->u.tAIBroadcastEUTRA);

         stat = asn1PD_TAIBroadcastEUTRA (pctxt, pvalue->u.tAIBroadcastEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* emergencyAreaIDBroadcastEUTRA */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "emergencyAreaIDBroadcastEUTRA");

         pvalue->u.emergencyAreaIDBroadcastEUTRA = rtxMemAllocType (pctxt, 
            EmergencyAreaIDBroadcastEUTRA);

         if (pvalue->u.emergencyAreaIDBroadcastEUTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EmergencyAreaIDBroadcastEUTRA (pvalue->u.emergencyAreaIDBroadcastEUTRA);

         stat = asn1PD_EmergencyAreaIDBroadcastEUTRA (pctxt, pvalue->u.emergencyAreaIDBroadcastEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* cellIDBroadcastNR */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "cellIDBroadcastNR");

         pvalue->u.cellIDBroadcastNR = rtxMemAllocType (pctxt, 
            CellIDBroadcastNR);

         if (pvalue->u.cellIDBroadcastNR == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellIDBroadcastNR (pvalue->u.cellIDBroadcastNR);

         stat = asn1PD_CellIDBroadcastNR (pctxt, pvalue->u.cellIDBroadcastNR);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tAIBroadcastNR */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "tAIBroadcastNR");

         pvalue->u.tAIBroadcastNR = rtxMemAllocType (pctxt, TAIBroadcastNR);

         if (pvalue->u.tAIBroadcastNR == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TAIBroadcastNR (pvalue->u.tAIBroadcastNR);

         stat = asn1PD_TAIBroadcastNR (pctxt, pvalue->u.tAIBroadcastNR);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* emergencyAreaIDBroadcastNR */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "emergencyAreaIDBroadcastNR");

         pvalue->u.emergencyAreaIDBroadcastNR = rtxMemAllocType (pctxt, 
            EmergencyAreaIDBroadcastNR);

         if (pvalue->u.emergencyAreaIDBroadcastNR == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EmergencyAreaIDBroadcastNR (pvalue->u.emergencyAreaIDBroadcastNR);

         stat = asn1PD_EmergencyAreaIDBroadcastNR (pctxt, pvalue->u.emergencyAreaIDBroadcastNR);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            BroadcastCompletedAreaList_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BroadcastCompletedAreaList_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_BroadcastCompletedAreaList_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastCompletedAreaList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SliceSupportItem_iE_Extensions_element (OSCTXT* pctxt, SliceSupportItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceSupportItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceSupportItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SliceSupportItem_iE_Extensions (OSCTXT* pctxt, SliceSupportItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceSupportItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SliceSupportItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SliceSupportItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SliceSupportItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SliceSupportItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceSupportItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SliceSupportItem (OSCTXT* pctxt, SliceSupportItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SliceSupportItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceSupportItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode s_NSSAI */
   RTXCTXTPUSHELEMNAME (pctxt, "s-NSSAI");

   stat = asn1PD_S_NSSAI (pctxt, &pvalue->s_NSSAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SliceSupportItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceSupportItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SliceSupportList (OSCTXT* pctxt, SliceSupportList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SliceSupportList");

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceSupportList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SliceSupportItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SliceSupportItem", xx1);

      rtxDListAllocNodeAndData (pctxt, SliceSupportItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SliceSupportItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SliceSupportItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceSupportList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_BroadcastPLMNItem_iE_Extensions_element (OSCTXT* pctxt, BroadcastPLMNItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastPLMNItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastPLMNItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_BroadcastPLMNItem_iE_Extensions (OSCTXT* pctxt, BroadcastPLMNItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastPLMNItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      BroadcastPLMNItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, BroadcastPLMNItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BroadcastPLMNItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_BroadcastPLMNItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastPLMNItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_BroadcastPLMNItem (OSCTXT* pctxt, BroadcastPLMNItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "BroadcastPLMNItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastPLMNItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tAISliceSupportList */
   RTXCTXTPUSHELEMNAME (pctxt, "tAISliceSupportList");

   stat = asn1PD_SliceSupportList (pctxt, &pvalue->tAISliceSupportList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_BroadcastPLMNItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastPLMNItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_BroadcastPLMNList (OSCTXT* pctxt, BroadcastPLMNList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BroadcastPLMNList");

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastPLMNList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(12), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      BroadcastPLMNItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BroadcastPLMNItem", xx1);

      rtxDListAllocNodeAndData (pctxt, BroadcastPLMNItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BroadcastPLMNItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_BroadcastPLMNItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_BroadcastPLMNList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_Cause_choice_Extensions (OSCTXT* pctxt, Cause_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Cause_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_Cause_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_Cause (OSCTXT* pctxt, Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "Cause");

   RTDIAGSTRM2 (pctxt,"asn1PD_Cause: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* radioNetwork */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "radioNetwork");

         stat = asn1PD_CauseRadioNetwork (pctxt, &pvalue->u.radioNetwork);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* transport */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "transport");

         stat = asn1PD_CauseTransport (pctxt, &pvalue->u.transport);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* nas */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "nas");

         stat = asn1PD_CauseNas (pctxt, &pvalue->u.nas);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* protocol */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "protocol");

         stat = asn1PD_CauseProtocol (pctxt, &pvalue->u.protocol);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* misc */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "misc");

         stat = asn1PD_CauseMisc (pctxt, &pvalue->u.misc);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            Cause_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_Cause_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Cause: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EUTRA_CGIList (OSCTXT* pctxt, EUTRA_CGIList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EUTRA-CGIList");

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRA_CGIList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EUTRA_CGI* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "EUTRA-CGI", xx1);

      rtxDListAllocNodeAndData (pctxt, EUTRA_CGI, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EUTRA_CGI (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EUTRA_CGI (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRA_CGIList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NR_CGIList (OSCTXT* pctxt, NR_CGIList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NR-CGIList");

   RTDIAGSTRM2 (pctxt,"asn1PD_NR_CGIList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16384), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NR_CGI* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NR-CGI", xx1);

      rtxDListAllocNodeAndData (pctxt, NR_CGI, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NR_CGI (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NR_CGI (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NR_CGIList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellIDListForRestart_choice_Extensions (OSCTXT* pctxt, CellIDListForRestart_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDListForRestart_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDListForRestart_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CellIDListForRestart (OSCTXT* pctxt, CellIDListForRestart* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIDListForRestart");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDListForRestart: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* eUTRA_CGIListforRestart */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGIListforRestart");

         pvalue->u.eUTRA_CGIListforRestart = rtxMemAllocType (pctxt, 
            EUTRA_CGIList);

         if (pvalue->u.eUTRA_CGIListforRestart == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EUTRA_CGIList (pvalue->u.eUTRA_CGIListforRestart);

         stat = asn1PD_EUTRA_CGIList (pctxt, pvalue->u.eUTRA_CGIListforRestart);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* nR_CGIListforRestart */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "nR-CGIListforRestart");

         pvalue->u.nR_CGIListforRestart = rtxMemAllocType (pctxt, NR_CGIList);

         if (pvalue->u.nR_CGIListforRestart == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NR_CGIList (pvalue->u.nR_CGIListforRestart);

         stat = asn1PD_NR_CGIList (pctxt, pvalue->u.nR_CGIListforRestart);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            CellIDListForRestart_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellIDListForRestart_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_CellIDListForRestart_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellIDListForRestart: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellType_iE_Extensions_element (OSCTXT* pctxt, CellType_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellType_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellType_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CellType_iE_Extensions (OSCTXT* pctxt, CellType_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellType_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellType_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CellType_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellType_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellType_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellType_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CellType (OSCTXT* pctxt, CellType* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CellType");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode cellSize */
   RTXCTXTPUSHELEMNAME (pctxt, "cellSize");

   stat = asn1PD_CellSize (pctxt, &pvalue->cellSize);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CellType_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellType: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ExpectedUEActivityBehaviour_iE_Extensions_element (OSCTXT* pctxt, ExpectedUEActivityBehaviour_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEActivityBehaviour_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEActivityBehaviour_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_ExpectedUEActivityBehaviour_iE_Extensions (OSCTXT* pctxt, ExpectedUEActivityBehaviour_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEActivityBehaviour_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ExpectedUEActivityBehaviour_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ExpectedUEActivityBehaviour_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ExpectedUEActivityBehaviour_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ExpectedUEActivityBehaviour_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEActivityBehaviour_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_ExpectedUEActivityBehaviour (OSCTXT* pctxt, ExpectedUEActivityBehaviour* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "ExpectedUEActivityBehaviour");

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEActivityBehaviour: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode expectedActivityPeriod */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "expectedActivityPeriod");

      pvalue->m.expectedActivityPeriodPresent = 1;

      stat = asn1PD_ExpectedActivityPeriod (pctxt, &pvalue->expectedActivityPeriod);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode expectedIdlePeriod */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "expectedIdlePeriod");

      pvalue->m.expectedIdlePeriodPresent = 1;

      stat = asn1PD_ExpectedIdlePeriod (pctxt, &pvalue->expectedIdlePeriod);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sourceOfUEActivityBehaviourInformation */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sourceOfUEActivityBehaviourInformation");

      pvalue->m.sourceOfUEActivityBehaviourInformationPresent = 1;

      stat = asn1PD_SourceOfUEActivityBehaviourInformation (pctxt, &pvalue->sourceOfUEActivityBehaviourInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ExpectedUEActivityBehaviour_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEActivityBehaviour: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ExpectedUEMovingTrajectoryItem_iE_Extensions_element (OSCTXT* pctxt, ExpectedUEMovingTrajectoryItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEMovingTrajectoryItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEMovingTrajectoryItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_ExpectedUEMovingTrajectoryItem_iE_Extensions (OSCTXT* pctxt, ExpectedUEMovingTrajectoryItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEMovingTrajectoryItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ExpectedUEMovingTrajectoryItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ExpectedUEMovingTrajectoryItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ExpectedUEMovingTrajectoryItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ExpectedUEMovingTrajectoryItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEMovingTrajectoryItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_ExpectedUEMovingTrajectoryItem (OSCTXT* pctxt, ExpectedUEMovingTrajectoryItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ExpectedUEMovingTrajectoryItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEMovingTrajectoryItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nGRAN_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "nGRAN-CGI");

   stat = asn1PD_NGRAN_CGI (pctxt, &pvalue->nGRAN_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeStayedInCell */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timeStayedInCell");

      pvalue->m.timeStayedInCellPresent = 1;

      if (pctxt->buffer.aligned) {
         int stat2 = PD_BYTE_ALIGN (pctxt);
         if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
      }
      PU_NEWFIELD (pctxt, "constrainted int");

      stat = rtxDecBitsToUInt16 (pctxt, &pvalue->timeStayedInCell, pctxt->buffer.aligned ? 16 : 12);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      if (pvalue->timeStayedInCell > 4095){
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, 4095);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      PU_SETBITCOUNT (pctxt);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ExpectedUEMovingTrajectoryItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEMovingTrajectoryItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ExpectedUEMovingTrajectory (OSCTXT* pctxt, ExpectedUEMovingTrajectory* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExpectedUEMovingTrajectory");

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEMovingTrajectory: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ExpectedUEMovingTrajectoryItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExpectedUEMovingTrajectoryItem", xx1);

      rtxDListAllocNodeAndData (pctxt, ExpectedUEMovingTrajectoryItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ExpectedUEMovingTrajectoryItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ExpectedUEMovingTrajectoryItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEMovingTrajectory: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ExpectedUEBehaviour_iE_Extensions_element (OSCTXT* pctxt, ExpectedUEBehaviour_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEBehaviour_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEBehaviour_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_ExpectedUEBehaviour_iE_Extensions (OSCTXT* pctxt, ExpectedUEBehaviour_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEBehaviour_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ExpectedUEBehaviour_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ExpectedUEBehaviour_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ExpectedUEBehaviour_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ExpectedUEBehaviour_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEBehaviour_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_ExpectedUEBehaviour (OSCTXT* pctxt, ExpectedUEBehaviour* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "ExpectedUEBehaviour");

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEBehaviour: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode expectedUEActivityBehaviour */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "expectedUEActivityBehaviour");

      pvalue->m.expectedUEActivityBehaviourPresent = 1;

      stat = asn1PD_ExpectedUEActivityBehaviour (pctxt, &pvalue->expectedUEActivityBehaviour);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode expectedHOInterval */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "expectedHOInterval");

      pvalue->m.expectedHOIntervalPresent = 1;

      stat = asn1PD_ExpectedHOInterval (pctxt, &pvalue->expectedHOInterval);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode expectedUEMobility */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "expectedUEMobility");

      pvalue->m.expectedUEMobilityPresent = 1;

      stat = asn1PD_ExpectedUEMobility (pctxt, &pvalue->expectedUEMobility);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode expectedUEMovingTrajectory */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "expectedUEMovingTrajectory");

      pvalue->m.expectedUEMovingTrajectoryPresent = 1;

      stat = asn1PD_ExpectedUEMovingTrajectory (pctxt, &pvalue->expectedUEMovingTrajectory);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ExpectedUEBehaviour_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ExpectedUEBehaviour: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CNAssistedRANTuning_iE_Extensions_element (OSCTXT* pctxt, CNAssistedRANTuning_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CNAssistedRANTuning_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CNAssistedRANTuning_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CNAssistedRANTuning_iE_Extensions (OSCTXT* pctxt, CNAssistedRANTuning_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CNAssistedRANTuning_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CNAssistedRANTuning_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CNAssistedRANTuning_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CNAssistedRANTuning_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CNAssistedRANTuning_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CNAssistedRANTuning_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CNAssistedRANTuning (OSCTXT* pctxt, CNAssistedRANTuning* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "CNAssistedRANTuning");

   RTDIAGSTRM2 (pctxt,"asn1PD_CNAssistedRANTuning: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode expectedUEBehaviour */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "expectedUEBehaviour");

      pvalue->m.expectedUEBehaviourPresent = 1;

      stat = asn1PD_ExpectedUEBehaviour (pctxt, &pvalue->expectedUEBehaviour);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CNAssistedRANTuning_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CNAssistedRANTuning: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CNTypeRestrictionsForEquivalentItem_iE_Extensions_element (OSCTXT* pctxt, CNTypeRestrictionsForEquivalentItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForEquivalentItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForEquivalentItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CNTypeRestrictionsForEquivalentItem_iE_Extensions (OSCTXT* pctxt, CNTypeRestrictionsForEquivalentItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForEquivalentItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CNTypeRestrictionsForEquivalentItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CNTypeRestrictionsForEquivalentItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CNTypeRestrictionsForEquivalentItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CNTypeRestrictionsForEquivalentItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForEquivalentItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CNTypeRestrictionsForEquivalentItem (OSCTXT* pctxt, CNTypeRestrictionsForEquivalentItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CNTypeRestrictionsForEquivalentItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForEquivalentItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode plmnIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "plmnIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->plmnIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cn_Type */
   RTXCTXTPUSHELEMNAME (pctxt, "cn-Type");

   stat = asn1PD_CNTypeRestrictionsForEquivalentItem_cn_Type (pctxt, &pvalue->cn_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CNTypeRestrictionsForEquivalentItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForEquivalentItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CNTypeRestrictionsForEquivalent (OSCTXT* pctxt, CNTypeRestrictionsForEquivalent* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CNTypeRestrictionsForEquivalent");

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForEquivalent: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(15), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CNTypeRestrictionsForEquivalentItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CNTypeRestrictionsForEquivalentItem", xx1);

      rtxDListAllocNodeAndData (pctxt, CNTypeRestrictionsForEquivalentItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CNTypeRestrictionsForEquivalentItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CNTypeRestrictionsForEquivalentItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CNTypeRestrictionsForEquivalent: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEIdentityIndexValue_choice_Extensions (OSCTXT* pctxt, UEIdentityIndexValue_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEIdentityIndexValue_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEIdentityIndexValue_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UEIdentityIndexValue (OSCTXT* pctxt, UEIdentityIndexValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UEIdentityIndexValue");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEIdentityIndexValue: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* indexLength10 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "indexLength10");

         pvalue->u.indexLength10 = rtxMemAllocTypeZ (pctxt, ASN1BitStr32);

         if (pvalue->u.indexLength10 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = pd_BitString32 (pctxt, pvalue->u.indexLength10
            , OSUINTCONST(10), OSUINTCONST(10));

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            UEIdentityIndexValue_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEIdentityIndexValue_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_UEIdentityIndexValue_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEIdentityIndexValue: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAIListForInactiveItem_iE_Extensions_element (OSCTXT* pctxt, TAIListForInactiveItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForInactiveItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForInactiveItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TAIListForInactiveItem_iE_Extensions (OSCTXT* pctxt, TAIListForInactiveItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForInactiveItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAIListForInactiveItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TAIListForInactiveItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAIListForInactiveItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAIListForInactiveItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForInactiveItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TAIListForInactiveItem (OSCTXT* pctxt, TAIListForInactiveItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TAIListForInactiveItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForInactiveItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode tAI */
   RTXCTXTPUSHELEMNAME (pctxt, "tAI");

   stat = asn1PD_TAI (pctxt, &pvalue->tAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TAIListForInactiveItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForInactiveItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAIListForInactive (OSCTXT* pctxt, TAIListForInactive* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAIListForInactive");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForInactive: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAIListForInactiveItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAIListForInactiveItem", xx1);

      rtxDListAllocNodeAndData (pctxt, TAIListForInactiveItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAIListForInactiveItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAIListForInactiveItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForInactive: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CoreNetworkAssistanceInformationForInactive_iE_Extensions_element (OSCTXT* pctxt, CoreNetworkAssistanceInformationForInactive_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CoreNetworkAssistanceInformationForInactive_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CoreNetworkAssistanceInformationForInactive_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CoreNetworkAssistanceInformationForInactive_iE_Extensions (OSCTXT* pctxt, CoreNetworkAssistanceInformationForInactive_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CoreNetworkAssistanceInformationForInactive_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CoreNetworkAssistanceInformationForInactive_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CoreNetworkAssistanceInformationForInactive_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CoreNetworkAssistanceInformationForInactive_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CoreNetworkAssistanceInformationForInactive_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CoreNetworkAssistanceInformationForInactive_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CoreNetworkAssistanceInformationForInactive (OSCTXT* pctxt, CoreNetworkAssistanceInformationForInactive* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "CoreNetworkAssistanceInformationForInactive");

   RTDIAGSTRM2 (pctxt,"asn1PD_CoreNetworkAssistanceInformationForInactive: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode uEIdentityIndexValue */
   RTXCTXTPUSHELEMNAME (pctxt, "uEIdentityIndexValue");

   stat = asn1PD_UEIdentityIndexValue (pctxt, &pvalue->uEIdentityIndexValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uESpecificDRX */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uESpecificDRX");

      pvalue->m.uESpecificDRXPresent = 1;

      stat = asn1PD_PagingDRX (pctxt, &pvalue->uESpecificDRX);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode periodicRegistrationUpdateTimer */
   RTXCTXTPUSHELEMNAME (pctxt, "periodicRegistrationUpdateTimer");

   stat = asn1PD_PeriodicRegistrationUpdateTimer (pctxt, &pvalue->periodicRegistrationUpdateTimer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mICOModeIndication */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "mICOModeIndication");

      pvalue->m.mICOModeIndicationPresent = 1;

      stat = asn1PD_MICOModeIndication (pctxt, &pvalue->mICOModeIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode tAIListForInactive */
   RTXCTXTPUSHELEMNAME (pctxt, "tAIListForInactive");

   stat = asn1PD_TAIListForInactive (pctxt, &pvalue->tAIListForInactive);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode expectedUEBehaviour */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "expectedUEBehaviour");

      pvalue->m.expectedUEBehaviourPresent = 1;

      stat = asn1PD_ExpectedUEBehaviour (pctxt, &pvalue->expectedUEBehaviour);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CoreNetworkAssistanceInformationForInactive_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CoreNetworkAssistanceInformationForInactive: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_COUNTValueForPDCP_SN12_iE_Extensions_element (OSCTXT* pctxt, COUNTValueForPDCP_SN12_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN12_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN12_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_COUNTValueForPDCP_SN12_iE_Extensions (OSCTXT* pctxt, COUNTValueForPDCP_SN12_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN12_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      COUNTValueForPDCP_SN12_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, COUNTValueForPDCP_SN12_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_COUNTValueForPDCP_SN12_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_COUNTValueForPDCP_SN12_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN12_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_COUNTValueForPDCP_SN12 (OSCTXT* pctxt, COUNTValueForPDCP_SN12* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "COUNTValueForPDCP-SN12");

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN12: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDCP_SN12 */
   RTXCTXTPUSHELEMNAME (pctxt, "pDCP-SN12");

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToUInt16 (pctxt, &pvalue->pDCP_SN12, pctxt->buffer.aligned ? 16 : 12);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (pvalue->pDCP_SN12 > 4095){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, 4095);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hFN_PDCP_SN12 */
   RTXCTXTPUSHELEMNAME (pctxt, "hFN-PDCP-SN12");

   stat = pd_ConsUnsigned (pctxt, &pvalue->hFN_PDCP_SN12, 0, 1048575);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_COUNTValueForPDCP_SN12_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN12: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_COUNTValueForPDCP_SN18_iE_Extensions_element (OSCTXT* pctxt, COUNTValueForPDCP_SN18_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN18_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN18_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_COUNTValueForPDCP_SN18_iE_Extensions (OSCTXT* pctxt, COUNTValueForPDCP_SN18_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN18_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      COUNTValueForPDCP_SN18_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, COUNTValueForPDCP_SN18_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_COUNTValueForPDCP_SN18_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_COUNTValueForPDCP_SN18_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN18_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_COUNTValueForPDCP_SN18 (OSCTXT* pctxt, COUNTValueForPDCP_SN18* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "COUNTValueForPDCP-SN18");

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN18: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDCP_SN18 */
   RTXCTXTPUSHELEMNAME (pctxt, "pDCP-SN18");

   stat = pd_ConsUnsigned (pctxt, &pvalue->pDCP_SN18, 0, 262143);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hFN_PDCP_SN18 */
   RTXCTXTPUSHELEMNAME (pctxt, "hFN-PDCP-SN18");

   if (pctxt->buffer.aligned) {
      int stat2 = PD_BYTE_ALIGN (pctxt);
      if (stat2 != 0) return LOG_RTERR (pctxt, stat2);
   }
   PU_NEWFIELD (pctxt, "constrainted int");

   stat = rtxDecBitsToUInt16 (pctxt, &pvalue->hFN_PDCP_SN18, pctxt->buffer.aligned ? 16 : 14);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (pvalue->hFN_PDCP_SN18 > 16383){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, 16383);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_COUNTValueForPDCP_SN18_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_COUNTValueForPDCP_SN18: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CriticalityDiagnostics_IE_Item_iE_Extensions_element (OSCTXT* pctxt, CriticalityDiagnostics_IE_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CriticalityDiagnostics_IE_Item_iE_Extensions (OSCTXT* pctxt, CriticalityDiagnostics_IE_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CriticalityDiagnostics_IE_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CriticalityDiagnostics_IE_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics_IE_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CriticalityDiagnostics_IE_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CriticalityDiagnostics_IE_Item (OSCTXT* pctxt, CriticalityDiagnostics_IE_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics-IE-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode iECriticality */
   RTXCTXTPUSHELEMNAME (pctxt, "iECriticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->iECriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "iE-ID");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode typeOfError */
   RTXCTXTPUSHELEMNAME (pctxt, "typeOfError");

   stat = asn1PD_TypeOfError (pctxt, &pvalue->typeOfError);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CriticalityDiagnostics_IE_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, CriticalityDiagnostics_IE_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics-IE-List");

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_List: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CriticalityDiagnostics_IE_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CriticalityDiagnostics-IE-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, CriticalityDiagnostics_IE_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics_IE_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CriticalityDiagnostics_IE_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_IE_List: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CriticalityDiagnostics_iE_Extensions_element (OSCTXT* pctxt, CriticalityDiagnostics_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CriticalityDiagnostics_iE_Extensions (OSCTXT* pctxt, CriticalityDiagnostics_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CriticalityDiagnostics_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CriticalityDiagnostics_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CriticalityDiagnostics_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_CriticalityDiagnostics (OSCTXT* pctxt, CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics");

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode procedureCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

      pvalue->m.procedureCodePresent = 1;

      stat = asn1PD_ProcedureCode (pctxt, &pvalue->procedureCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode triggeringMessage */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "triggeringMessage");

      pvalue->m.triggeringMessagePresent = 1;

      stat = asn1PD_TriggeringMessage (pctxt, &pvalue->triggeringMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode procedureCriticality */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "procedureCriticality");

      pvalue->m.procedureCriticalityPresent = 1;

      stat = asn1PD_Criticality (pctxt, &pvalue->procedureCriticality);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iEsCriticalityDiagnostics */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iEsCriticalityDiagnostics");

      pvalue->m.iEsCriticalityDiagnosticsPresent = 1;

      stat = asn1PD_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_CriticalityDiagnostics_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CriticalityDiagnostics: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DataForwardingResponseDRBItem_iE_Extensions_element (OSCTXT* pctxt, DataForwardingResponseDRBItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingResponseDRBItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingResponseDRBItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DataForwardingResponseDRBItem_iE_Extensions (OSCTXT* pctxt, DataForwardingResponseDRBItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingResponseDRBItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DataForwardingResponseDRBItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DataForwardingResponseDRBItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DataForwardingResponseDRBItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DataForwardingResponseDRBItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingResponseDRBItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_DataForwardingResponseDRBItem (OSCTXT* pctxt, DataForwardingResponseDRBItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DataForwardingResponseDRBItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingResponseDRBItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dRB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "dRB-ID");

   stat = asn1PD_DRB_ID (pctxt, &pvalue->dRB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dLForwardingUP_TNLInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dLForwardingUP-TNLInformation");

      pvalue->m.dLForwardingUP_TNLInformationPresent = 1;

      stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->dLForwardingUP_TNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uLForwardingUP_TNLInformation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uLForwardingUP-TNLInformation");

      pvalue->m.uLForwardingUP_TNLInformationPresent = 1;

      stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->uLForwardingUP_TNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_DataForwardingResponseDRBItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingResponseDRBItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DataForwardingResponseDRBList (OSCTXT* pctxt, DataForwardingResponseDRBList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DataForwardingResponseDRBList");

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingResponseDRBList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DataForwardingResponseDRBItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DataForwardingResponseDRBItem", xx1);

      rtxDListAllocNodeAndData (pctxt, DataForwardingResponseDRBItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DataForwardingResponseDRBItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DataForwardingResponseDRBItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DataForwardingResponseDRBList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRBStatusUL12_iE_Extension_element (OSCTXT* pctxt, DRBStatusUL12_iE_Extension_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL12_iE_Extension_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL12_iE_Extension_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusUL12_iE_Extension (OSCTXT* pctxt, DRBStatusUL12_iE_Extension* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL12_iE_Extension: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRBStatusUL12_iE_Extension_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DRBStatusUL12_iE_Extension_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DRBStatusUL12_iE_Extension_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DRBStatusUL12_iE_Extension_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL12_iE_Extension: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusUL12 (OSCTXT* pctxt, DRBStatusUL12* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DRBStatusUL12");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL12: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode uL_COUNTValue */
   RTXCTXTPUSHELEMNAME (pctxt, "uL-COUNTValue");

   stat = asn1PD_COUNTValueForPDCP_SN12 (pctxt, &pvalue->uL_COUNTValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode receiveStatusOfUL_PDCP_SDUs */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "receiveStatusOfUL-PDCP-SDUs");

      pvalue->m.receiveStatusOfUL_PDCP_SDUsPresent = 1;

      stat = asn1PD_DRBStatusUL12_receiveStatusOfUL_PDCP_SDUs (pctxt, &pvalue->receiveStatusOfUL_PDCP_SDUs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extension");

      pvalue->m.iE_ExtensionPresent = 1;

      stat = asn1PD_DRBStatusUL12_iE_Extension (pctxt, &pvalue->iE_Extension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL12: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRBStatusUL18_iE_Extension_element (OSCTXT* pctxt, DRBStatusUL18_iE_Extension_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL18_iE_Extension_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL18_iE_Extension_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusUL18_iE_Extension (OSCTXT* pctxt, DRBStatusUL18_iE_Extension* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL18_iE_Extension: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRBStatusUL18_iE_Extension_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DRBStatusUL18_iE_Extension_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DRBStatusUL18_iE_Extension_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DRBStatusUL18_iE_Extension_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL18_iE_Extension: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusUL18 (OSCTXT* pctxt, DRBStatusUL18* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "DRBStatusUL18");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL18: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode uL_COUNTValue */
   RTXCTXTPUSHELEMNAME (pctxt, "uL-COUNTValue");

   stat = asn1PD_COUNTValueForPDCP_SN18 (pctxt, &pvalue->uL_COUNTValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode receiveStatusOfUL_PDCP_SDUs */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "receiveStatusOfUL-PDCP-SDUs");

      pvalue->m.receiveStatusOfUL_PDCP_SDUsPresent = 1;

      PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(131072), 0, 0);

      stat = pd_DynBitString (pctxt, &pvalue->receiveStatusOfUL_PDCP_SDUs);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extension */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extension");

      pvalue->m.iE_ExtensionPresent = 1;

      stat = asn1PD_DRBStatusUL18_iE_Extension (pctxt, &pvalue->iE_Extension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL18: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRBStatusUL_choice_Extensions (OSCTXT* pctxt, DRBStatusUL_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusUL (OSCTXT* pctxt, DRBStatusUL* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DRBStatusUL");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* dRBStatusUL12 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dRBStatusUL12");

         pvalue->u.dRBStatusUL12 = rtxMemAllocType (pctxt, DRBStatusUL12);

         if (pvalue->u.dRBStatusUL12 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DRBStatusUL12 (pvalue->u.dRBStatusUL12);

         stat = asn1PD_DRBStatusUL12 (pctxt, pvalue->u.dRBStatusUL12);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dRBStatusUL18 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dRBStatusUL18");

         pvalue->u.dRBStatusUL18 = rtxMemAllocType (pctxt, DRBStatusUL18);

         if (pvalue->u.dRBStatusUL18 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DRBStatusUL18 (pvalue->u.dRBStatusUL18);

         stat = asn1PD_DRBStatusUL18 (pctxt, pvalue->u.dRBStatusUL18);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            DRBStatusUL_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DRBStatusUL_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_DRBStatusUL_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusUL: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRBStatusDL12_iE_Extension_element (OSCTXT* pctxt, DRBStatusDL12_iE_Extension_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL12_iE_Extension_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL12_iE_Extension_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusDL12_iE_Extension (OSCTXT* pctxt, DRBStatusDL12_iE_Extension* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL12_iE_Extension: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRBStatusDL12_iE_Extension_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DRBStatusDL12_iE_Extension_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DRBStatusDL12_iE_Extension_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DRBStatusDL12_iE_Extension_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL12_iE_Extension: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusDL12 (OSCTXT* pctxt, DRBStatusDL12* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DRBStatusDL12");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL12: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dL_COUNTValue */
   RTXCTXTPUSHELEMNAME (pctxt, "dL-COUNTValue");

   stat = asn1PD_COUNTValueForPDCP_SN12 (pctxt, &pvalue->dL_COUNTValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extension");

      pvalue->m.iE_ExtensionPresent = 1;

      stat = asn1PD_DRBStatusDL12_iE_Extension (pctxt, &pvalue->iE_Extension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL12: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRBStatusDL18_iE_Extension_element (OSCTXT* pctxt, DRBStatusDL18_iE_Extension_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL18_iE_Extension_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL18_iE_Extension_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusDL18_iE_Extension (OSCTXT* pctxt, DRBStatusDL18_iE_Extension* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL18_iE_Extension: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRBStatusDL18_iE_Extension_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DRBStatusDL18_iE_Extension_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DRBStatusDL18_iE_Extension_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DRBStatusDL18_iE_Extension_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL18_iE_Extension: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusDL18 (OSCTXT* pctxt, DRBStatusDL18* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DRBStatusDL18");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL18: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dL_COUNTValue */
   RTXCTXTPUSHELEMNAME (pctxt, "dL-COUNTValue");

   stat = asn1PD_COUNTValueForPDCP_SN18 (pctxt, &pvalue->dL_COUNTValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extension");

      pvalue->m.iE_ExtensionPresent = 1;

      stat = asn1PD_DRBStatusDL18_iE_Extension (pctxt, &pvalue->iE_Extension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL18: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRBStatusDL_choice_Extensions (OSCTXT* pctxt, DRBStatusDL_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBStatusDL (OSCTXT* pctxt, DRBStatusDL* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "DRBStatusDL");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* dRBStatusDL12 */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "dRBStatusDL12");

         pvalue->u.dRBStatusDL12 = rtxMemAllocType (pctxt, DRBStatusDL12);

         if (pvalue->u.dRBStatusDL12 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DRBStatusDL12 (pvalue->u.dRBStatusDL12);

         stat = asn1PD_DRBStatusDL12 (pctxt, pvalue->u.dRBStatusDL12);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dRBStatusDL18 */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dRBStatusDL18");

         pvalue->u.dRBStatusDL18 = rtxMemAllocType (pctxt, DRBStatusDL18);

         if (pvalue->u.dRBStatusDL18 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DRBStatusDL18 (pvalue->u.dRBStatusDL18);

         stat = asn1PD_DRBStatusDL18 (pctxt, pvalue->u.dRBStatusDL18);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            DRBStatusDL_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DRBStatusDL_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_DRBStatusDL_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBStatusDL: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRBsSubjectToStatusTransferItem_iE_Extension_element (OSCTXT* pctxt, DRBsSubjectToStatusTransferItem_iE_Extension_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsSubjectToStatusTransferItem_iE_Extension_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _DRBsSubjectToStatusTransferItem_ExtIEs_id_OldAssociatedQosFlowList_ULendmarkerexpected */
   case ASN1V_id_OldAssociatedQosFlowList_ULendmarkerexpected:
      pvalue->extensionValue.
         t = T_NGAP_IEs_DRBsSubjectToStatusTransferItem_ExtIEs_id_OldAssociatedQosFlowList_ULendmarkerexpected;

      RTXCTXTPUSHELEMNAME (pctxt, "_DRBsSubjectToStatusTransferItem_ExtIEs_id_OldAssociatedQosFlowList_ULendmarkerexpected");

      pvalue->extensionValue.
         u._DRBsSubjectToStatusTransferItem_ExtIEs_id_OldAssociatedQosFlowList_ULendmarkerexpected
          = rtxMemAllocType (pctxt, AssociatedQosFlowList);

      if (pvalue->extensionValue.
         u._DRBsSubjectToStatusTransferItem_ExtIEs_id_OldAssociatedQosFlowList_ULendmarkerexpected
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AssociatedQosFlowList (pvalue->extensionValue.
         u._DRBsSubjectToStatusTransferItem_ExtIEs_id_OldAssociatedQosFlowList_ULendmarkerexpected
         );

      stat = asn1PD_AssociatedQosFlowList (pctxt, pvalue->extensionValue.
         u._DRBsSubjectToStatusTransferItem_ExtIEs_id_OldAssociatedQosFlowList_ULendmarkerexpected
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_DRBsSubjectToStatusTransferItem_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsSubjectToStatusTransferItem_iE_Extension_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBsSubjectToStatusTransferItem_iE_Extension (OSCTXT* pctxt, DRBsSubjectToStatusTransferItem_iE_Extension* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsSubjectToStatusTransferItem_iE_Extension: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRBsSubjectToStatusTransferItem_iE_Extension_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DRBsSubjectToStatusTransferItem_iE_Extension_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DRBsSubjectToStatusTransferItem_iE_Extension_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DRBsSubjectToStatusTransferItem_iE_Extension_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsSubjectToStatusTransferItem_iE_Extension: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBsSubjectToStatusTransferItem (OSCTXT* pctxt, DRBsSubjectToStatusTransferItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DRBsSubjectToStatusTransferItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsSubjectToStatusTransferItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dRB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "dRB-ID");

   stat = asn1PD_DRB_ID (pctxt, &pvalue->dRB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dRBStatusUL */
   RTXCTXTPUSHELEMNAME (pctxt, "dRBStatusUL");

   stat = asn1PD_DRBStatusUL (pctxt, &pvalue->dRBStatusUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dRBStatusDL */
   RTXCTXTPUSHELEMNAME (pctxt, "dRBStatusDL");

   stat = asn1PD_DRBStatusDL (pctxt, &pvalue->dRBStatusDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extension */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extension");

      pvalue->m.iE_ExtensionPresent = 1;

      stat = asn1PD_DRBsSubjectToStatusTransferItem_iE_Extension (pctxt, &pvalue->iE_Extension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsSubjectToStatusTransferItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRBsSubjectToStatusTransferList (OSCTXT* pctxt, DRBsSubjectToStatusTransferList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRBsSubjectToStatusTransferList");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsSubjectToStatusTransferList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRBsSubjectToStatusTransferItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRBsSubjectToStatusTransferItem", xx1);

      rtxDListAllocNodeAndData (pctxt, DRBsSubjectToStatusTransferItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DRBsSubjectToStatusTransferItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DRBsSubjectToStatusTransferItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsSubjectToStatusTransferList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRBsToQosFlowsMappingItem_iE_Extensions_element (OSCTXT* pctxt, DRBsToQosFlowsMappingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsToQosFlowsMappingItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsToQosFlowsMappingItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBsToQosFlowsMappingItem_iE_Extensions (OSCTXT* pctxt, DRBsToQosFlowsMappingItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsToQosFlowsMappingItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRBsToQosFlowsMappingItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DRBsToQosFlowsMappingItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DRBsToQosFlowsMappingItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DRBsToQosFlowsMappingItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsToQosFlowsMappingItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_DRBsToQosFlowsMappingItem (OSCTXT* pctxt, DRBsToQosFlowsMappingItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DRBsToQosFlowsMappingItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsToQosFlowsMappingItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dRB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "dRB-ID");

   stat = asn1PD_DRB_ID (pctxt, &pvalue->dRB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode associatedQosFlowList */
   RTXCTXTPUSHELEMNAME (pctxt, "associatedQosFlowList");

   stat = asn1PD_AssociatedQosFlowList (pctxt, &pvalue->associatedQosFlowList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_DRBsToQosFlowsMappingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsToQosFlowsMappingItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DRBsToQosFlowsMappingList (OSCTXT* pctxt, DRBsToQosFlowsMappingList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRBsToQosFlowsMappingList");

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsToQosFlowsMappingList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DRBsToQosFlowsMappingItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DRBsToQosFlowsMappingItem", xx1);

      rtxDListAllocNodeAndData (pctxt, DRBsToQosFlowsMappingItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DRBsToQosFlowsMappingItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DRBsToQosFlowsMappingItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DRBsToQosFlowsMappingList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PacketErrorRate_iE_Extensions_element (OSCTXT* pctxt, PacketErrorRate_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PacketErrorRate_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PacketErrorRate_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PacketErrorRate_iE_Extensions (OSCTXT* pctxt, PacketErrorRate_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PacketErrorRate_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PacketErrorRate_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PacketErrorRate_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PacketErrorRate_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PacketErrorRate_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PacketErrorRate_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PacketErrorRate (OSCTXT* pctxt, PacketErrorRate* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PacketErrorRate");

   RTDIAGSTRM2 (pctxt,"asn1PD_PacketErrorRate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pERScalar */
   RTXCTXTPUSHELEMNAME (pctxt, "pERScalar");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, &pvalue->pERScalar, 0, 9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, &pvalue->pERScalar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pERExponent */
   RTXCTXTPUSHELEMNAME (pctxt, "pERExponent");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, &pvalue->pERExponent, 0, 9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, &pvalue->pERExponent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PacketErrorRate_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PacketErrorRate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_Dynamic5QIDescriptor_iE_Extensions_element (OSCTXT* pctxt, Dynamic5QIDescriptor_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Dynamic5QIDescriptor_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_Dynamic5QIDescriptor_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_Dynamic5QIDescriptor_iE_Extensions (OSCTXT* pctxt, Dynamic5QIDescriptor_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Dynamic5QIDescriptor_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      Dynamic5QIDescriptor_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, Dynamic5QIDescriptor_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Dynamic5QIDescriptor_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_Dynamic5QIDescriptor_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Dynamic5QIDescriptor_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_Dynamic5QIDescriptor (OSCTXT* pctxt, Dynamic5QIDescriptor* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "Dynamic5QIDescriptor");

   RTDIAGSTRM2 (pctxt,"asn1PD_Dynamic5QIDescriptor: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode priorityLevelQos */
   RTXCTXTPUSHELEMNAME (pctxt, "priorityLevelQos");

   stat = asn1PD_PriorityLevelQos (pctxt, &pvalue->priorityLevelQos);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode packetDelayBudget */
   RTXCTXTPUSHELEMNAME (pctxt, "packetDelayBudget");

   stat = asn1PD_PacketDelayBudget (pctxt, &pvalue->packetDelayBudget);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode packetErrorRate */
   RTXCTXTPUSHELEMNAME (pctxt, "packetErrorRate");

   stat = asn1PD_PacketErrorRate (pctxt, &pvalue->packetErrorRate);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode fiveQI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "fiveQI");

      pvalue->m.fiveQIPresent = 1;

      stat = asn1PD_FiveQI (pctxt, &pvalue->fiveQI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode delayCritical */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "delayCritical");

      pvalue->m.delayCriticalPresent = 1;

      stat = asn1PD_DelayCritical (pctxt, &pvalue->delayCritical);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode averagingWindow */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "averagingWindow");

      pvalue->m.averagingWindowPresent = 1;

      stat = asn1PD_AveragingWindow (pctxt, &pvalue->averagingWindow);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode maximumDataBurstVolume */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "maximumDataBurstVolume");

      pvalue->m.maximumDataBurstVolumePresent = 1;

      stat = asn1PD_MaximumDataBurstVolume (pctxt, &pvalue->maximumDataBurstVolume);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_Dynamic5QIDescriptor_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Dynamic5QIDescriptor: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDList (OSCTXT* pctxt, EmergencyAreaIDList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaIDList");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EmergencyAreaID* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "EmergencyAreaID", xx1);

      rtxDListAllocNodeAndData (pctxt, EmergencyAreaID, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EmergencyAreaID (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyAreaIDListForRestart (OSCTXT* pctxt, EmergencyAreaIDListForRestart* pvalue)
{
   int stat = 0;
   OSUINT16 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyAreaIDListForRestart");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDListForRestart: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   if (pctxt->buffer.aligned)  {
      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtxDecBitsToUInt16 (pctxt, &pvalue->n, 8);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 256){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "EmergencyAreaID", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (EmergencyAreaID));
      stat = asn1PD_EmergencyAreaID (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyAreaIDListForRestart: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EmergencyFallbackIndicator_iE_Extensions_element (OSCTXT* pctxt, EmergencyFallbackIndicator_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyFallbackIndicator_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyFallbackIndicator_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyFallbackIndicator_iE_Extensions (OSCTXT* pctxt, EmergencyFallbackIndicator_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyFallbackIndicator_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EmergencyFallbackIndicator_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, EmergencyFallbackIndicator_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyFallbackIndicator_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EmergencyFallbackIndicator_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyFallbackIndicator_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_EmergencyFallbackIndicator (OSCTXT* pctxt, EmergencyFallbackIndicator* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencyFallbackIndicator");

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyFallbackIndicator: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode emergencyFallbackRequestIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "emergencyFallbackRequestIndicator");

   stat = asn1PD_EmergencyFallbackRequestIndicator (pctxt, &pvalue->emergencyFallbackRequestIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode emergencyServiceTargetCN */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "emergencyServiceTargetCN");

      pvalue->m.emergencyServiceTargetCNPresent = 1;

      stat = asn1PD_EmergencyServiceTargetCN (pctxt, &pvalue->emergencyServiceTargetCN);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_EmergencyFallbackIndicator_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EmergencyFallbackIndicator: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EquivalentPLMNs (OSCTXT* pctxt, EquivalentPLMNs* pvalue)
{
   int stat = 0;
   OSUINT8 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EquivalentPLMNs");

   RTDIAGSTRM2 (pctxt,"asn1PD_EquivalentPLMNs: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToByte (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 15){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PLMNIdentity", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (PLMNIdentity));
      stat = asn1PD_PLMNIdentity (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EquivalentPLMNs: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EPS_TAI_iE_Extensions_element (OSCTXT* pctxt, EPS_TAI_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EPS_TAI_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_EPS_TAI_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_EPS_TAI_iE_Extensions (OSCTXT* pctxt, EPS_TAI_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_EPS_TAI_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EPS_TAI_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, EPS_TAI_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EPS_TAI_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EPS_TAI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EPS_TAI_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_EPS_TAI (OSCTXT* pctxt, EPS_TAI* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EPS-TAI");

   RTDIAGSTRM2 (pctxt,"asn1PD_EPS_TAI: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ePS_TAC */
   RTXCTXTPUSHELEMNAME (pctxt, "ePS-TAC");

   stat = asn1PD_EPS_TAC (pctxt, &pvalue->ePS_TAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_EPS_TAI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EPS_TAI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_E_RABInformationItem_iE_Extensions_element (OSCTXT* pctxt, E_RABInformationItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RABInformationItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RABInformationItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_E_RABInformationItem_iE_Extensions (OSCTXT* pctxt, E_RABInformationItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RABInformationItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      E_RABInformationItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, E_RABInformationItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_E_RABInformationItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_E_RABInformationItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RABInformationItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_E_RABInformationItem (OSCTXT* pctxt, E_RABInformationItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "E-RABInformationItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RABInformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode e_RAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "e-RAB-ID");

   stat = asn1PD_E_RAB_ID (pctxt, &pvalue->e_RAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dLForwarding */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dLForwarding");

      pvalue->m.dLForwardingPresent = 1;

      stat = asn1PD_DLForwarding (pctxt, &pvalue->dLForwarding);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_E_RABInformationItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RABInformationItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_E_RABInformationList (OSCTXT* pctxt, E_RABInformationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-RABInformationList");

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RABInformationList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      E_RABInformationItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "E-RABInformationItem", xx1);

      rtxDListAllocNodeAndData (pctxt, E_RABInformationItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_E_RABInformationItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_E_RABInformationItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_E_RABInformationList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_EUTRA_CGIListForWarning (OSCTXT* pctxt, EUTRA_CGIListForWarning* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EUTRA-CGIListForWarning");

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRA_CGIListForWarning: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      EUTRA_CGI* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "EUTRA-CGI", xx1);

      rtxDListAllocNodeAndData (pctxt, EUTRA_CGI, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EUTRA_CGI (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_EUTRA_CGI (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_EUTRA_CGIListForWarning: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_FiveG_S_TMSI_iE_Extensions_element (OSCTXT* pctxt, FiveG_S_TMSI_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FiveG_S_TMSI_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_FiveG_S_TMSI_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_FiveG_S_TMSI_iE_Extensions (OSCTXT* pctxt, FiveG_S_TMSI_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_FiveG_S_TMSI_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      FiveG_S_TMSI_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, FiveG_S_TMSI_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FiveG_S_TMSI_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_FiveG_S_TMSI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FiveG_S_TMSI_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_FiveG_S_TMSI (OSCTXT* pctxt, FiveG_S_TMSI* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "FiveG-S-TMSI");

   RTDIAGSTRM2 (pctxt,"asn1PD_FiveG_S_TMSI: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode aMFSetID */
   RTXCTXTPUSHELEMNAME (pctxt, "aMFSetID");

   stat = asn1PD_AMFSetID (pctxt, &pvalue->aMFSetID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode aMFPointer */
   RTXCTXTPUSHELEMNAME (pctxt, "aMFPointer");

   stat = asn1PD_AMFPointer (pctxt, &pvalue->aMFPointer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode fiveG_TMSI */
   RTXCTXTPUSHELEMNAME (pctxt, "fiveG-TMSI");

   stat = asn1PD_FiveG_TMSI (pctxt, &pvalue->fiveG_TMSI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_FiveG_S_TMSI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_FiveG_S_TMSI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ForbiddenTACs (OSCTXT* pctxt, ForbiddenTACs* pvalue)
{
   int stat = 0;
   OSUINT16 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ForbiddenTACs");

   RTDIAGSTRM2 (pctxt,"asn1PD_ForbiddenTACs: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   if (pctxt->buffer.aligned) {
      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtxDecBitsToUInt16 (pctxt, &pvalue->n, 16);
   }
   else {
      stat = rtxDecBitsToUInt16 (pctxt, &pvalue->n, 12);
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 4096){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAC", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (TAC));
      stat = asn1PD_TAC (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ForbiddenTACs: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ForbiddenAreaInformation_Item_iE_Extensions_element (OSCTXT* pctxt, ForbiddenAreaInformation_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ForbiddenAreaInformation_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ForbiddenAreaInformation_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_ForbiddenAreaInformation_Item_iE_Extensions (OSCTXT* pctxt, ForbiddenAreaInformation_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ForbiddenAreaInformation_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ForbiddenAreaInformation_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ForbiddenAreaInformation_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ForbiddenAreaInformation_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ForbiddenAreaInformation_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ForbiddenAreaInformation_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_ForbiddenAreaInformation_Item (OSCTXT* pctxt, ForbiddenAreaInformation_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ForbiddenAreaInformation-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_ForbiddenAreaInformation_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode forbiddenTACs */
   RTXCTXTPUSHELEMNAME (pctxt, "forbiddenTACs");

   stat = asn1PD_ForbiddenTACs (pctxt, &pvalue->forbiddenTACs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ForbiddenAreaInformation_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ForbiddenAreaInformation_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ForbiddenAreaInformation (OSCTXT* pctxt, ForbiddenAreaInformation* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ForbiddenAreaInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_ForbiddenAreaInformation: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ForbiddenAreaInformation_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ForbiddenAreaInformation-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, ForbiddenAreaInformation_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ForbiddenAreaInformation_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ForbiddenAreaInformation_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ForbiddenAreaInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_GBR_QosInformation_iE_Extensions_element (OSCTXT* pctxt, GBR_QosInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GBR_QosInformation_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_GBR_QosInformation_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_GBR_QosInformation_iE_Extensions (OSCTXT* pctxt, GBR_QosInformation_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GBR_QosInformation_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GBR_QosInformation_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, GBR_QosInformation_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GBR_QosInformation_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GBR_QosInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GBR_QosInformation_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_GBR_QosInformation (OSCTXT* pctxt, GBR_QosInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "GBR-QosInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_GBR_QosInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode maximumFlowBitRateDL */
   RTXCTXTPUSHELEMNAME (pctxt, "maximumFlowBitRateDL");

   stat = asn1PD_BitRate (pctxt, &pvalue->maximumFlowBitRateDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maximumFlowBitRateUL */
   RTXCTXTPUSHELEMNAME (pctxt, "maximumFlowBitRateUL");

   stat = asn1PD_BitRate (pctxt, &pvalue->maximumFlowBitRateUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode guaranteedFlowBitRateDL */
   RTXCTXTPUSHELEMNAME (pctxt, "guaranteedFlowBitRateDL");

   stat = asn1PD_BitRate (pctxt, &pvalue->guaranteedFlowBitRateDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode guaranteedFlowBitRateUL */
   RTXCTXTPUSHELEMNAME (pctxt, "guaranteedFlowBitRateUL");

   stat = asn1PD_BitRate (pctxt, &pvalue->guaranteedFlowBitRateUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode notificationControl */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "notificationControl");

      pvalue->m.notificationControlPresent = 1;

      stat = asn1PD_NotificationControl (pctxt, &pvalue->notificationControl);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode maximumPacketLossRateDL */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "maximumPacketLossRateDL");

      pvalue->m.maximumPacketLossRateDLPresent = 1;

      stat = asn1PD_PacketLossRate (pctxt, &pvalue->maximumPacketLossRateDL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode maximumPacketLossRateUL */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "maximumPacketLossRateUL");

      pvalue->m.maximumPacketLossRateULPresent = 1;

      stat = asn1PD_PacketLossRate (pctxt, &pvalue->maximumPacketLossRateUL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_GBR_QosInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GBR_QosInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_GUAMI_iE_Extensions_element (OSCTXT* pctxt, GUAMI_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GUAMI_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_GUAMI_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_GUAMI_iE_Extensions (OSCTXT* pctxt, GUAMI_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_GUAMI_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      GUAMI_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, GUAMI_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GUAMI_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_GUAMI_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GUAMI_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_GUAMI (OSCTXT* pctxt, GUAMI* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GUAMI");

   RTDIAGSTRM2 (pctxt,"asn1PD_GUAMI: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode aMFRegionID */
   RTXCTXTPUSHELEMNAME (pctxt, "aMFRegionID");

   stat = asn1PD_AMFRegionID (pctxt, &pvalue->aMFRegionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode aMFSetID */
   RTXCTXTPUSHELEMNAME (pctxt, "aMFSetID");

   stat = asn1PD_AMFSetID (pctxt, &pvalue->aMFSetID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode aMFPointer */
   RTXCTXTPUSHELEMNAME (pctxt, "aMFPointer");

   stat = asn1PD_AMFPointer (pctxt, &pvalue->aMFPointer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_GUAMI_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_GUAMI: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowToBeForwardedItem_iE_Extensions_element (OSCTXT* pctxt, QosFlowToBeForwardedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowToBeForwardedItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowToBeForwardedItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowToBeForwardedItem_iE_Extensions (OSCTXT* pctxt, QosFlowToBeForwardedItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowToBeForwardedItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowToBeForwardedItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowToBeForwardedItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowToBeForwardedItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowToBeForwardedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowToBeForwardedItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowToBeForwardedItem (OSCTXT* pctxt, QosFlowToBeForwardedItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowToBeForwardedItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowToBeForwardedItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowToBeForwardedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowToBeForwardedItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowToBeForwardedList (OSCTXT* pctxt, QosFlowToBeForwardedList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowToBeForwardedList");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowToBeForwardedList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowToBeForwardedItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowToBeForwardedItem", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowToBeForwardedItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowToBeForwardedItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowToBeForwardedItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowToBeForwardedList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowPerTNLInformation_iE_Extensions_element (OSCTXT* pctxt, QosFlowPerTNLInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformation_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformation_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowPerTNLInformation_iE_Extensions (OSCTXT* pctxt, QosFlowPerTNLInformation_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformation_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowPerTNLInformation_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowPerTNLInformation_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowPerTNLInformation_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowPerTNLInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformation_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowPerTNLInformation (OSCTXT* pctxt, QosFlowPerTNLInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowPerTNLInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode uPTransportLayerInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "uPTransportLayerInformation");

   stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->uPTransportLayerInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode associatedQosFlowList */
   RTXCTXTPUSHELEMNAME (pctxt, "associatedQosFlowList");

   stat = asn1PD_AssociatedQosFlowList (pctxt, &pvalue->associatedQosFlowList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowPerTNLInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowPerTNLInformationItem_iE_Extensions_element (OSCTXT* pctxt, QosFlowPerTNLInformationItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformationItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformationItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowPerTNLInformationItem_iE_Extensions (OSCTXT* pctxt, QosFlowPerTNLInformationItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformationItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowPerTNLInformationItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowPerTNLInformationItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowPerTNLInformationItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowPerTNLInformationItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformationItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowPerTNLInformationItem (OSCTXT* pctxt, QosFlowPerTNLInformationItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowPerTNLInformationItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowPerTNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowPerTNLInformation");

   stat = asn1PD_QosFlowPerTNLInformation (pctxt, &pvalue->qosFlowPerTNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowPerTNLInformationItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformationItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowPerTNLInformationList (OSCTXT* pctxt, QosFlowPerTNLInformationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowPerTNLInformationList");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformationList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(3), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowPerTNLInformationItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowPerTNLInformationItem", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowPerTNLInformationItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowPerTNLInformationItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowPerTNLInformationItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowPerTNLInformationList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UPTransportLayerInformationItem_iE_Extensions_element (OSCTXT* pctxt, UPTransportLayerInformationItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UPTransportLayerInformationItem_iE_Extensions (OSCTXT* pctxt, UPTransportLayerInformationItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UPTransportLayerInformationItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UPTransportLayerInformationItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformationItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UPTransportLayerInformationItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UPTransportLayerInformationItem (OSCTXT* pctxt, UPTransportLayerInformationItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UPTransportLayerInformationItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nGU_UP_TNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "nGU-UP-TNLInformation");

   stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->nGU_UP_TNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UPTransportLayerInformationItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UPTransportLayerInformationList (OSCTXT* pctxt, UPTransportLayerInformationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UPTransportLayerInformationList");

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(3), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UPTransportLayerInformationItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UPTransportLayerInformationItem", xx1);

      rtxDListAllocNodeAndData (pctxt, UPTransportLayerInformationItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformationItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UPTransportLayerInformationItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCommandTransfer_iE_Extensions_element (OSCTXT* pctxt, HandoverCommandTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommandTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverCommandTransfer_ExtIEs_id_AdditionalDLForwardingUPTNLInformation */
   case ASN1V_id_AdditionalDLForwardingUPTNLInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_HandoverCommandTransfer_ExtIEs_id_AdditionalDLForwardingUPTNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandTransfer_ExtIEs_id_AdditionalDLForwardingUPTNLInformation");

      pvalue->extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_AdditionalDLForwardingUPTNLInformation
          = rtxMemAllocType (pctxt, QosFlowPerTNLInformationList);

      if (pvalue->extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_AdditionalDLForwardingUPTNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowPerTNLInformationList (pvalue->extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_AdditionalDLForwardingUPTNLInformation
         );

      stat = asn1PD_QosFlowPerTNLInformationList (pctxt, pvalue->extensionValue
         .
         u._HandoverCommandTransfer_ExtIEs_id_AdditionalDLForwardingUPTNLInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCommandTransfer_ExtIEs_id_ULForwardingUP_TNLInformation */
   case ASN1V_id_ULForwardingUP_TNLInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_HandoverCommandTransfer_ExtIEs_id_ULForwardingUP_TNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandTransfer_ExtIEs_id_ULForwardingUP_TNLInformation");

      pvalue->extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_ULForwardingUP_TNLInformation
          = rtxMemAllocType (pctxt, UPTransportLayerInformation);

      if (pvalue->extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_ULForwardingUP_TNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformation ((UPTransportLayerInformation*)
         pvalue->extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_ULForwardingUP_TNLInformation);

      stat = asn1PD_UPTransportLayerInformation (pctxt, 
         (UPTransportLayerInformation*)pvalue->extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_ULForwardingUP_TNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCommandTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation */
   case ASN1V_id_AdditionalULForwardingUPTNLInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_HandoverCommandTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation");

      pvalue->extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation
          = rtxMemAllocType (pctxt, UPTransportLayerInformationList);

      if (pvalue->extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformationList (pvalue->extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation
         );

      stat = asn1PD_UPTransportLayerInformationList (pctxt, pvalue->
         extensionValue.
         u._HandoverCommandTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_HandoverCommandTransfer_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommandTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCommandTransfer_iE_Extensions (OSCTXT* pctxt, HandoverCommandTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommandTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverCommandTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverCommandTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverCommandTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverCommandTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommandTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCommandTransfer (OSCTXT* pctxt, HandoverCommandTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCommandTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommandTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dLForwardingUP_TNLInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dLForwardingUP-TNLInformation");

      pvalue->m.dLForwardingUP_TNLInformationPresent = 1;

      stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->dLForwardingUP_TNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode qosFlowToBeForwardedList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowToBeForwardedList");

      pvalue->m.qosFlowToBeForwardedListPresent = 1;

      stat = asn1PD_QosFlowToBeForwardedList (pctxt, &pvalue->qosFlowToBeForwardedList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dataForwardingResponseDRBList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataForwardingResponseDRBList");

      pvalue->m.dataForwardingResponseDRBListPresent = 1;

      stat = asn1PD_DataForwardingResponseDRBList (pctxt, &pvalue->dataForwardingResponseDRBList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_HandoverCommandTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommandTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationUnsuccessfulTransfer_iE_Extensions_element (OSCTXT* pctxt, HandoverPreparationUnsuccessfulTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationUnsuccessfulTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationUnsuccessfulTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationUnsuccessfulTransfer_iE_Extensions (OSCTXT* pctxt, HandoverPreparationUnsuccessfulTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationUnsuccessfulTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverPreparationUnsuccessfulTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverPreparationUnsuccessfulTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverPreparationUnsuccessfulTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverPreparationUnsuccessfulTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationUnsuccessfulTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationUnsuccessfulTransfer (OSCTXT* pctxt, HandoverPreparationUnsuccessfulTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverPreparationUnsuccessfulTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationUnsuccessfulTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_HandoverPreparationUnsuccessfulTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationUnsuccessfulTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityResult_iE_Extensions_element (OSCTXT* pctxt, SecurityResult_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityResult_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityResult_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SecurityResult_iE_Extensions (OSCTXT* pctxt, SecurityResult_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityResult_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SecurityResult_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SecurityResult_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecurityResult_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SecurityResult_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityResult_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SecurityResult (OSCTXT* pctxt, SecurityResult* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityResult");

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityResult: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode integrityProtectionResult */
   RTXCTXTPUSHELEMNAME (pctxt, "integrityProtectionResult");

   stat = asn1PD_IntegrityProtectionResult (pctxt, &pvalue->integrityProtectionResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode confidentialityProtectionResult */
   RTXCTXTPUSHELEMNAME (pctxt, "confidentialityProtectionResult");

   stat = asn1PD_ConfidentialityProtectionResult (pctxt, &pvalue->confidentialityProtectionResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SecurityResult_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityResult: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowWithCauseItem_iE_Extensions_element (OSCTXT* pctxt, QosFlowWithCauseItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowWithCauseItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowWithCauseItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowWithCauseItem_iE_Extensions (OSCTXT* pctxt, QosFlowWithCauseItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowWithCauseItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowWithCauseItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowWithCauseItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowWithCauseItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowWithCauseItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowWithCauseItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowWithCauseItem (OSCTXT* pctxt, QosFlowWithCauseItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowWithCauseItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowWithCauseItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowWithCauseItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowWithCauseItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowListWithCause (OSCTXT* pctxt, QosFlowListWithCause* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowListWithCause");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowListWithCause: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowWithCauseItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowWithCauseItem", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowWithCauseItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowWithCauseItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowWithCauseItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowListWithCause: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverRequestAcknowledgeTransfer_iE_Extensions_element (OSCTXT* pctxt, HandoverRequestAcknowledgeTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledgeTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalDLUPTNLInformationForHOList */
   case ASN1V_id_AdditionalDLUPTNLInformationForHOList:
      pvalue->extensionValue.
         t = T_NGAP_IEs_HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalDLUPTNLInformationForHOList;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalDLUPTNLInformationForHOList");

      pvalue->extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalDLUPTNLInformationForHOList
          = rtxMemAllocType (pctxt, AdditionalDLUPTNLInformationForHOList);

      if (pvalue->extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalDLUPTNLInformationForHOList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AdditionalDLUPTNLInformationForHOList (pvalue->extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalDLUPTNLInformationForHOList
         );

      stat = asn1PD_AdditionalDLUPTNLInformationForHOList (pctxt, pvalue->
         extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalDLUPTNLInformationForHOList
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestAcknowledgeTransfer_ExtIEs_id_ULForwardingUP_TNLInformation */
   case ASN1V_id_ULForwardingUP_TNLInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_HandoverRequestAcknowledgeTransfer_ExtIEs_id_ULForwardingUP_TNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeTransfer_ExtIEs_id_ULForwardingUP_TNLInformation");

      pvalue->extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_ULForwardingUP_TNLInformation
          = rtxMemAllocType (pctxt, UPTransportLayerInformation);

      if (pvalue->extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_ULForwardingUP_TNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformation ((UPTransportLayerInformation*)
         pvalue->extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_ULForwardingUP_TNLInformation
         );

      stat = asn1PD_UPTransportLayerInformation (pctxt, 
         (UPTransportLayerInformation*)pvalue->extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_ULForwardingUP_TNLInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation */
   case ASN1V_id_AdditionalULForwardingUPTNLInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation");

      pvalue->extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation
          = rtxMemAllocType (pctxt, UPTransportLayerInformationList);

      if (pvalue->extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformationList (pvalue->extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation
         );

      stat = asn1PD_UPTransportLayerInformationList (pctxt, pvalue->
         extensionValue.
         u._HandoverRequestAcknowledgeTransfer_ExtIEs_id_AdditionalULForwardingUPTNLInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_HandoverRequestAcknowledgeTransfer_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledgeTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequestAcknowledgeTransfer_iE_Extensions (OSCTXT* pctxt, HandoverRequestAcknowledgeTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledgeTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverRequestAcknowledgeTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverRequestAcknowledgeTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverRequestAcknowledgeTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverRequestAcknowledgeTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledgeTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequestAcknowledgeTransfer (OSCTXT* pctxt, HandoverRequestAcknowledgeTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequestAcknowledgeTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledgeTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dL_NGU_UP_TNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "dL-NGU-UP-TNLInformation");

   stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->dL_NGU_UP_TNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dLForwardingUP_TNLInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dLForwardingUP-TNLInformation");

      pvalue->m.dLForwardingUP_TNLInformationPresent = 1;

      stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->dLForwardingUP_TNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode securityResult */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "securityResult");

      pvalue->m.securityResultPresent = 1;

      stat = asn1PD_SecurityResult (pctxt, &pvalue->securityResult);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode qosFlowSetupResponseList */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowSetupResponseList");

   stat = asn1PD_QosFlowListWithDataForwarding (pctxt, &pvalue->qosFlowSetupResponseList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode qosFlowFailedToSetupList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowFailedToSetupList");

      pvalue->m.qosFlowFailedToSetupListPresent = 1;

      stat = asn1PD_QosFlowListWithCause (pctxt, &pvalue->qosFlowFailedToSetupList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dataForwardingResponseDRBList */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataForwardingResponseDRBList");

      pvalue->m.dataForwardingResponseDRBListPresent = 1;

      stat = asn1PD_DataForwardingResponseDRBList (pctxt, &pvalue->dataForwardingResponseDRBList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_HandoverRequestAcknowledgeTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledgeTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverRequiredTransfer_iE_Extensions_element (OSCTXT* pctxt, HandoverRequiredTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequiredTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequiredTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequiredTransfer_iE_Extensions (OSCTXT* pctxt, HandoverRequiredTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequiredTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverRequiredTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverRequiredTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverRequiredTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverRequiredTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequiredTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequiredTransfer (OSCTXT* pctxt, HandoverRequiredTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequiredTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequiredTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode directForwardingPathAvailability */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "directForwardingPathAvailability");

      pvalue->m.directForwardingPathAvailabilityPresent = 1;

      stat = asn1PD_DirectForwardingPathAvailability (pctxt, &pvalue->directForwardingPathAvailability);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_HandoverRequiredTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequiredTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions_element (OSCTXT* pctxt, HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions (OSCTXT* pctxt, HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverResourceAllocationUnsuccessfulTransfer (OSCTXT* pctxt, HandoverResourceAllocationUnsuccessfulTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverResourceAllocationUnsuccessfulTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverResourceAllocationUnsuccessfulTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalityDiagnostics */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "criticalityDiagnostics");

      pvalue->m.criticalityDiagnosticsPresent = 1;

      stat = asn1PD_CriticalityDiagnostics (pctxt, &pvalue->criticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_HandoverResourceAllocationUnsuccessfulTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverResourceAllocationUnsuccessfulTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RecommendedRANNodeItem_iE_Extensions_element (OSCTXT* pctxt, RecommendedRANNodeItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodeItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodeItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RecommendedRANNodeItem_iE_Extensions (OSCTXT* pctxt, RecommendedRANNodeItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodeItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RecommendedRANNodeItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RecommendedRANNodeItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RecommendedRANNodeItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RecommendedRANNodeItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodeItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_RecommendedRANNodeItem (OSCTXT* pctxt, RecommendedRANNodeItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RecommendedRANNodeItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodeItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode aMFPagingTarget */
   RTXCTXTPUSHELEMNAME (pctxt, "aMFPagingTarget");

   stat = asn1PD_AMFPagingTarget (pctxt, &pvalue->aMFPagingTarget);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_RecommendedRANNodeItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodeItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RecommendedRANNodeList (OSCTXT* pctxt, RecommendedRANNodeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RecommendedRANNodeList");

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodeList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RecommendedRANNodeItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RecommendedRANNodeItem", xx1);

      rtxDListAllocNodeAndData (pctxt, RecommendedRANNodeItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RecommendedRANNodeItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RecommendedRANNodeItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodeList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RecommendedRANNodesForPaging_iE_Extensions_element (OSCTXT* pctxt, RecommendedRANNodesForPaging_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodesForPaging_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodesForPaging_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RecommendedRANNodesForPaging_iE_Extensions (OSCTXT* pctxt, RecommendedRANNodesForPaging_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodesForPaging_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RecommendedRANNodesForPaging_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RecommendedRANNodesForPaging_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RecommendedRANNodesForPaging_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RecommendedRANNodesForPaging_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodesForPaging_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_RecommendedRANNodesForPaging (OSCTXT* pctxt, RecommendedRANNodesForPaging* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RecommendedRANNodesForPaging");

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodesForPaging: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode recommendedRANNodeList */
   RTXCTXTPUSHELEMNAME (pctxt, "recommendedRANNodeList");

   stat = asn1PD_RecommendedRANNodeList (pctxt, &pvalue->recommendedRANNodeList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_RecommendedRANNodesForPaging_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RecommendedRANNodesForPaging: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions_element (OSCTXT* pctxt, InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions (OSCTXT* pctxt, InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging (OSCTXT* pctxt, InfoOnRecommendedCellsAndRANNodesForPaging* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "InfoOnRecommendedCellsAndRANNodesForPaging");

   RTDIAGSTRM2 (pctxt,"asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode recommendedCellsForPaging */
   RTXCTXTPUSHELEMNAME (pctxt, "recommendedCellsForPaging");

   stat = asn1PD_RecommendedCellsForPaging (pctxt, &pvalue->recommendedCellsForPaging);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode recommendRANNodesForPaging */
   RTXCTXTPUSHELEMNAME (pctxt, "recommendRANNodesForPaging");

   stat = asn1PD_RecommendedRANNodesForPaging (pctxt, &pvalue->recommendRANNodesForPaging);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LastVisitedNGRANCellInformation_iE_Extensions_element (OSCTXT* pctxt, LastVisitedNGRANCellInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedNGRANCellInformation_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedNGRANCellInformation_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_LastVisitedNGRANCellInformation_iE_Extensions (OSCTXT* pctxt, LastVisitedNGRANCellInformation_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedNGRANCellInformation_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LastVisitedNGRANCellInformation_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, LastVisitedNGRANCellInformation_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LastVisitedNGRANCellInformation_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LastVisitedNGRANCellInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedNGRANCellInformation_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_LastVisitedNGRANCellInformation (OSCTXT* pctxt, LastVisitedNGRANCellInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "LastVisitedNGRANCellInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedNGRANCellInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode globalCellID */
   RTXCTXTPUSHELEMNAME (pctxt, "globalCellID");

   stat = asn1PD_NGRAN_CGI (pctxt, &pvalue->globalCellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellType */
   RTXCTXTPUSHELEMNAME (pctxt, "cellType");

   stat = asn1PD_CellType (pctxt, &pvalue->cellType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeUEStayedInCell */
   RTXCTXTPUSHELEMNAME (pctxt, "timeUEStayedInCell");

   stat = asn1PD_TimeUEStayedInCell (pctxt, &pvalue->timeUEStayedInCell);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeUEStayedInCellEnhancedGranularity */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timeUEStayedInCellEnhancedGranularity");

      pvalue->m.timeUEStayedInCellEnhancedGranularityPresent = 1;

      stat = asn1PD_TimeUEStayedInCellEnhancedGranularity (pctxt, &pvalue->timeUEStayedInCellEnhancedGranularity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode hOCauseValue */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "hOCauseValue");

      pvalue->m.hOCauseValuePresent = 1;

      stat = asn1PD_Cause (pctxt, &pvalue->hOCauseValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_LastVisitedNGRANCellInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedNGRANCellInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LastVisitedCellInformation_choice_Extensions (OSCTXT* pctxt, LastVisitedCellInformation_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedCellInformation_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedCellInformation_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_LastVisitedCellInformation (OSCTXT* pctxt, LastVisitedCellInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "LastVisitedCellInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedCellInformation: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* nGRANCell */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "nGRANCell");

         pvalue->u.nGRANCell = rtxMemAllocType (pctxt, 
            LastVisitedNGRANCellInformation);

         if (pvalue->u.nGRANCell == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LastVisitedNGRANCellInformation (pvalue->u.nGRANCell);

         stat = asn1PD_LastVisitedNGRANCellInformation (pctxt, pvalue->u.nGRANCell);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* eUTRANCell */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "eUTRANCell");

         pvalue->u.eUTRANCell = rtxMemAllocType (pctxt, 
            LastVisitedEUTRANCellInformation);

         if (pvalue->u.eUTRANCell == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LastVisitedEUTRANCellInformation (pvalue->u.eUTRANCell);

         stat = asn1PD_LastVisitedEUTRANCellInformation (pctxt, pvalue->u.eUTRANCell);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* uTRANCell */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "uTRANCell");

         pvalue->u.uTRANCell = rtxMemAllocType (pctxt, 
            LastVisitedUTRANCellInformation);

         if (pvalue->u.uTRANCell == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LastVisitedUTRANCellInformation (pvalue->u.uTRANCell);

         stat = asn1PD_LastVisitedUTRANCellInformation (pctxt, pvalue->u.uTRANCell);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* gERANCell */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "gERANCell");

         pvalue->u.gERANCell = rtxMemAllocType (pctxt, 
            LastVisitedGERANCellInformation);

         if (pvalue->u.gERANCell == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LastVisitedGERANCellInformation (pvalue->u.gERANCell);

         stat = asn1PD_LastVisitedGERANCellInformation (pctxt, pvalue->u.gERANCell);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            LastVisitedCellInformation_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LastVisitedCellInformation_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_LastVisitedCellInformation_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedCellInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LastVisitedCellItem_iE_Extensions_element (OSCTXT* pctxt, LastVisitedCellItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedCellItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedCellItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_LastVisitedCellItem_iE_Extensions (OSCTXT* pctxt, LastVisitedCellItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedCellItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LastVisitedCellItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, LastVisitedCellItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LastVisitedCellItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LastVisitedCellItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedCellItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_LastVisitedCellItem (OSCTXT* pctxt, LastVisitedCellItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LastVisitedCellItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedCellItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode lastVisitedCellInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "lastVisitedCellInformation");

   stat = asn1PD_LastVisitedCellInformation (pctxt, &pvalue->lastVisitedCellInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_LastVisitedCellItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LastVisitedCellItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LocationReportingRequestType_iE_Extensions_element (OSCTXT* pctxt, LocationReportingRequestType_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingRequestType_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _LocationReportingRequestType_ExtIEs_id_LocationReportingAdditionalInfo */
   case ASN1V_id_LocationReportingAdditionalInfo:
      pvalue->extensionValue.
         t = T_NGAP_IEs_LocationReportingRequestType_ExtIEs_id_LocationReportingAdditionalInfo;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingRequestType_ExtIEs_id_LocationReportingAdditionalInfo");

      stat = asn1PD_LocationReportingAdditionalInfo (pctxt, &pvalue->
         extensionValue.
         u._LocationReportingRequestType_ExtIEs_id_LocationReportingAdditionalInfo
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_LocationReportingRequestType_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingRequestType_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReportingRequestType_iE_Extensions (OSCTXT* pctxt, LocationReportingRequestType_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingRequestType_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LocationReportingRequestType_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, LocationReportingRequestType_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReportingRequestType_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LocationReportingRequestType_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingRequestType_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReportingRequestType (OSCTXT* pctxt, LocationReportingRequestType* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingRequestType");

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingRequestType: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode eventType */
   RTXCTXTPUSHELEMNAME (pctxt, "eventType");

   stat = asn1PD_EventType (pctxt, &pvalue->eventType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportArea */
   RTXCTXTPUSHELEMNAME (pctxt, "reportArea");

   stat = asn1PD_ReportArea (pctxt, &pvalue->reportArea);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode areaOfInterestList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "areaOfInterestList");

      pvalue->m.areaOfInterestListPresent = 1;

      stat = asn1PD_AreaOfInterestList (pctxt, &pvalue->areaOfInterestList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode locationReportingReferenceIDToBeCancelled */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "locationReportingReferenceIDToBeCancelled");

      pvalue->m.locationReportingReferenceIDToBeCancelledPresent = 1;

      stat = asn1PD_LocationReportingReferenceID (pctxt, &pvalue->locationReportingReferenceIDToBeCancelled);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_LocationReportingRequestType_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingRequestType: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RATRestrictions_Item_iE_Extensions_element (OSCTXT* pctxt, RATRestrictions_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RATRestrictions_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RATRestrictions_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RATRestrictions_Item_iE_Extensions (OSCTXT* pctxt, RATRestrictions_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RATRestrictions_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RATRestrictions_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RATRestrictions_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RATRestrictions_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RATRestrictions_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RATRestrictions_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_RATRestrictions_Item (OSCTXT* pctxt, RATRestrictions_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RATRestrictions-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_RATRestrictions_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rATRestrictionInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "rATRestrictionInformation");

   stat = asn1PD_RATRestrictionInformation (pctxt, &pvalue->rATRestrictionInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_RATRestrictions_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RATRestrictions_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RATRestrictions (OSCTXT* pctxt, RATRestrictions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RATRestrictions");

   RTDIAGSTRM2 (pctxt,"asn1PD_RATRestrictions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RATRestrictions_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RATRestrictions-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, RATRestrictions_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RATRestrictions_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RATRestrictions_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RATRestrictions: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NotAllowedTACs (OSCTXT* pctxt, NotAllowedTACs* pvalue)
{
   int stat = 0;
   OSUINT8 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NotAllowedTACs");

   RTDIAGSTRM2 (pctxt,"asn1PD_NotAllowedTACs: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToByte (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 16){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAC", xx1);

      OSCRTLMEMSET (&pvalue->elem[xx1], 0, sizeof (TAC));
      stat = asn1PD_TAC (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NotAllowedTACs: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ServiceAreaInformation_Item_iE_Extensions_element (OSCTXT* pctxt, ServiceAreaInformation_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ServiceAreaInformation_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ServiceAreaInformation_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_ServiceAreaInformation_Item_iE_Extensions (OSCTXT* pctxt, ServiceAreaInformation_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ServiceAreaInformation_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ServiceAreaInformation_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ServiceAreaInformation_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ServiceAreaInformation_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ServiceAreaInformation_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ServiceAreaInformation_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_ServiceAreaInformation_Item (OSCTXT* pctxt, ServiceAreaInformation_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "ServiceAreaInformation-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_ServiceAreaInformation_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode allowedTACs */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "allowedTACs");

      pvalue->m.allowedTACsPresent = 1;

      stat = asn1PD_AllowedTACs (pctxt, &pvalue->allowedTACs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode notAllowedTACs */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "notAllowedTACs");

      pvalue->m.notAllowedTACsPresent = 1;

      stat = asn1PD_NotAllowedTACs (pctxt, &pvalue->notAllowedTACs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ServiceAreaInformation_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ServiceAreaInformation_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ServiceAreaInformation (OSCTXT* pctxt, ServiceAreaInformation* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ServiceAreaInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_ServiceAreaInformation: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ServiceAreaInformation_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ServiceAreaInformation-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, ServiceAreaInformation_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ServiceAreaInformation_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ServiceAreaInformation_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ServiceAreaInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_MobilityRestrictionList_iE_Extensions_element (OSCTXT* pctxt, MobilityRestrictionList_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MobilityRestrictionList_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _MobilityRestrictionList_ExtIEs_id_LastEUTRAN_PLMNIdentity */
   case ASN1V_id_LastEUTRAN_PLMNIdentity:
      pvalue->extensionValue.
         t = T_NGAP_IEs_MobilityRestrictionList_ExtIEs_id_LastEUTRAN_PLMNIdentity;

      RTXCTXTPUSHELEMNAME (pctxt, "_MobilityRestrictionList_ExtIEs_id_LastEUTRAN_PLMNIdentity");

      pvalue->extensionValue.
         u._MobilityRestrictionList_ExtIEs_id_LastEUTRAN_PLMNIdentity
          = rtxMemAllocTypeZ (pctxt, PLMNIdentity);

      if (pvalue->extensionValue.
         u._MobilityRestrictionList_ExtIEs_id_LastEUTRAN_PLMNIdentity == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_PLMNIdentity (pctxt, (PLMNIdentity*)pvalue->extensionValue.
         u._MobilityRestrictionList_ExtIEs_id_LastEUTRAN_PLMNIdentity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForServing */
   case ASN1V_id_CNTypeRestrictionsForServing:
      pvalue->extensionValue.
         t = T_NGAP_IEs_MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForServing;

      RTXCTXTPUSHELEMNAME (pctxt, "_MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForServing");

      stat = asn1PD_CNTypeRestrictionsForServing (pctxt, &pvalue->
         extensionValue.
         u._MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForServing);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForEquivalent */
   case ASN1V_id_CNTypeRestrictionsForEquivalent:
      pvalue->extensionValue.
         t = T_NGAP_IEs_MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForEquivalent;

      RTXCTXTPUSHELEMNAME (pctxt, "_MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForEquivalent");

      pvalue->extensionValue.
         u._MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForEquivalent
          = rtxMemAllocType (pctxt, CNTypeRestrictionsForEquivalent);

      if (pvalue->extensionValue.
         u._MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForEquivalent
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CNTypeRestrictionsForEquivalent (pvalue->extensionValue.
         u._MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForEquivalent
         );

      stat = asn1PD_CNTypeRestrictionsForEquivalent (pctxt, pvalue->
         extensionValue.
         u._MobilityRestrictionList_ExtIEs_id_CNTypeRestrictionsForEquivalent
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_MobilityRestrictionList_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_MobilityRestrictionList_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_MobilityRestrictionList_iE_Extensions (OSCTXT* pctxt, MobilityRestrictionList_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_MobilityRestrictionList_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      MobilityRestrictionList_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, MobilityRestrictionList_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MobilityRestrictionList_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_MobilityRestrictionList_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MobilityRestrictionList_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_MobilityRestrictionList (OSCTXT* pctxt, MobilityRestrictionList* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "MobilityRestrictionList");

   RTDIAGSTRM2 (pctxt,"asn1PD_MobilityRestrictionList: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode servingPLMN */
   RTXCTXTPUSHELEMNAME (pctxt, "servingPLMN");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->servingPLMN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode equivalentPLMNs */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "equivalentPLMNs");

      pvalue->m.equivalentPLMNsPresent = 1;

      stat = asn1PD_EquivalentPLMNs (pctxt, &pvalue->equivalentPLMNs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rATRestrictions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rATRestrictions");

      pvalue->m.rATRestrictionsPresent = 1;

      stat = asn1PD_RATRestrictions (pctxt, &pvalue->rATRestrictions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode forbiddenAreaInformation */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "forbiddenAreaInformation");

      pvalue->m.forbiddenAreaInformationPresent = 1;

      stat = asn1PD_ForbiddenAreaInformation (pctxt, &pvalue->forbiddenAreaInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode serviceAreaInformation */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "serviceAreaInformation");

      pvalue->m.serviceAreaInformationPresent = 1;

      stat = asn1PD_ServiceAreaInformation (pctxt, &pvalue->serviceAreaInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_MobilityRestrictionList_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_MobilityRestrictionList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGRAN_TNLAssociationToRemoveItem_iE_Extensions_element (OSCTXT* pctxt, NGRAN_TNLAssociationToRemoveItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_TNLAssociationToRemoveItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_TNLAssociationToRemoveItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGRAN_TNLAssociationToRemoveItem_iE_Extensions (OSCTXT* pctxt, NGRAN_TNLAssociationToRemoveItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_TNLAssociationToRemoveItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGRAN_TNLAssociationToRemoveItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGRAN_TNLAssociationToRemoveItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGRAN_TNLAssociationToRemoveItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGRAN_TNLAssociationToRemoveItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_TNLAssociationToRemoveItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_NGRAN_TNLAssociationToRemoveItem (OSCTXT* pctxt, NGRAN_TNLAssociationToRemoveItem* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "NGRAN-TNLAssociationToRemoveItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_TNLAssociationToRemoveItem: start\n");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode tNLAssociationTransportLayerAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "tNLAssociationTransportLayerAddress");

   stat = asn1PD_CPTransportLayerInformation (pctxt, &pvalue->tNLAssociationTransportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tNLAssociationTransportLayerAddressAMF */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tNLAssociationTransportLayerAddressAMF");

      pvalue->m.tNLAssociationTransportLayerAddressAMFPresent = 1;

      stat = asn1PD_CPTransportLayerInformation (pctxt, &pvalue->tNLAssociationTransportLayerAddressAMF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_NGRAN_TNLAssociationToRemoveItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_TNLAssociationToRemoveItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGRAN_TNLAssociationToRemoveList (OSCTXT* pctxt, NGRAN_TNLAssociationToRemoveList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NGRAN-TNLAssociationToRemoveList");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_TNLAssociationToRemoveList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGRAN_TNLAssociationToRemoveItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NGRAN-TNLAssociationToRemoveItem", xx1);

      rtxDListAllocNodeAndData (pctxt, NGRAN_TNLAssociationToRemoveItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGRAN_TNLAssociationToRemoveItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGRAN_TNLAssociationToRemoveItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGRAN_TNLAssociationToRemoveList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NonDynamic5QIDescriptor_iE_Extensions_element (OSCTXT* pctxt, NonDynamic5QIDescriptor_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NonDynamic5QIDescriptor_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NonDynamic5QIDescriptor_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NonDynamic5QIDescriptor_iE_Extensions (OSCTXT* pctxt, NonDynamic5QIDescriptor_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NonDynamic5QIDescriptor_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NonDynamic5QIDescriptor_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NonDynamic5QIDescriptor_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NonDynamic5QIDescriptor_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NonDynamic5QIDescriptor_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NonDynamic5QIDescriptor_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_NonDynamic5QIDescriptor (OSCTXT* pctxt, NonDynamic5QIDescriptor* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "NonDynamic5QIDescriptor");

   RTDIAGSTRM2 (pctxt,"asn1PD_NonDynamic5QIDescriptor: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode fiveQI */
   RTXCTXTPUSHELEMNAME (pctxt, "fiveQI");

   stat = asn1PD_FiveQI (pctxt, &pvalue->fiveQI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode priorityLevelQos */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "priorityLevelQos");

      pvalue->m.priorityLevelQosPresent = 1;

      stat = asn1PD_PriorityLevelQos (pctxt, &pvalue->priorityLevelQos);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode averagingWindow */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "averagingWindow");

      pvalue->m.averagingWindowPresent = 1;

      stat = asn1PD_AveragingWindow (pctxt, &pvalue->averagingWindow);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode maximumDataBurstVolume */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "maximumDataBurstVolume");

      pvalue->m.maximumDataBurstVolumePresent = 1;

      stat = asn1PD_MaximumDataBurstVolume (pctxt, &pvalue->maximumDataBurstVolume);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_NonDynamic5QIDescriptor_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NonDynamic5QIDescriptor: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NR_CGIListForWarning (OSCTXT* pctxt, NR_CGIListForWarning* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NR-CGIListForWarning");

   RTDIAGSTRM2 (pctxt,"asn1PD_NR_CGIListForWarning: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NR_CGI* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "NR-CGI", xx1);

      rtxDListAllocNodeAndData (pctxt, NR_CGI, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NR_CGI (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NR_CGI (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NR_CGIListForWarning: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_OverloadResponse_choice_Extensions (OSCTXT* pctxt, OverloadResponse_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadResponse_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadResponse_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadResponse (OSCTXT* pctxt, OverloadResponse* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "OverloadResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadResponse: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* overloadAction */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "overloadAction");

         stat = asn1PD_OverloadAction (pctxt, &pvalue->u.overloadAction);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            OverloadResponse_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_OverloadResponse_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_OverloadResponse_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SliceOverloadItem_iE_Extensions_element (OSCTXT* pctxt, SliceOverloadItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceOverloadItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceOverloadItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SliceOverloadItem_iE_Extensions (OSCTXT* pctxt, SliceOverloadItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceOverloadItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SliceOverloadItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SliceOverloadItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SliceOverloadItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SliceOverloadItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceOverloadItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SliceOverloadItem (OSCTXT* pctxt, SliceOverloadItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SliceOverloadItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceOverloadItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode s_NSSAI */
   RTXCTXTPUSHELEMNAME (pctxt, "s-NSSAI");

   stat = asn1PD_S_NSSAI (pctxt, &pvalue->s_NSSAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SliceOverloadItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceOverloadItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SliceOverloadList (OSCTXT* pctxt, SliceOverloadList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SliceOverloadList");

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceOverloadList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SliceOverloadItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SliceOverloadItem", xx1);

      rtxDListAllocNodeAndData (pctxt, SliceOverloadItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SliceOverloadItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SliceOverloadItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SliceOverloadList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_OverloadStartNSSAIItem_iE_Extensions_element (OSCTXT* pctxt, OverloadStartNSSAIItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStartNSSAIItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStartNSSAIItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadStartNSSAIItem_iE_Extensions (OSCTXT* pctxt, OverloadStartNSSAIItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStartNSSAIItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      OverloadStartNSSAIItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, OverloadStartNSSAIItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_OverloadStartNSSAIItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_OverloadStartNSSAIItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStartNSSAIItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadStartNSSAIItem (OSCTXT* pctxt, OverloadStartNSSAIItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "OverloadStartNSSAIItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStartNSSAIItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode sliceOverloadList */
   RTXCTXTPUSHELEMNAME (pctxt, "sliceOverloadList");

   stat = asn1PD_SliceOverloadList (pctxt, &pvalue->sliceOverloadList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sliceOverloadResponse */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sliceOverloadResponse");

      pvalue->m.sliceOverloadResponsePresent = 1;

      stat = asn1PD_OverloadResponse (pctxt, &pvalue->sliceOverloadResponse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sliceTrafficLoadReductionIndication */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sliceTrafficLoadReductionIndication");

      pvalue->m.sliceTrafficLoadReductionIndicationPresent = 1;

      stat = asn1PD_TrafficLoadReductionIndication (pctxt, &pvalue->sliceTrafficLoadReductionIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_OverloadStartNSSAIItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStartNSSAIItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_OverloadStartNSSAIList (OSCTXT* pctxt, OverloadStartNSSAIList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OverloadStartNSSAIList");

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStartNSSAIList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1024), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      OverloadStartNSSAIItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OverloadStartNSSAIItem", xx1);

      rtxDListAllocNodeAndData (pctxt, OverloadStartNSSAIItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_OverloadStartNSSAIItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_OverloadStartNSSAIItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStartNSSAIList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityIndication_iE_Extensions_element (OSCTXT* pctxt, SecurityIndication_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityIndication_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _SecurityIndication_ExtIEs_id_MaximumIntegrityProtectedDataRate_DL */
   case ASN1V_id_MaximumIntegrityProtectedDataRate_DL:
      pvalue->extensionValue.
         t = T_NGAP_IEs_SecurityIndication_ExtIEs_id_MaximumIntegrityProtectedDataRate_DL;

      RTXCTXTPUSHELEMNAME (pctxt, "_SecurityIndication_ExtIEs_id_MaximumIntegrityProtectedDataRate_DL");

      stat = asn1PD_MaximumIntegrityProtectedDataRate (pctxt, &pvalue->
         extensionValue.
         u._SecurityIndication_ExtIEs_id_MaximumIntegrityProtectedDataRate_DL
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_SecurityIndication_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityIndication_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SecurityIndication_iE_Extensions (OSCTXT* pctxt, SecurityIndication_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityIndication_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SecurityIndication_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SecurityIndication_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecurityIndication_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SecurityIndication_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityIndication_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SecurityIndication (OSCTXT* pctxt, SecurityIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode integrityProtectionIndication */
   RTXCTXTPUSHELEMNAME (pctxt, "integrityProtectionIndication");

   stat = asn1PD_IntegrityProtectionIndication (pctxt, &pvalue->integrityProtectionIndication);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode confidentialityProtectionIndication */
   RTXCTXTPUSHELEMNAME (pctxt, "confidentialityProtectionIndication");

   stat = asn1PD_ConfidentialityProtectionIndication (pctxt, &pvalue->confidentialityProtectionIndication);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maximumIntegrityProtectedDataRate_UL */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "maximumIntegrityProtectedDataRate-UL");

      pvalue->m.maximumIntegrityProtectedDataRate_ULPresent = 1;

      stat = asn1PD_MaximumIntegrityProtectedDataRate (pctxt, &pvalue->maximumIntegrityProtectedDataRate_UL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SecurityIndication_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UPTransportLayerInformationPairItem_iE_Extensions_element (OSCTXT* pctxt, UPTransportLayerInformationPairItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationPairItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationPairItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UPTransportLayerInformationPairItem_iE_Extensions (OSCTXT* pctxt, UPTransportLayerInformationPairItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationPairItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UPTransportLayerInformationPairItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UPTransportLayerInformationPairItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformationPairItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UPTransportLayerInformationPairItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationPairItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UPTransportLayerInformationPairItem (OSCTXT* pctxt, UPTransportLayerInformationPairItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UPTransportLayerInformationPairItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationPairItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode uL_NGU_UP_TNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "uL-NGU-UP-TNLInformation");

   stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->uL_NGU_UP_TNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dL_NGU_UP_TNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "dL-NGU-UP-TNLInformation");

   stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->dL_NGU_UP_TNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UPTransportLayerInformationPairItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationPairItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UPTransportLayerInformationPairList (OSCTXT* pctxt, UPTransportLayerInformationPairList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UPTransportLayerInformationPairList");

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationPairList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(3), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UPTransportLayerInformationPairItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UPTransportLayerInformationPairItem", xx1);

      rtxDListAllocNodeAndData (pctxt, UPTransportLayerInformationPairItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformationPairItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UPTransportLayerInformationPairItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UPTransportLayerInformationPairList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestAcknowledgeTransfer_iE_Extensions_element (OSCTXT* pctxt, PathSwitchRequestAcknowledgeTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledgeTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PathSwitchRequestAcknowledgeTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation */
   case ASN1V_id_AdditionalNGU_UP_TNLInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_PathSwitchRequestAcknowledgeTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation");

      pvalue->extensionValue.
         u._PathSwitchRequestAcknowledgeTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation
          = rtxMemAllocType (pctxt, UPTransportLayerInformationPairList);

      if (pvalue->extensionValue.
         u._PathSwitchRequestAcknowledgeTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformationPairList (pvalue->extensionValue.
         u._PathSwitchRequestAcknowledgeTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation
         );

      stat = asn1PD_UPTransportLayerInformationPairList (pctxt, pvalue->
         extensionValue.
         u._PathSwitchRequestAcknowledgeTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_PathSwitchRequestAcknowledgeTransfer_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledgeTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestAcknowledgeTransfer_iE_Extensions (OSCTXT* pctxt, PathSwitchRequestAcknowledgeTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledgeTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathSwitchRequestAcknowledgeTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PathSwitchRequestAcknowledgeTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PathSwitchRequestAcknowledgeTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathSwitchRequestAcknowledgeTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledgeTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestAcknowledgeTransfer (OSCTXT* pctxt, PathSwitchRequestAcknowledgeTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequestAcknowledgeTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledgeTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode uL_NGU_UP_TNLInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uL-NGU-UP-TNLInformation");

      pvalue->m.uL_NGU_UP_TNLInformationPresent = 1;

      stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->uL_NGU_UP_TNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode securityIndication */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "securityIndication");

      pvalue->m.securityIndicationPresent = 1;

      stat = asn1PD_SecurityIndication (pctxt, &pvalue->securityIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PathSwitchRequestAcknowledgeTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledgeTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestSetupFailedTransfer_iE_Extensions_element (OSCTXT* pctxt, PathSwitchRequestSetupFailedTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestSetupFailedTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestSetupFailedTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestSetupFailedTransfer_iE_Extensions (OSCTXT* pctxt, PathSwitchRequestSetupFailedTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestSetupFailedTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathSwitchRequestSetupFailedTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PathSwitchRequestSetupFailedTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PathSwitchRequestSetupFailedTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathSwitchRequestSetupFailedTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestSetupFailedTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestSetupFailedTransfer (OSCTXT* pctxt, PathSwitchRequestSetupFailedTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequestSetupFailedTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestSetupFailedTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PathSwitchRequestSetupFailedTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestSetupFailedTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UserPlaneSecurityInformation_iE_Extensions_element (OSCTXT* pctxt, UserPlaneSecurityInformation_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UserPlaneSecurityInformation_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UserPlaneSecurityInformation_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UserPlaneSecurityInformation_iE_Extensions (OSCTXT* pctxt, UserPlaneSecurityInformation_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UserPlaneSecurityInformation_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UserPlaneSecurityInformation_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UserPlaneSecurityInformation_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserPlaneSecurityInformation_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UserPlaneSecurityInformation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UserPlaneSecurityInformation_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UserPlaneSecurityInformation (OSCTXT* pctxt, UserPlaneSecurityInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UserPlaneSecurityInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_UserPlaneSecurityInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode securityResult */
   RTXCTXTPUSHELEMNAME (pctxt, "securityResult");

   stat = asn1PD_SecurityResult (pctxt, &pvalue->securityResult);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode securityIndication */
   RTXCTXTPUSHELEMNAME (pctxt, "securityIndication");

   stat = asn1PD_SecurityIndication (pctxt, &pvalue->securityIndication);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UserPlaneSecurityInformation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UserPlaneSecurityInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowAcceptedItem_iE_Extensions_element (OSCTXT* pctxt, QosFlowAcceptedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAcceptedItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAcceptedItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowAcceptedItem_iE_Extensions (OSCTXT* pctxt, QosFlowAcceptedItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAcceptedItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowAcceptedItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowAcceptedItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowAcceptedItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowAcceptedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAcceptedItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowAcceptedItem (OSCTXT* pctxt, QosFlowAcceptedItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowAcceptedItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAcceptedItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowAcceptedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAcceptedItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowAcceptedList (OSCTXT* pctxt, QosFlowAcceptedList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowAcceptedList");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAcceptedList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowAcceptedItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowAcceptedItem", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowAcceptedItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowAcceptedItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowAcceptedItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAcceptedList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestTransfer_iE_Extensions_element (OSCTXT* pctxt, PathSwitchRequestTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PathSwitchRequestTransfer_ExtIEs_id_AdditionalDLQosFlowPerTNLInformation */
   case ASN1V_id_AdditionalDLQosFlowPerTNLInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_PathSwitchRequestTransfer_ExtIEs_id_AdditionalDLQosFlowPerTNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestTransfer_ExtIEs_id_AdditionalDLQosFlowPerTNLInformation");

      pvalue->extensionValue.
         u._PathSwitchRequestTransfer_ExtIEs_id_AdditionalDLQosFlowPerTNLInformation
          = rtxMemAllocType (pctxt, QosFlowPerTNLInformationList);

      if (pvalue->extensionValue.
         u._PathSwitchRequestTransfer_ExtIEs_id_AdditionalDLQosFlowPerTNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowPerTNLInformationList (pvalue->extensionValue.
         u._PathSwitchRequestTransfer_ExtIEs_id_AdditionalDLQosFlowPerTNLInformation
         );

      stat = asn1PD_QosFlowPerTNLInformationList (pctxt, pvalue->extensionValue
         .
         u._PathSwitchRequestTransfer_ExtIEs_id_AdditionalDLQosFlowPerTNLInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_PathSwitchRequestTransfer_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestTransfer_iE_Extensions (OSCTXT* pctxt, PathSwitchRequestTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathSwitchRequestTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PathSwitchRequestTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PathSwitchRequestTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathSwitchRequestTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestTransfer (OSCTXT* pctxt, PathSwitchRequestTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequestTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dL_NGU_UP_TNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "dL-NGU-UP-TNLInformation");

   stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->dL_NGU_UP_TNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dL_NGU_TNLInformationReused */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dL-NGU-TNLInformationReused");

      pvalue->m.dL_NGU_TNLInformationReusedPresent = 1;

      stat = asn1PD_DL_NGU_TNLInformationReused (pctxt, &pvalue->dL_NGU_TNLInformationReused);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode userPlaneSecurityInformation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "userPlaneSecurityInformation");

      pvalue->m.userPlaneSecurityInformationPresent = 1;

      stat = asn1PD_UserPlaneSecurityInformation (pctxt, &pvalue->userPlaneSecurityInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode qosFlowAcceptedList */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowAcceptedList");

   stat = asn1PD_QosFlowAcceptedList (pctxt, &pvalue->qosFlowAcceptedList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PathSwitchRequestTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestUnsuccessfulTransfer_iE_Extensions_element (OSCTXT* pctxt, PathSwitchRequestUnsuccessfulTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestUnsuccessfulTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestUnsuccessfulTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestUnsuccessfulTransfer_iE_Extensions (OSCTXT* pctxt, PathSwitchRequestUnsuccessfulTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestUnsuccessfulTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathSwitchRequestUnsuccessfulTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PathSwitchRequestUnsuccessfulTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PathSwitchRequestUnsuccessfulTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathSwitchRequestUnsuccessfulTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestUnsuccessfulTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestUnsuccessfulTransfer (OSCTXT* pctxt, PathSwitchRequestUnsuccessfulTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequestUnsuccessfulTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestUnsuccessfulTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PathSwitchRequestUnsuccessfulTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestUnsuccessfulTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionAggregateMaximumBitRate_iE_Extensions_element (OSCTXT* pctxt, PDUSessionAggregateMaximumBitRate_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionAggregateMaximumBitRate_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionAggregateMaximumBitRate_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionAggregateMaximumBitRate_iE_Extensions (OSCTXT* pctxt, PDUSessionAggregateMaximumBitRate_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionAggregateMaximumBitRate_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionAggregateMaximumBitRate_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionAggregateMaximumBitRate_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionAggregateMaximumBitRate_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionAggregateMaximumBitRate_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionAggregateMaximumBitRate_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionAggregateMaximumBitRate (OSCTXT* pctxt, PDUSessionAggregateMaximumBitRate* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionAggregateMaximumBitRate");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionAggregateMaximumBitRate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionAggregateMaximumBitRateDL */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionAggregateMaximumBitRateDL");

   stat = asn1PD_BitRate (pctxt, &pvalue->pDUSessionAggregateMaximumBitRateDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionAggregateMaximumBitRateUL */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionAggregateMaximumBitRateUL");

   stat = asn1PD_BitRate (pctxt, &pvalue->pDUSessionAggregateMaximumBitRateUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionAggregateMaximumBitRate_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionAggregateMaximumBitRate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceAdmittedItem_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceAdmittedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceAdmittedItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceAdmittedItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceAdmittedItem_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceAdmittedItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceAdmittedItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceAdmittedItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceAdmittedItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceAdmittedItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceAdmittedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceAdmittedItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceAdmittedItem (OSCTXT* pctxt, PDUSessionResourceAdmittedItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceAdmittedItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceAdmittedItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode handoverRequestAcknowledgeTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "handoverRequestAcknowledgeTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->handoverRequestAcknowledgeTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceAdmittedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceAdmittedItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceAdmittedList (OSCTXT* pctxt, PDUSessionResourceAdmittedList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceAdmittedList");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceAdmittedList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceAdmittedItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceAdmittedItem", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceAdmittedItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceAdmittedItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceAdmittedItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceAdmittedList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToModifyItemModCfm (OSCTXT* pctxt, PDUSessionResourceFailedToModifyItemModCfm* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToModifyItemModCfm");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModCfm: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceModifyIndicationUnsuccessfulTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceModifyIndicationUnsuccessfulTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceModifyIndicationUnsuccessfulTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceFailedToModifyItemModCfm_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModCfm: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToModifyListModCfm (OSCTXT* pctxt, PDUSessionResourceFailedToModifyListModCfm* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToModifyListModCfm");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyListModCfm: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToModifyItemModCfm* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceFailedToModifyItemModCfm", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToModifyItemModCfm, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToModifyItemModCfm (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToModifyItemModCfm (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyListModCfm: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToModifyItemModRes_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceFailedToModifyItemModRes_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModRes_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModRes_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToModifyItemModRes_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceFailedToModifyItemModRes_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModRes_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToModifyItemModRes_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToModifyItemModRes_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToModifyItemModRes_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToModifyItemModRes_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModRes_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToModifyItemModRes (OSCTXT* pctxt, PDUSessionResourceFailedToModifyItemModRes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToModifyItemModRes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModRes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceModifyUnsuccessfulTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceModifyUnsuccessfulTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceModifyUnsuccessfulTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceFailedToModifyItemModRes_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyItemModRes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToModifyListModRes (OSCTXT* pctxt, PDUSessionResourceFailedToModifyListModRes* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToModifyListModRes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyListModRes: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToModifyItemModRes* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceFailedToModifyItemModRes", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToModifyItemModRes, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToModifyItemModRes (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToModifyItemModRes (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToModifyListModRes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer (OSCTXT* pctxt, PDUSessionResourceSetupUnsuccessfulTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupUnsuccessfulTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalityDiagnostics */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "criticalityDiagnostics");

      pvalue->m.criticalityDiagnosticsPresent = 1;

      stat = asn1PD_CriticalityDiagnostics (pctxt, &pvalue->criticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemCxtFail (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemCxtFail* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToSetupItemCxtFail");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtFail: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceSetupUnsuccessfulTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceSetupUnsuccessfulTransfer");
   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceSetupUnsuccessfulTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

/*    {
      OSCTXT lctxt;
      ASN1DynOctStr loctstr;
      OSRTDiagBitFieldList* pFieldList;
      OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

      stat = pd_DynOctetString (pctxt, &loctstr);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxCopyContext (&lctxt, pctxt);

      pFieldList = pctxt->pBitFldList;
      if (0 != pFieldList) {
         pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
      }
      stat = pd_setp (pctxt, (OSOCTET*)loctstr.data,
         loctstr.numocts, pctxt->buffer.aligned);

      if (0 == stat) {
         stat = asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer (pctxt, &pvalue->pDUSessionResourceSetupUnsuccessfulTransfer);

      }
      rtxCopyContext (pctxt, &lctxt);
      rtxMemFreePtr (pctxt, loctstr.data);

      if (0 != pctxt->pBitFldList) {
         PU_SETOPENTYPEFLDLIST (pFieldList, pctxt->pBitFldList);
         pctxt->pBitFldList = pFieldList;
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
*/
   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceFailedToSetupItemCxtFail_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtFail: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupListCxtFail (OSCTXT* pctxt, PDUSessionResourceFailedToSetupListCxtFail* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToSetupListCxtFail");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupListCxtFail: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToSetupItemCxtFail* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceFailedToSetupItemCxtFail", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToSetupItemCxtFail, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupItemCxtFail (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToSetupItemCxtFail (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupListCxtFail: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemCxtRes (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemCxtRes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToSetupItemCxtRes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtRes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceSetupUnsuccessfulTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceSetupUnsuccessfulTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceSetupUnsuccessfulTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
/*
    {
      OSCTXT lctxt;
      ASN1DynOctStr loctstr;
      OSRTDiagBitFieldList* pFieldList;
      OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

      stat = pd_DynOctetString (pctxt, &loctstr);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxCopyContext (&lctxt, pctxt);

      pFieldList = pctxt->pBitFldList;
      if (0 != pFieldList) {
         pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
      }
      stat = pd_setp (pctxt, (OSOCTET*)loctstr.data,
         loctstr.numocts, pctxt->buffer.aligned);

      if (0 == stat) {
         stat = asn1PD_PDUSessionResourceSetupUnsuccessfulTransfer (pctxt, &pvalue->pDUSessionResourceSetupUnsuccessfulTransfer);

      }
      rtxCopyContext (pctxt, &lctxt);
      rtxMemFreePtr (pctxt, loctstr.data);

      if (0 != pctxt->pBitFldList) {
         PU_SETOPENTYPEFLDLIST (pFieldList, pctxt->pBitFldList);
         pctxt->pBitFldList = pFieldList;
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
*/
   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceFailedToSetupItemCxtRes_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemCxtRes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupListCxtRes (OSCTXT* pctxt, PDUSessionResourceFailedToSetupListCxtRes* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToSetupListCxtRes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupListCxtRes: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToSetupItemCxtRes* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceFailedToSetupItemCxtRes", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToSetupItemCxtRes, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupItemCxtRes (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToSetupItemCxtRes (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupListCxtRes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemHOAck (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemHOAck* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToSetupItemHOAck");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemHOAck: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode handoverResourceAllocationUnsuccessfulTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "handoverResourceAllocationUnsuccessfulTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->handoverResourceAllocationUnsuccessfulTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceFailedToSetupItemHOAck_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemHOAck: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupListHOAck (OSCTXT* pctxt, PDUSessionResourceFailedToSetupListHOAck* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToSetupListHOAck");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupListHOAck: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToSetupItemHOAck* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceFailedToSetupItemHOAck", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToSetupItemHOAck, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupItemHOAck (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToSetupItemHOAck (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupListHOAck: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemPSReq (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemPSReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToSetupItemPSReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemPSReq: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pathSwitchRequestSetupFailedTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pathSwitchRequestSetupFailedTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pathSwitchRequestSetupFailedTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceFailedToSetupItemPSReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemPSReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupListPSReq (OSCTXT* pctxt, PDUSessionResourceFailedToSetupListPSReq* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToSetupListPSReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupListPSReq: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToSetupItemPSReq* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceFailedToSetupItemPSReq", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToSetupItemPSReq, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupItemPSReq (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToSetupItemPSReq (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupListPSReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemSURes_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemSURes_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemSURes_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemSURes_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemSURes_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemSURes_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemSURes_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToSetupItemSURes_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToSetupItemSURes_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupItemSURes_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToSetupItemSURes_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemSURes_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupItemSURes (OSCTXT* pctxt, PDUSessionResourceFailedToSetupItemSURes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToSetupItemSURes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemSURes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceSetupUnsuccessfulTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceSetupUnsuccessfulTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceSetupUnsuccessfulTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceFailedToSetupItemSURes_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupItemSURes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceFailedToSetupListSURes (OSCTXT* pctxt, PDUSessionResourceFailedToSetupListSURes* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceFailedToSetupListSURes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupListSURes: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceFailedToSetupItemSURes* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceFailedToSetupItemSURes", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceFailedToSetupItemSURes, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupItemSURes (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceFailedToSetupItemSURes (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceFailedToSetupListSURes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceHandoverItem_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceHandoverItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceHandoverItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceHandoverItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceHandoverItem_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceHandoverItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceHandoverItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceHandoverItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceHandoverItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceHandoverItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceHandoverItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceHandoverItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceHandoverItem (OSCTXT* pctxt, PDUSessionResourceHandoverItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceHandoverItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceHandoverItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode handoverCommandTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "handoverCommandTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->handoverCommandTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceHandoverItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceHandoverItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceHandoverList (OSCTXT* pctxt, PDUSessionResourceHandoverList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceHandoverList");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceHandoverList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceHandoverItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceHandoverItem", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceHandoverItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceHandoverItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceHandoverItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceHandoverList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowInformationItem_iE_Extensions_element (OSCTXT* pctxt, QosFlowInformationItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowInformationItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _QosFlowInformationItem_ExtIEs_id_ULForwarding */
   case ASN1V_id_ULForwarding:
      pvalue->extensionValue.
         t = T_NGAP_IEs_QosFlowInformationItem_ExtIEs_id_ULForwarding;

      RTXCTXTPUSHELEMNAME (pctxt, "_QosFlowInformationItem_ExtIEs_id_ULForwarding");

      stat = asn1PD_ULForwarding (pctxt, &pvalue->extensionValue.
         u._QosFlowInformationItem_ExtIEs_id_ULForwarding);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_QosFlowInformationItem_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowInformationItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowInformationItem_iE_Extensions (OSCTXT* pctxt, QosFlowInformationItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowInformationItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowInformationItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowInformationItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowInformationItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowInformationItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowInformationItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowInformationItem (OSCTXT* pctxt, QosFlowInformationItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowInformationItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowInformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dLForwarding */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dLForwarding");

      pvalue->m.dLForwardingPresent = 1;

      stat = asn1PD_DLForwarding (pctxt, &pvalue->dLForwarding);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowInformationItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowInformationItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowInformationList (OSCTXT* pctxt, QosFlowInformationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowInformationList");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowInformationList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowInformationItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowInformationItem", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowInformationItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowInformationItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowInformationItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowInformationList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceInformationItem_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceInformationItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceInformationItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceInformationItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceInformationItem_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceInformationItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceInformationItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceInformationItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceInformationItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceInformationItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceInformationItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceInformationItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceInformationItem (OSCTXT* pctxt, PDUSessionResourceInformationItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceInformationItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceInformationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode qosFlowInformationList */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowInformationList");

   stat = asn1PD_QosFlowInformationList (pctxt, &pvalue->qosFlowInformationList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dRBsToQosFlowsMappingList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dRBsToQosFlowsMappingList");

      pvalue->m.dRBsToQosFlowsMappingListPresent = 1;

      stat = asn1PD_DRBsToQosFlowsMappingList (pctxt, &pvalue->dRBsToQosFlowsMappingList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceInformationItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceInformationItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceInformationList (OSCTXT* pctxt, PDUSessionResourceInformationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceInformationList");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceInformationList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceInformationItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceInformationItem", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceInformationItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceInformationItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceInformationItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceInformationList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceItemCxtRelCpl_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceItemCxtRelCpl_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelCpl_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceItemCxtRelCpl_ExtIEs_id_PDUSessionResourceReleaseResponseTransfer */
   case ASN1V_id_PDUSessionResourceReleaseResponseTransfer:
      pvalue->extensionValue.
         t = T_NGAP_IEs_PDUSessionResourceItemCxtRelCpl_ExtIEs_id_PDUSessionResourceReleaseResponseTransfer;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceItemCxtRelCpl_ExtIEs_id_PDUSessionResourceReleaseResponseTransfer");

      pvalue->extensionValue.
         u._PDUSessionResourceItemCxtRelCpl_ExtIEs_id_PDUSessionResourceReleaseResponseTransfer
          = rtxMemAllocType (pctxt, 
         _PDUSessionResourceItemCxtRelCpl_ExtIEs_Extension);

      if (pvalue->extensionValue.
         u._PDUSessionResourceItemCxtRelCpl_ExtIEs_id_PDUSessionResourceReleaseResponseTransfer
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init__PDUSessionResourceItemCxtRelCpl_ExtIEs_Extension (pvalue->
         extensionValue.
         u._PDUSessionResourceItemCxtRelCpl_ExtIEs_id_PDUSessionResourceReleaseResponseTransfer
         );

      stat = asn1PD__PDUSessionResourceItemCxtRelCpl_ExtIEs_Extension (pctxt, 
         pvalue->extensionValue.
         u._PDUSessionResourceItemCxtRelCpl_ExtIEs_id_PDUSessionResourceReleaseResponseTransfer
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_PDUSessionResourceItemCxtRelCpl_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelCpl_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceItemCxtRelCpl_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceItemCxtRelCpl_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelCpl_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceItemCxtRelCpl_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceItemCxtRelCpl_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceItemCxtRelCpl_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceItemCxtRelCpl_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelCpl_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceItemCxtRelCpl (OSCTXT* pctxt, PDUSessionResourceItemCxtRelCpl* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceItemCxtRelCpl");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelCpl: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceItemCxtRelCpl_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelCpl: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceListCxtRelCpl (OSCTXT* pctxt, PDUSessionResourceListCxtRelCpl* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceListCxtRelCpl");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceListCxtRelCpl: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceItemCxtRelCpl* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceItemCxtRelCpl", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceItemCxtRelCpl, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceItemCxtRelCpl (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceItemCxtRelCpl (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceListCxtRelCpl: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceItemCxtRelReq_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceItemCxtRelReq_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelReq_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelReq_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceItemCxtRelReq_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceItemCxtRelReq_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelReq_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceItemCxtRelReq_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceItemCxtRelReq_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceItemCxtRelReq_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceItemCxtRelReq_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelReq_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceItemCxtRelReq (OSCTXT* pctxt, PDUSessionResourceItemCxtRelReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceItemCxtRelReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelReq: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceItemCxtRelReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemCxtRelReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceListCxtRelReq (OSCTXT* pctxt, PDUSessionResourceListCxtRelReq* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceListCxtRelReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceListCxtRelReq: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceItemCxtRelReq* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceItemCxtRelReq", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceItemCxtRelReq, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceItemCxtRelReq (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceItemCxtRelReq (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceListCxtRelReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceItemHORqd_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceItemHORqd_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemHORqd_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemHORqd_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceItemHORqd_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceItemHORqd_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemHORqd_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceItemHORqd_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceItemHORqd_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceItemHORqd_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceItemHORqd_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemHORqd_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceItemHORqd (OSCTXT* pctxt, PDUSessionResourceItemHORqd* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceItemHORqd");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemHORqd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode handoverRequiredTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "handoverRequiredTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->handoverRequiredTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceItemHORqd_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceItemHORqd: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceListHORqd (OSCTXT* pctxt, PDUSessionResourceListHORqd* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceListHORqd");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceListHORqd: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceItemHORqd* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceItemHORqd", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceItemHORqd, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceItemHORqd (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceItemHORqd (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceListHORqd: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowModifyConfirmItem_iE_Extensions_element (OSCTXT* pctxt, QosFlowModifyConfirmItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowModifyConfirmItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowModifyConfirmItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowModifyConfirmItem_iE_Extensions (OSCTXT* pctxt, QosFlowModifyConfirmItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowModifyConfirmItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowModifyConfirmItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowModifyConfirmItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowModifyConfirmItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowModifyConfirmItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowModifyConfirmItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowModifyConfirmItem (OSCTXT* pctxt, QosFlowModifyConfirmItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowModifyConfirmItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowModifyConfirmItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowModifyConfirmItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowModifyConfirmItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowModifyConfirmList (OSCTXT* pctxt, QosFlowModifyConfirmList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowModifyConfirmList");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowModifyConfirmList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowModifyConfirmItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowModifyConfirmItem", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowModifyConfirmItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowModifyConfirmItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowModifyConfirmItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowModifyConfirmList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyConfirmTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceModifyConfirmTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirmTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirmTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyConfirmTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceModifyConfirmTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirmTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyConfirmTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyConfirmTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyConfirmTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyConfirmTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirmTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyConfirmTransfer (OSCTXT* pctxt, PDUSessionResourceModifyConfirmTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyConfirmTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirmTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowModifyConfirmList */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowModifyConfirmList");

   stat = asn1PD_QosFlowModifyConfirmList (pctxt, &pvalue->qosFlowModifyConfirmList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uLNGU_UP_TNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "uLNGU-UP-TNLInformation");

   stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->uLNGU_UP_TNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode additionalNG_UUPTNLInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalNG-UUPTNLInformation");

      pvalue->m.additionalNG_UUPTNLInformationPresent = 1;

      stat = asn1PD_UPTransportLayerInformationPairList (pctxt, &pvalue->additionalNG_UUPTNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode qosFlowFailedToModifyList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowFailedToModifyList");

      pvalue->m.qosFlowFailedToModifyListPresent = 1;

      stat = asn1PD_QosFlowListWithCause (pctxt, &pvalue->qosFlowFailedToModifyList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceModifyConfirmTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirmTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer (OSCTXT* pctxt, PDUSessionResourceModifyIndicationUnsuccessfulTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyIndicationUnsuccessfulTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationUnsuccessfulTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_NGU_UP_TNLModifyItem_iE_Extensions_element (OSCTXT* pctxt, UL_NGU_UP_TNLModifyItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_NGU_UP_TNLModifyItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_NGU_UP_TNLModifyItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UL_NGU_UP_TNLModifyItem_iE_Extensions (OSCTXT* pctxt, UL_NGU_UP_TNLModifyItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_NGU_UP_TNLModifyItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UL_NGU_UP_TNLModifyItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UL_NGU_UP_TNLModifyItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UL_NGU_UP_TNLModifyItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UL_NGU_UP_TNLModifyItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_NGU_UP_TNLModifyItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UL_NGU_UP_TNLModifyItem (OSCTXT* pctxt, UL_NGU_UP_TNLModifyItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UL-NGU-UP-TNLModifyItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_NGU_UP_TNLModifyItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode uL_NGU_UP_TNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "uL-NGU-UP-TNLInformation");

   stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->uL_NGU_UP_TNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dL_NGU_UP_TNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "dL-NGU-UP-TNLInformation");

   stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->dL_NGU_UP_TNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UL_NGU_UP_TNLModifyItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_NGU_UP_TNLModifyItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UL_NGU_UP_TNLModifyList (OSCTXT* pctxt, UL_NGU_UP_TNLModifyList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-NGU-UP-TNLModifyList");

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_NGU_UP_TNLModifyList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(4), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UL_NGU_UP_TNLModifyItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UL-NGU-UP-TNLModifyItem", xx1);

      rtxDListAllocNodeAndData (pctxt, UL_NGU_UP_TNLModifyItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UL_NGU_UP_TNLModifyItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UL_NGU_UP_TNLModifyItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UL_NGU_UP_TNLModifyList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosCharacteristics_choice_Extensions (OSCTXT* pctxt, QosCharacteristics_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosCharacteristics_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosCharacteristics_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosCharacteristics (OSCTXT* pctxt, QosCharacteristics* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "QosCharacteristics");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosCharacteristics: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* nonDynamic5QI */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "nonDynamic5QI");

         pvalue->u.nonDynamic5QI = rtxMemAllocType (pctxt, 
            NonDynamic5QIDescriptor);

         if (pvalue->u.nonDynamic5QI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NonDynamic5QIDescriptor (pvalue->u.nonDynamic5QI);

         stat = asn1PD_NonDynamic5QIDescriptor (pctxt, pvalue->u.nonDynamic5QI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* dynamic5QI */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "dynamic5QI");

         pvalue->u.dynamic5QI = rtxMemAllocType (pctxt, Dynamic5QIDescriptor);

         if (pvalue->u.dynamic5QI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Dynamic5QIDescriptor (pvalue->u.dynamic5QI);

         stat = asn1PD_Dynamic5QIDescriptor (pctxt, pvalue->u.dynamic5QI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            QosCharacteristics_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_QosCharacteristics_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_QosCharacteristics_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosCharacteristics: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowLevelQosParameters_iE_Extensions_element (OSCTXT* pctxt, QosFlowLevelQosParameters_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowLevelQosParameters_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowLevelQosParameters_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowLevelQosParameters_iE_Extensions (OSCTXT* pctxt, QosFlowLevelQosParameters_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowLevelQosParameters_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowLevelQosParameters_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowLevelQosParameters_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowLevelQosParameters_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowLevelQosParameters_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowLevelQosParameters_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowLevelQosParameters (OSCTXT* pctxt, QosFlowLevelQosParameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowLevelQosParameters");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowLevelQosParameters: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosCharacteristics */
   RTXCTXTPUSHELEMNAME (pctxt, "qosCharacteristics");

   stat = asn1PD_QosCharacteristics (pctxt, &pvalue->qosCharacteristics);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode allocationAndRetentionPriority */
   RTXCTXTPUSHELEMNAME (pctxt, "allocationAndRetentionPriority");

   stat = asn1PD_AllocationAndRetentionPriority (pctxt, &pvalue->allocationAndRetentionPriority);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode gBR_QosInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "gBR-QosInformation");

      pvalue->m.gBR_QosInformationPresent = 1;

      stat = asn1PD_GBR_QosInformation (pctxt, &pvalue->gBR_QosInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode reflectiveQosAttribute */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reflectiveQosAttribute");

      pvalue->m.reflectiveQosAttributePresent = 1;

      stat = asn1PD_ReflectiveQosAttribute (pctxt, &pvalue->reflectiveQosAttribute);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode additionalQosFlowInformation */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalQosFlowInformation");

      pvalue->m.additionalQosFlowInformationPresent = 1;

      stat = asn1PD_AdditionalQosFlowInformation (pctxt, &pvalue->additionalQosFlowInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowLevelQosParameters_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowLevelQosParameters: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowAddOrModifyRequestItem_iE_Extensions_element (OSCTXT* pctxt, QosFlowAddOrModifyRequestItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyRequestItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyRequestItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowAddOrModifyRequestItem_iE_Extensions (OSCTXT* pctxt, QosFlowAddOrModifyRequestItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyRequestItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowAddOrModifyRequestItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowAddOrModifyRequestItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowAddOrModifyRequestItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowAddOrModifyRequestItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyRequestItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowAddOrModifyRequestItem (OSCTXT* pctxt, QosFlowAddOrModifyRequestItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowAddOrModifyRequestItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyRequestItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode qosFlowLevelQosParameters */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowLevelQosParameters");

      pvalue->m.qosFlowLevelQosParametersPresent = 1;

      stat = asn1PD_QosFlowLevelQosParameters (pctxt, &pvalue->qosFlowLevelQosParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RAB_ID */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RAB-ID");

      pvalue->m.e_RAB_IDPresent = 1;

      stat = asn1PD_E_RAB_ID (pctxt, &pvalue->e_RAB_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowAddOrModifyRequestItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyRequestItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowAddOrModifyRequestList (OSCTXT* pctxt, QosFlowAddOrModifyRequestList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowAddOrModifyRequestList");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyRequestList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowAddOrModifyRequestItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowAddOrModifyRequestItem", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowAddOrModifyRequestItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowAddOrModifyRequestItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowAddOrModifyRequestItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyRequestList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyRequestTransfer_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyRequestTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequestTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceModifyRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate */
   case ASN1V_id_PDUSessionAggregateMaximumBitRate:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceModifyRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate");

      pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate
          = rtxMemAllocType (pctxt, PDUSessionAggregateMaximumBitRate);

      if (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionAggregateMaximumBitRate (
         (PDUSessionAggregateMaximumBitRate*)pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate
         );

      stat = asn1PD_PDUSessionAggregateMaximumBitRate (pctxt, 
         (PDUSessionAggregateMaximumBitRate*)pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyRequestTransferIEs_id_UL_NGU_UP_TNLModifyList */
   case ASN1V_id_UL_NGU_UP_TNLModifyList:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceModifyRequestTransferIEs_id_UL_NGU_UP_TNLModifyList;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestTransferIEs_id_UL_NGU_UP_TNLModifyList");

      pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_UL_NGU_UP_TNLModifyList
          = rtxMemAllocType (pctxt, UL_NGU_UP_TNLModifyList);

      if (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_UL_NGU_UP_TNLModifyList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UL_NGU_UP_TNLModifyList (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_UL_NGU_UP_TNLModifyList
         );

      stat = asn1PD_UL_NGU_UP_TNLModifyList (pctxt, pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_UL_NGU_UP_TNLModifyList
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyRequestTransferIEs_id_NetworkInstance */
   case ASN1V_id_NetworkInstance:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceModifyRequestTransferIEs_id_NetworkInstance;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestTransferIEs_id_NetworkInstance");

      stat = asn1PD_NetworkInstance (pctxt, &pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_NetworkInstance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyRequestTransferIEs_id_QosFlowAddOrModifyRequestList */
   case ASN1V_id_QosFlowAddOrModifyRequestList:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceModifyRequestTransferIEs_id_QosFlowAddOrModifyRequestList;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestTransferIEs_id_QosFlowAddOrModifyRequestList");

      pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_QosFlowAddOrModifyRequestList
          = rtxMemAllocType (pctxt, QosFlowAddOrModifyRequestList);

      if (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_QosFlowAddOrModifyRequestList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowAddOrModifyRequestList (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_QosFlowAddOrModifyRequestList
         );

      stat = asn1PD_QosFlowAddOrModifyRequestList (pctxt, pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_QosFlowAddOrModifyRequestList
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyRequestTransferIEs_id_QosFlowToReleaseList */
   case ASN1V_id_QosFlowToReleaseList:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceModifyRequestTransferIEs_id_QosFlowToReleaseList;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestTransferIEs_id_QosFlowToReleaseList");

      pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_QosFlowToReleaseList
          = rtxMemAllocType (pctxt, QosFlowListWithCause);

      if (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_QosFlowToReleaseList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowListWithCause (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_QosFlowToReleaseList
         );

      stat = asn1PD_QosFlowListWithCause (pctxt, pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_QosFlowToReleaseList
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation */
   case ASN1V_id_AdditionalUL_NGU_UP_TNLInformation:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceModifyRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation");

      pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation
          = rtxMemAllocType (pctxt, UPTransportLayerInformationList);

      if (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformationList (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation
         );

      stat = asn1PD_UPTransportLayerInformationList (pctxt, pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyRequestTransferIEs_id_CommonNetworkInstance */
   case ASN1V_id_CommonNetworkInstance:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceModifyRequestTransferIEs_id_CommonNetworkInstance;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestTransferIEs_id_CommonNetworkInstance");

      pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_CommonNetworkInstance
          = rtxMemAllocType (pctxt, CommonNetworkInstance);

      if (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_CommonNetworkInstance
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CommonNetworkInstance (pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_CommonNetworkInstance
         );

      stat = asn1PD_CommonNetworkInstance (pctxt, pvalue->value.
         u._PDUSessionResourceModifyRequestTransferIEs_id_CommonNetworkInstance
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_IEs_PDUSessionResourceModifyRequestTransferIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequestTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyRequestTransfer_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyRequestTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequestTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyRequestTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyRequestTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyRequestTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyRequestTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequestTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyRequestTransfer (OSCTXT* pctxt, PDUSessionResourceModifyRequestTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyRequestTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequestTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceModifyRequestTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequestTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowAddOrModifyResponseItem_iE_Extensions_element (OSCTXT* pctxt, QosFlowAddOrModifyResponseItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyResponseItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyResponseItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowAddOrModifyResponseItem_iE_Extensions (OSCTXT* pctxt, QosFlowAddOrModifyResponseItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyResponseItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowAddOrModifyResponseItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowAddOrModifyResponseItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowAddOrModifyResponseItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowAddOrModifyResponseItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyResponseItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowAddOrModifyResponseItem (OSCTXT* pctxt, QosFlowAddOrModifyResponseItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowAddOrModifyResponseItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyResponseItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowAddOrModifyResponseItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyResponseItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowAddOrModifyResponseList (OSCTXT* pctxt, QosFlowAddOrModifyResponseList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowAddOrModifyResponseList");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyResponseList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowAddOrModifyResponseItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowAddOrModifyResponseItem", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowAddOrModifyResponseItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowAddOrModifyResponseItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowAddOrModifyResponseItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowAddOrModifyResponseList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyResponseTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceModifyResponseTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponseTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceModifyResponseTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation */
   case ASN1V_id_AdditionalNGU_UP_TNLInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_PDUSessionResourceModifyResponseTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation");

      pvalue->extensionValue.
         u._PDUSessionResourceModifyResponseTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation
          = rtxMemAllocType (pctxt, UPTransportLayerInformationPairList);

      if (pvalue->extensionValue.
         u._PDUSessionResourceModifyResponseTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformationPairList (pvalue->extensionValue.
         u._PDUSessionResourceModifyResponseTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation
         );

      stat = asn1PD_UPTransportLayerInformationPairList (pctxt, pvalue->
         extensionValue.
         u._PDUSessionResourceModifyResponseTransfer_ExtIEs_id_AdditionalNGU_UP_TNLInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_PDUSessionResourceModifyResponseTransfer_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponseTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyResponseTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceModifyResponseTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponseTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyResponseTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyResponseTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyResponseTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyResponseTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponseTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyResponseTransfer (OSCTXT* pctxt, PDUSessionResourceModifyResponseTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyResponseTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponseTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dL_NGU_UP_TNLInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dL-NGU-UP-TNLInformation");

      pvalue->m.dL_NGU_UP_TNLInformationPresent = 1;

      stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->dL_NGU_UP_TNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uL_NGU_UP_TNLInformation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uL-NGU-UP-TNLInformation");

      pvalue->m.uL_NGU_UP_TNLInformationPresent = 1;

      stat = asn1PD_UPTransportLayerInformation (pctxt, &pvalue->uL_NGU_UP_TNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode qosFlowAddOrModifyResponseList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowAddOrModifyResponseList");

      pvalue->m.qosFlowAddOrModifyResponseListPresent = 1;

      stat = asn1PD_QosFlowAddOrModifyResponseList (pctxt, &pvalue->qosFlowAddOrModifyResponseList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode additionalDLQosFlowPerTNLInformation */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalDLQosFlowPerTNLInformation");

      pvalue->m.additionalDLQosFlowPerTNLInformationPresent = 1;

      stat = asn1PD_QosFlowPerTNLInformationList (pctxt, &pvalue->additionalDLQosFlowPerTNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode qosFlowFailedToAddOrModifyList */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowFailedToAddOrModifyList");

      pvalue->m.qosFlowFailedToAddOrModifyListPresent = 1;

      stat = asn1PD_QosFlowListWithCause (pctxt, &pvalue->qosFlowFailedToAddOrModifyList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceModifyResponseTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponseTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_VolumeTimedReport_Item_iE_Extensions_element (OSCTXT* pctxt, VolumeTimedReport_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VolumeTimedReport_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_VolumeTimedReport_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_VolumeTimedReport_Item_iE_Extensions (OSCTXT* pctxt, VolumeTimedReport_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_VolumeTimedReport_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      VolumeTimedReport_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, VolumeTimedReport_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_VolumeTimedReport_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_VolumeTimedReport_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VolumeTimedReport_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_VolumeTimedReport_Item (OSCTXT* pctxt, VolumeTimedReport_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "VolumeTimedReport-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_VolumeTimedReport_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode startTimeStamp */
   RTXCTXTPUSHELEMNAME (pctxt, "startTimeStamp");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->startTimeStamp, 4, 32);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode endTimeStamp */
   RTXCTXTPUSHELEMNAME (pctxt, "endTimeStamp");

   PU_NEWFIELD (pctxt, "OctetString");

   stat = PD_BYTE_ALIGN (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxDecBitsToByteArray (pctxt, pvalue->endTimeStamp, 4, 32);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode usageCountUL */
   RTXCTXTPUSHELEMNAME (pctxt, "usageCountUL");

   stat = pd_ConsUInt64 (pctxt, &pvalue->usageCountUL, 0, OSUINT64MAX);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode usageCountDL */
   RTXCTXTPUSHELEMNAME (pctxt, "usageCountDL");

   stat = pd_ConsUInt64 (pctxt, &pvalue->usageCountDL, 0, OSUINT64MAX);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_VolumeTimedReport_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VolumeTimedReport_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_VolumeTimedReportList (OSCTXT* pctxt, VolumeTimedReportList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VolumeTimedReportList");

   RTDIAGSTRM2 (pctxt,"asn1PD_VolumeTimedReportList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      VolumeTimedReport_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "VolumeTimedReport-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, VolumeTimedReport_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_VolumeTimedReport_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_VolumeTimedReport_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_VolumeTimedReportList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionUsageReport_iE_Extensions_element (OSCTXT* pctxt, PDUSessionUsageReport_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionUsageReport_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionUsageReport_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionUsageReport_iE_Extensions (OSCTXT* pctxt, PDUSessionUsageReport_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionUsageReport_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionUsageReport_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionUsageReport_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionUsageReport_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionUsageReport_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionUsageReport_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionUsageReport (OSCTXT* pctxt, PDUSessionUsageReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionUsageReport");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionUsageReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode rATType */
   RTXCTXTPUSHELEMNAME (pctxt, "rATType");

   stat = asn1PD_PDUSessionUsageReport_rATType (pctxt, &pvalue->rATType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionTimedReportList */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionTimedReportList");

   stat = asn1PD_VolumeTimedReportList (pctxt, &pvalue->pDUSessionTimedReportList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionUsageReport_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionUsageReport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QoSFlowsUsageReport_Item_iE_Extensions_element (OSCTXT* pctxt, QoSFlowsUsageReport_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QoSFlowsUsageReport_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QoSFlowsUsageReport_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QoSFlowsUsageReport_Item_iE_Extensions (OSCTXT* pctxt, QoSFlowsUsageReport_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QoSFlowsUsageReport_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QoSFlowsUsageReport_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QoSFlowsUsageReport_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QoSFlowsUsageReport_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QoSFlowsUsageReport_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QoSFlowsUsageReport_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QoSFlowsUsageReport_Item (OSCTXT* pctxt, QoSFlowsUsageReport_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QoSFlowsUsageReport-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_QoSFlowsUsageReport_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rATType */
   RTXCTXTPUSHELEMNAME (pctxt, "rATType");

   stat = asn1PD_QoSFlowsUsageReport_Item_rATType (pctxt, &pvalue->rATType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode qoSFlowsTimedReportList */
   RTXCTXTPUSHELEMNAME (pctxt, "qoSFlowsTimedReportList");

   stat = asn1PD_VolumeTimedReportList (pctxt, &pvalue->qoSFlowsTimedReportList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QoSFlowsUsageReport_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QoSFlowsUsageReport_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QoSFlowsUsageReportList (OSCTXT* pctxt, QoSFlowsUsageReportList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QoSFlowsUsageReportList");

   RTDIAGSTRM2 (pctxt,"asn1PD_QoSFlowsUsageReportList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QoSFlowsUsageReport_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QoSFlowsUsageReport-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, QoSFlowsUsageReport_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QoSFlowsUsageReport_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QoSFlowsUsageReport_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QoSFlowsUsageReportList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecondaryRATUsageInformation_iE_Extension_element (OSCTXT* pctxt, SecondaryRATUsageInformation_iE_Extension_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATUsageInformation_iE_Extension_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATUsageInformation_iE_Extension_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SecondaryRATUsageInformation_iE_Extension (OSCTXT* pctxt, SecondaryRATUsageInformation_iE_Extension* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATUsageInformation_iE_Extension: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SecondaryRATUsageInformation_iE_Extension_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SecondaryRATUsageInformation_iE_Extension_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecondaryRATUsageInformation_iE_Extension_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SecondaryRATUsageInformation_iE_Extension_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATUsageInformation_iE_Extension: end\n");

   return (stat);
}

EXTERN int asn1PD_SecondaryRATUsageInformation (OSCTXT* pctxt, SecondaryRATUsageInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "SecondaryRATUsageInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATUsageInformation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionUsageReport */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionUsageReport");

      pvalue->m.pDUSessionUsageReportPresent = 1;

      stat = asn1PD_PDUSessionUsageReport (pctxt, &pvalue->pDUSessionUsageReport);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode qosFlowsUsageReportList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowsUsageReportList");

      pvalue->m.qosFlowsUsageReportListPresent = 1;

      stat = asn1PD_QoSFlowsUsageReportList (pctxt, &pvalue->qosFlowsUsageReportList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extension */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extension");

      pvalue->m.iE_ExtensionPresent = 1;

      stat = asn1PD_SecondaryRATUsageInformation_iE_Extension (pctxt, &pvalue->iE_Extension);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATUsageInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndicationTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceModifyIndicationTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecondaryRATUsageInformation */
   case ASN1V_id_SecondaryRATUsageInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecondaryRATUsageInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecondaryRATUsageInformation");

      pvalue->extensionValue.
         u._PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecondaryRATUsageInformation
          = rtxMemAllocType (pctxt, SecondaryRATUsageInformation);

      if (pvalue->extensionValue.
         u._PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecondaryRATUsageInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecondaryRATUsageInformation ((SecondaryRATUsageInformation*)
         pvalue->extensionValue.
         u._PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecondaryRATUsageInformation
         );

      stat = asn1PD_SecondaryRATUsageInformation (pctxt, 
         (SecondaryRATUsageInformation*)pvalue->extensionValue.
         u._PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecondaryRATUsageInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecurityResult */
   case ASN1V_id_SecurityResult:
      pvalue->extensionValue.
         t = T_NGAP_IEs_PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecurityResult;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecurityResult");

      pvalue->extensionValue.
         u._PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecurityResult
          = rtxMemAllocType (pctxt, SecurityResult);

      if (pvalue->extensionValue.
         u._PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecurityResult
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecurityResult ((SecurityResult*)pvalue->extensionValue.
         u._PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecurityResult
         );

      stat = asn1PD_SecurityResult (pctxt, (SecurityResult*)pvalue->
         extensionValue.
         u._PDUSessionResourceModifyIndicationTransfer_ExtIEs_id_SecurityResult
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_PDUSessionResourceModifyIndicationTransfer_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndicationTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceModifyIndicationTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyIndicationTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyIndicationTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyIndicationTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyIndicationTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndicationTransfer (OSCTXT* pctxt, PDUSessionResourceModifyIndicationTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyIndicationTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dLQosFlowPerTNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "dLQosFlowPerTNLInformation");

   stat = asn1PD_QosFlowPerTNLInformation (pctxt, &pvalue->dLQosFlowPerTNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode additionalDLQosFlowPerTNLInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalDLQosFlowPerTNLInformation");

      pvalue->m.additionalDLQosFlowPerTNLInformationPresent = 1;

      stat = asn1PD_QosFlowPerTNLInformationList (pctxt, &pvalue->additionalDLQosFlowPerTNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceModifyIndicationTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndicationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModCfm_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceModifyItemModCfm_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModCfm_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModCfm_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModCfm_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceModifyItemModCfm_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModCfm_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyItemModCfm_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyItemModCfm_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyItemModCfm_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyItemModCfm_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModCfm_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModCfm (OSCTXT* pctxt, PDUSessionResourceModifyItemModCfm* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyItemModCfm");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModCfm: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceModifyConfirmTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceModifyConfirmTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceModifyConfirmTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceModifyItemModCfm_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModCfm: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyListModCfm (OSCTXT* pctxt, PDUSessionResourceModifyListModCfm* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyListModCfm");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyListModCfm: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyItemModCfm* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceModifyItemModCfm", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyItemModCfm, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyItemModCfm (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyItemModCfm (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyListModCfm: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModInd_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceModifyItemModInd_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModInd_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModInd_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModInd_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceModifyItemModInd_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModInd_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyItemModInd_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyItemModInd_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyItemModInd_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyItemModInd_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModInd_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModInd (OSCTXT* pctxt, PDUSessionResourceModifyItemModInd* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyItemModInd");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModInd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceModifyIndicationTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceModifyIndicationTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceModifyIndicationTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceModifyItemModInd_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModInd: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyListModInd (OSCTXT* pctxt, PDUSessionResourceModifyListModInd* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyListModInd");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyListModInd: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyItemModInd* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceModifyItemModInd", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyItemModInd, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyItemModInd (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyItemModInd (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyListModInd: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModReq_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceModifyItemModReq_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModReq_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceModifyItemModReq_ExtIEs_id_S_NSSAI */
   case ASN1V_id_S_NSSAI:
      pvalue->extensionValue.
         t = T_NGAP_IEs_PDUSessionResourceModifyItemModReq_ExtIEs_id_S_NSSAI;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyItemModReq_ExtIEs_id_S_NSSAI");

      pvalue->extensionValue.
         u._PDUSessionResourceModifyItemModReq_ExtIEs_id_S_NSSAI
          = rtxMemAllocType (pctxt, S_NSSAI);

      if (pvalue->extensionValue.
         u._PDUSessionResourceModifyItemModReq_ExtIEs_id_S_NSSAI == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_S_NSSAI (pvalue->extensionValue.
         u._PDUSessionResourceModifyItemModReq_ExtIEs_id_S_NSSAI);

      stat = asn1PD_S_NSSAI (pctxt, pvalue->extensionValue.
         u._PDUSessionResourceModifyItemModReq_ExtIEs_id_S_NSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_PDUSessionResourceModifyItemModReq_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModReq_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModReq_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceModifyItemModReq_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModReq_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyItemModReq_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyItemModReq_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyItemModReq_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyItemModReq_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModReq_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModReq (OSCTXT* pctxt, PDUSessionResourceModifyItemModReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyItemModReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModReq: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nAS_PDU */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nAS-PDU");

      pvalue->m.nAS_PDUPresent = 1;

      stat = asn1PD_NAS_PDU (pctxt, &pvalue->nAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pDUSessionResourceModifyRequestTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceModifyRequestTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceModifyRequestTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceModifyItemModReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyListModReq (OSCTXT* pctxt, PDUSessionResourceModifyListModReq* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyListModReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyListModReq: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyItemModReq* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceModifyItemModReq", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyItemModReq, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyItemModReq (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyItemModReq (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyListModReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModRes_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceModifyItemModRes_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModRes_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModRes_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModRes_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceModifyItemModRes_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModRes_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyItemModRes_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyItemModRes_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyItemModRes_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyItemModRes_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModRes_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyItemModRes (OSCTXT* pctxt, PDUSessionResourceModifyItemModRes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyItemModRes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModRes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceModifyResponseTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceModifyResponseTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceModifyResponseTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceModifyItemModRes_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyItemModRes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyListModRes (OSCTXT* pctxt, PDUSessionResourceModifyListModRes* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyListModRes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyListModRes: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyItemModRes* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceModifyItemModRes", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyItemModRes, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyItemModRes (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyItemModRes (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyListModRes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer (OSCTXT* pctxt, PDUSessionResourceModifyUnsuccessfulTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyUnsuccessfulTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticalityDiagnostics */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "criticalityDiagnostics");

      pvalue->m.criticalityDiagnosticsPresent = 1;

      stat = asn1PD_CriticalityDiagnostics (pctxt, &pvalue->criticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyUnsuccessfulTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotifyItem_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceNotifyItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotifyItem_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceNotifyItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceNotifyItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceNotifyItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceNotifyItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceNotifyItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotifyItem (OSCTXT* pctxt, PDUSessionResourceNotifyItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceNotifyItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceNotifyTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceNotifyTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceNotifyTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceNotifyItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotifyList (OSCTXT* pctxt, PDUSessionResourceNotifyList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceNotifyList");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceNotifyItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceNotifyItem", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceNotifyItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceNotifyItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceNotifyItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotifyReleasedTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceNotifyReleasedTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyReleasedTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceNotifyReleasedTransfer_ExtIEs_id_SecondaryRATUsageInformation */
   case ASN1V_id_SecondaryRATUsageInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_PDUSessionResourceNotifyReleasedTransfer_ExtIEs_id_SecondaryRATUsageInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyReleasedTransfer_ExtIEs_id_SecondaryRATUsageInformation");

      pvalue->extensionValue.
         u._PDUSessionResourceNotifyReleasedTransfer_ExtIEs_id_SecondaryRATUsageInformation
          = rtxMemAllocType (pctxt, SecondaryRATUsageInformation);

      if (pvalue->extensionValue.
         u._PDUSessionResourceNotifyReleasedTransfer_ExtIEs_id_SecondaryRATUsageInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecondaryRATUsageInformation (pvalue->extensionValue.
         u._PDUSessionResourceNotifyReleasedTransfer_ExtIEs_id_SecondaryRATUsageInformation
         );

      stat = asn1PD_SecondaryRATUsageInformation (pctxt, pvalue->extensionValue
         .
         u._PDUSessionResourceNotifyReleasedTransfer_ExtIEs_id_SecondaryRATUsageInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_PDUSessionResourceNotifyReleasedTransfer_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyReleasedTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotifyReleasedTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceNotifyReleasedTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyReleasedTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceNotifyReleasedTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceNotifyReleasedTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceNotifyReleasedTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceNotifyReleasedTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyReleasedTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotifyReleasedTransfer (OSCTXT* pctxt, PDUSessionResourceNotifyReleasedTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceNotifyReleasedTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyReleasedTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceNotifyReleasedTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyReleasedTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowNotifyItem_iE_Extensions_element (OSCTXT* pctxt, QosFlowNotifyItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowNotifyItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowNotifyItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowNotifyItem_iE_Extensions (OSCTXT* pctxt, QosFlowNotifyItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowNotifyItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowNotifyItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowNotifyItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowNotifyItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowNotifyItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowNotifyItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowNotifyItem (OSCTXT* pctxt, QosFlowNotifyItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowNotifyItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowNotifyItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode notificationCause */
   RTXCTXTPUSHELEMNAME (pctxt, "notificationCause");

   stat = asn1PD_NotificationCause (pctxt, &pvalue->notificationCause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowNotifyItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowNotifyItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowNotifyList (OSCTXT* pctxt, QosFlowNotifyList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowNotifyList");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowNotifyList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowNotifyItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowNotifyItem", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowNotifyItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowNotifyItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowNotifyItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowNotifyList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotifyTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceNotifyTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceNotifyTransfer_ExtIEs_id_SecondaryRATUsageInformation */
   case ASN1V_id_SecondaryRATUsageInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_PDUSessionResourceNotifyTransfer_ExtIEs_id_SecondaryRATUsageInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyTransfer_ExtIEs_id_SecondaryRATUsageInformation");

      pvalue->extensionValue.
         u._PDUSessionResourceNotifyTransfer_ExtIEs_id_SecondaryRATUsageInformation
          = rtxMemAllocType (pctxt, SecondaryRATUsageInformation);

      if (pvalue->extensionValue.
         u._PDUSessionResourceNotifyTransfer_ExtIEs_id_SecondaryRATUsageInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecondaryRATUsageInformation (pvalue->extensionValue.
         u._PDUSessionResourceNotifyTransfer_ExtIEs_id_SecondaryRATUsageInformation
         );

      stat = asn1PD_SecondaryRATUsageInformation (pctxt, pvalue->extensionValue
         .
         u._PDUSessionResourceNotifyTransfer_ExtIEs_id_SecondaryRATUsageInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_PDUSessionResourceNotifyTransfer_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotifyTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceNotifyTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceNotifyTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceNotifyTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceNotifyTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceNotifyTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotifyTransfer (OSCTXT* pctxt, PDUSessionResourceNotifyTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceNotifyTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowNotifyList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowNotifyList");

      pvalue->m.qosFlowNotifyListPresent = 1;

      stat = asn1PD_QosFlowNotifyList (pctxt, &pvalue->qosFlowNotifyList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode qosFlowReleasedList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowReleasedList");

      pvalue->m.qosFlowReleasedListPresent = 1;

      stat = asn1PD_QosFlowListWithCause (pctxt, &pvalue->qosFlowReleasedList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceNotifyTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotifyTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseCommandTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceReleaseCommandTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommandTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommandTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseCommandTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceReleaseCommandTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommandTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleaseCommandTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleaseCommandTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleaseCommandTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleaseCommandTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommandTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseCommandTransfer (OSCTXT* pctxt, PDUSessionResourceReleaseCommandTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleaseCommandTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommandTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceReleaseCommandTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommandTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemNot_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceReleasedItemNot_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemNot_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemNot_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemNot_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceReleasedItemNot_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemNot_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleasedItemNot_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleasedItemNot_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedItemNot_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleasedItemNot_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemNot_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemNot (OSCTXT* pctxt, PDUSessionResourceReleasedItemNot* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleasedItemNot");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemNot: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceNotifyReleasedTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceNotifyReleasedTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceNotifyReleasedTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceReleasedItemNot_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemNot: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedListNot (OSCTXT* pctxt, PDUSessionResourceReleasedListNot* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleasedListNot");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedListNot: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleasedItemNot* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceReleasedItemNot", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleasedItemNot, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedItemNot (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleasedItemNot (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedListNot: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemPSAck_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceReleasedItemPSAck_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSAck_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSAck_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemPSAck_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceReleasedItemPSAck_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSAck_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleasedItemPSAck_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleasedItemPSAck_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedItemPSAck_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleasedItemPSAck_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSAck_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemPSAck (OSCTXT* pctxt, PDUSessionResourceReleasedItemPSAck* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleasedItemPSAck");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSAck: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pathSwitchRequestUnsuccessfulTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pathSwitchRequestUnsuccessfulTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pathSwitchRequestUnsuccessfulTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceReleasedItemPSAck_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSAck: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedListPSAck (OSCTXT* pctxt, PDUSessionResourceReleasedListPSAck* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleasedListPSAck");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedListPSAck: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleasedItemPSAck* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceReleasedItemPSAck", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleasedItemPSAck, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedItemPSAck (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleasedItemPSAck (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedListPSAck: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemPSFail_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceReleasedItemPSFail_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSFail_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSFail_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemPSFail_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceReleasedItemPSFail_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSFail_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleasedItemPSFail_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleasedItemPSFail_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedItemPSFail_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleasedItemPSFail_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSFail_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemPSFail (OSCTXT* pctxt, PDUSessionResourceReleasedItemPSFail* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleasedItemPSFail");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSFail: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pathSwitchRequestUnsuccessfulTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pathSwitchRequestUnsuccessfulTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pathSwitchRequestUnsuccessfulTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceReleasedItemPSFail_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemPSFail: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedListPSFail (OSCTXT* pctxt, PDUSessionResourceReleasedListPSFail* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleasedListPSFail");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedListPSFail: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleasedItemPSFail* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceReleasedItemPSFail", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleasedItemPSFail, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedItemPSFail (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleasedItemPSFail (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedListPSFail: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemRelRes_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceReleasedItemRelRes_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemRelRes_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemRelRes_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemRelRes_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceReleasedItemRelRes_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemRelRes_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleasedItemRelRes_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleasedItemRelRes_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedItemRelRes_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleasedItemRelRes_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemRelRes_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedItemRelRes (OSCTXT* pctxt, PDUSessionResourceReleasedItemRelRes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleasedItemRelRes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemRelRes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceReleaseResponseTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceReleaseResponseTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceReleaseResponseTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceReleasedItemRelRes_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedItemRelRes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleasedListRelRes (OSCTXT* pctxt, PDUSessionResourceReleasedListRelRes* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleasedListRelRes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedListRelRes: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleasedItemRelRes* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceReleasedItemRelRes", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleasedItemRelRes, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedItemRelRes (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleasedItemRelRes (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleasedListRelRes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseResponseTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceReleaseResponseTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponseTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceReleaseResponseTransfer_ExtIEs_id_SecondaryRATUsageInformation */
   case ASN1V_id_SecondaryRATUsageInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_PDUSessionResourceReleaseResponseTransfer_ExtIEs_id_SecondaryRATUsageInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseTransfer_ExtIEs_id_SecondaryRATUsageInformation");

      pvalue->extensionValue.
         u._PDUSessionResourceReleaseResponseTransfer_ExtIEs_id_SecondaryRATUsageInformation
          = rtxMemAllocType (pctxt, SecondaryRATUsageInformation);

      if (pvalue->extensionValue.
         u._PDUSessionResourceReleaseResponseTransfer_ExtIEs_id_SecondaryRATUsageInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecondaryRATUsageInformation (pvalue->extensionValue.
         u._PDUSessionResourceReleaseResponseTransfer_ExtIEs_id_SecondaryRATUsageInformation
         );

      stat = asn1PD_SecondaryRATUsageInformation (pctxt, pvalue->extensionValue
         .
         u._PDUSessionResourceReleaseResponseTransfer_ExtIEs_id_SecondaryRATUsageInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_PDUSessionResourceReleaseResponseTransfer_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponseTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseResponseTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceReleaseResponseTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponseTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleaseResponseTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleaseResponseTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleaseResponseTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleaseResponseTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponseTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseResponseTransfer (OSCTXT* pctxt, PDUSessionResourceReleaseResponseTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleaseResponseTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponseTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceReleaseResponseTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponseTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecondaryRATDataUsageReportTransfer_iE_Extensions_element (OSCTXT* pctxt, SecondaryRATDataUsageReportTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReportTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReportTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SecondaryRATDataUsageReportTransfer_iE_Extensions (OSCTXT* pctxt, SecondaryRATDataUsageReportTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReportTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SecondaryRATDataUsageReportTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SecondaryRATDataUsageReportTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecondaryRATDataUsageReportTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SecondaryRATDataUsageReportTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReportTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SecondaryRATDataUsageReportTransfer (OSCTXT* pctxt, SecondaryRATDataUsageReportTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SecondaryRATDataUsageReportTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReportTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode secondaryRATUsageInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "secondaryRATUsageInformation");

      pvalue->m.secondaryRATUsageInformationPresent = 1;

      stat = asn1PD_SecondaryRATUsageInformation (pctxt, &pvalue->secondaryRATUsageInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SecondaryRATDataUsageReportTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReportTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSecondaryRATUsageItem_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceSecondaryRATUsageItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSecondaryRATUsageItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSecondaryRATUsageItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSecondaryRATUsageItem_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceSecondaryRATUsageItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSecondaryRATUsageItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSecondaryRATUsageItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSecondaryRATUsageItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSecondaryRATUsageItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSecondaryRATUsageItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSecondaryRATUsageItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSecondaryRATUsageItem (OSCTXT* pctxt, PDUSessionResourceSecondaryRATUsageItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSecondaryRATUsageItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSecondaryRATUsageItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode secondaryRATDataUsageReportTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "secondaryRATDataUsageReportTransfer");

    {
      OSCTXT lctxt;
      ASN1DynOctStr loctstr;
      OSRTDiagBitFieldList* pFieldList;
      OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

      stat = pd_DynOctetString (pctxt, &loctstr);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxCopyContext (&lctxt, pctxt);

      pFieldList = pctxt->pBitFldList;
      if (0 != pFieldList) {
         pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
      }
      stat = pd_setp (pctxt, (OSOCTET*)loctstr.data,
         loctstr.numocts, pctxt->buffer.aligned);

      if (0 == stat) {
         stat = asn1PD_SecondaryRATDataUsageReportTransfer (pctxt, &pvalue->secondaryRATDataUsageReportTransfer);

      }
      rtxCopyContext (pctxt, &lctxt);
      rtxMemFreePtr (pctxt, loctstr.data);

      if (0 != pctxt->pBitFldList) {
         PU_SETOPENTYPEFLDLIST (pFieldList, pctxt->pBitFldList);
         pctxt->pBitFldList = pFieldList;
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceSecondaryRATUsageItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSecondaryRATUsageItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSecondaryRATUsageList (OSCTXT* pctxt, PDUSessionResourceSecondaryRATUsageList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSecondaryRATUsageList");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSecondaryRATUsageList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSecondaryRATUsageItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceSecondaryRATUsageItem", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSecondaryRATUsageItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSecondaryRATUsageItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSecondaryRATUsageItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSecondaryRATUsageList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowSetupRequestItem_iE_Extensions_element (OSCTXT* pctxt, QosFlowSetupRequestItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupRequestItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupRequestItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowSetupRequestItem_iE_Extensions (OSCTXT* pctxt, QosFlowSetupRequestItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupRequestItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowSetupRequestItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowSetupRequestItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowSetupRequestItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowSetupRequestItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupRequestItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowSetupRequestItem (OSCTXT* pctxt, QosFlowSetupRequestItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowSetupRequestItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupRequestItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode qosFlowLevelQosParameters */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowLevelQosParameters");

   stat = asn1PD_QosFlowLevelQosParameters (pctxt, &pvalue->qosFlowLevelQosParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode e_RAB_ID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RAB-ID");

      pvalue->m.e_RAB_IDPresent = 1;

      stat = asn1PD_E_RAB_ID (pctxt, &pvalue->e_RAB_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowSetupRequestItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupRequestItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowSetupRequestList (OSCTXT* pctxt, QosFlowSetupRequestList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowSetupRequestList");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupRequestList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowSetupRequestItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowSetupRequestItem", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowSetupRequestItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowSetupRequestItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowSetupRequestItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupRequestList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupRequestTransfer_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceSetupRequestTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequestTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate */
   case ASN1V_id_PDUSessionAggregateMaximumBitRate:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate");

      pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate
          = rtxMemAllocType (pctxt, PDUSessionAggregateMaximumBitRate);

      if (pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionAggregateMaximumBitRate (
         (PDUSessionAggregateMaximumBitRate*)pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate
         );

      stat = asn1PD_PDUSessionAggregateMaximumBitRate (pctxt, 
         (PDUSessionAggregateMaximumBitRate*)pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionAggregateMaximumBitRate
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestTransferIEs_id_UL_NGU_UP_TNLInformation */
   case ASN1V_id_UL_NGU_UP_TNLInformation:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceSetupRequestTransferIEs_id_UL_NGU_UP_TNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestTransferIEs_id_UL_NGU_UP_TNLInformation");

      pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_UL_NGU_UP_TNLInformation
          = rtxMemAllocType (pctxt, UPTransportLayerInformation);

      if (pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_UL_NGU_UP_TNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformation ((UPTransportLayerInformation*)
         pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_UL_NGU_UP_TNLInformation
         );

      stat = asn1PD_UPTransportLayerInformation (pctxt, 
         (UPTransportLayerInformation*)pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_UL_NGU_UP_TNLInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation */
   case ASN1V_id_AdditionalUL_NGU_UP_TNLInformation:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceSetupRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation");

      pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation
          = rtxMemAllocType (pctxt, UPTransportLayerInformationList);

      if (pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UPTransportLayerInformationList (pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation
         );

      stat = asn1PD_UPTransportLayerInformationList (pctxt, pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_AdditionalUL_NGU_UP_TNLInformation
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestTransferIEs_id_DataForwardingNotPossible */
   case ASN1V_id_DataForwardingNotPossible:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceSetupRequestTransferIEs_id_DataForwardingNotPossible;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestTransferIEs_id_DataForwardingNotPossible");

      stat = asn1PD_DataForwardingNotPossible (pctxt, &pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_DataForwardingNotPossible
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionType */
   case ASN1V_id_PDUSessionType:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionType;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionType");

      stat = asn1PD_PDUSessionType (pctxt, &pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_PDUSessionType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestTransferIEs_id_SecurityIndication */
   case ASN1V_id_SecurityIndication:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceSetupRequestTransferIEs_id_SecurityIndication;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestTransferIEs_id_SecurityIndication");

      pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_SecurityIndication
          = rtxMemAllocType (pctxt, SecurityIndication);

      if (pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_SecurityIndication
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecurityIndication ((SecurityIndication*)pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_SecurityIndication);

      stat = asn1PD_SecurityIndication (pctxt, (SecurityIndication*)pvalue->
         value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_SecurityIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestTransferIEs_id_NetworkInstance */
   case ASN1V_id_NetworkInstance:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceSetupRequestTransferIEs_id_NetworkInstance;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestTransferIEs_id_NetworkInstance");

      stat = asn1PD_NetworkInstance (pctxt, &pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_NetworkInstance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestTransferIEs_id_QosFlowSetupRequestList */
   case ASN1V_id_QosFlowSetupRequestList:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceSetupRequestTransferIEs_id_QosFlowSetupRequestList;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestTransferIEs_id_QosFlowSetupRequestList");

      pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_QosFlowSetupRequestList
          = rtxMemAllocType (pctxt, QosFlowSetupRequestList);

      if (pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_QosFlowSetupRequestList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowSetupRequestList (pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_QosFlowSetupRequestList
         );

      stat = asn1PD_QosFlowSetupRequestList (pctxt, pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_QosFlowSetupRequestList
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestTransferIEs_id_CommonNetworkInstance */
   case ASN1V_id_CommonNetworkInstance:
      pvalue->value.
         t = T_NGAP_IEs_PDUSessionResourceSetupRequestTransferIEs_id_CommonNetworkInstance;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestTransferIEs_id_CommonNetworkInstance");

      pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_CommonNetworkInstance
          = rtxMemAllocType (pctxt, CommonNetworkInstance);

      if (pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_CommonNetworkInstance
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CommonNetworkInstance (pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_CommonNetworkInstance
         );

      stat = asn1PD_CommonNetworkInstance (pctxt, pvalue->value.
         u._PDUSessionResourceSetupRequestTransferIEs_id_CommonNetworkInstance
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_IEs_PDUSessionResourceSetupRequestTransferIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequestTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupRequestTransfer_protocolIEs (OSCTXT* pctxt, PDUSessionResourceSetupRequestTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequestTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupRequestTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupRequestTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupRequestTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupRequestTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequestTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupRequestTransfer (OSCTXT* pctxt, PDUSessionResourceSetupRequestTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupRequestTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequestTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceSetupRequestTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequestTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemCxtReq_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceSetupItemCxtReq_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtReq_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtReq_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemCxtReq_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceSetupItemCxtReq_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtReq_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupItemCxtReq_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupItemCxtReq_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupItemCxtReq_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupItemCxtReq_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtReq_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemCxtReq (OSCTXT* pctxt, PDUSessionResourceSetupItemCxtReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupItemCxtReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtReq: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nAS_PDU */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nAS-PDU");

      pvalue->m.nAS_PDUPresent = 1;

      stat = asn1PD_NAS_PDU (pctxt, &pvalue->nAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode s_NSSAI */
   RTXCTXTPUSHELEMNAME (pctxt, "s-NSSAI");

   stat = asn1PD_S_NSSAI (pctxt, &pvalue->s_NSSAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceSetupRequestTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceSetupRequestTransfer");
   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceSetupRequestTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

/*
    {
      OSCTXT lctxt;
      ASN1DynOctStr loctstr;
      OSRTDiagBitFieldList* pFieldList;
      OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

      stat = pd_DynOctetString (pctxt, &loctstr);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxCopyContext (&lctxt, pctxt);

      pFieldList = pctxt->pBitFldList;
      if (0 != pFieldList) {
         pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
      }
      stat = pd_setp (pctxt, (OSOCTET*)loctstr.data,
         loctstr.numocts, pctxt->buffer.aligned);

      if (0 == stat) {
         stat = asn1PD_PDUSessionResourceSetupRequestTransfer (pctxt, &pvalue->pDUSessionResourceSetupRequestTransfer);

      }
      rtxCopyContext (pctxt, &lctxt);
      rtxMemFreePtr (pctxt, loctstr.data);

      if (0 != pctxt->pBitFldList) {
         PU_SETOPENTYPEFLDLIST (pFieldList, pctxt->pBitFldList);
         pctxt->pBitFldList = pFieldList;
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
*/
   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceSetupItemCxtReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupListCxtReq (OSCTXT* pctxt, PDUSessionResourceSetupListCxtReq* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupListCxtReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupListCxtReq: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupItemCxtReq* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceSetupItemCxtReq", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupItemCxtReq, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupItemCxtReq (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupItemCxtReq (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupListCxtReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupResponseTransfer_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceSetupResponseTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponseTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponseTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupResponseTransfer_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceSetupResponseTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponseTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupResponseTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupResponseTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupResponseTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupResponseTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponseTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupResponseTransfer (OSCTXT* pctxt, PDUSessionResourceSetupResponseTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupResponseTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponseTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dLQosFlowPerTNLInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "dLQosFlowPerTNLInformation");

   stat = asn1PD_QosFlowPerTNLInformation (pctxt, &pvalue->dLQosFlowPerTNLInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode additionalDLQosFlowPerTNLInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "additionalDLQosFlowPerTNLInformation");

      pvalue->m.additionalDLQosFlowPerTNLInformationPresent = 1;

      stat = asn1PD_QosFlowPerTNLInformationList (pctxt, &pvalue->additionalDLQosFlowPerTNLInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode securityResult */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "securityResult");

      pvalue->m.securityResultPresent = 1;

      stat = asn1PD_SecurityResult (pctxt, &pvalue->securityResult);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode qosFlowFailedToSetupList */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "qosFlowFailedToSetupList");

      pvalue->m.qosFlowFailedToSetupListPresent = 1;

      stat = asn1PD_QosFlowListWithCause (pctxt, &pvalue->qosFlowFailedToSetupList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceSetupResponseTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponseTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemCxtRes_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceSetupItemCxtRes_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtRes_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtRes_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemCxtRes_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceSetupItemCxtRes_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtRes_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupItemCxtRes_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupItemCxtRes_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupItemCxtRes_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupItemCxtRes_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtRes_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemCxtRes (OSCTXT* pctxt, PDUSessionResourceSetupItemCxtRes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupItemCxtRes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtRes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceSetupResponseTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceSetupResponseTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceSetupResponseTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   /*
    {
      OSCTXT lctxt;
      ASN1DynOctStr loctstr;
      OSRTDiagBitFieldList* pFieldList;
      OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

      stat = pd_DynOctetString (pctxt, &loctstr);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxCopyContext (&lctxt, pctxt);

      pFieldList = pctxt->pBitFldList;
      if (0 != pFieldList) {
         pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
      }
      stat = pd_setp (pctxt, (OSOCTET*)loctstr.data,
         loctstr.numocts, pctxt->buffer.aligned);

      if (0 == stat) {
         stat = asn1PD_PDUSessionResourceSetupResponseTransfer (pctxt, &pvalue->pDUSessionResourceSetupResponseTransfer);

      }
      rtxCopyContext (pctxt, &lctxt);
      rtxMemFreePtr (pctxt, loctstr.data);

      if (0 != pctxt->pBitFldList) {
         PU_SETOPENTYPEFLDLIST (pFieldList, pctxt->pBitFldList);
         pctxt->pBitFldList = pFieldList;
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
*/
   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceSetupItemCxtRes_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemCxtRes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupListCxtRes (OSCTXT* pctxt, PDUSessionResourceSetupListCxtRes* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupListCxtRes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupListCxtRes: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupItemCxtRes* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceSetupItemCxtRes", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupItemCxtRes, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupItemCxtRes (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupItemCxtRes (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupListCxtRes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemHOReq_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceSetupItemHOReq_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemHOReq_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemHOReq_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemHOReq_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceSetupItemHOReq_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemHOReq_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupItemHOReq_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupItemHOReq_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupItemHOReq_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupItemHOReq_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemHOReq_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemHOReq (OSCTXT* pctxt, PDUSessionResourceSetupItemHOReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupItemHOReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemHOReq: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode s_NSSAI */
   RTXCTXTPUSHELEMNAME (pctxt, "s-NSSAI");

   stat = asn1PD_S_NSSAI (pctxt, &pvalue->s_NSSAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode handoverRequestTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "handoverRequestTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->handoverRequestTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceSetupItemHOReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemHOReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupListHOReq (OSCTXT* pctxt, PDUSessionResourceSetupListHOReq* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupListHOReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupListHOReq: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupItemHOReq* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceSetupItemHOReq", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupItemHOReq, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupItemHOReq (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupItemHOReq (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupListHOReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemSUReq_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceSetupItemSUReq_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSUReq_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSUReq_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemSUReq_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceSetupItemSUReq_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSUReq_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupItemSUReq_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupItemSUReq_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupItemSUReq_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupItemSUReq_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSUReq_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemSUReq (OSCTXT* pctxt, PDUSessionResourceSetupItemSUReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupItemSUReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSUReq: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionNAS_PDU */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionNAS-PDU");

      pvalue->m.pDUSessionNAS_PDUPresent = 1;

      stat = asn1PD_NAS_PDU (pctxt, &pvalue->pDUSessionNAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode s_NSSAI */
   RTXCTXTPUSHELEMNAME (pctxt, "s-NSSAI");

   stat = asn1PD_S_NSSAI (pctxt, &pvalue->s_NSSAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceSetupRequestTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceSetupRequestTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceSetupRequestTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceSetupItemSUReq_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSUReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupListSUReq (OSCTXT* pctxt, PDUSessionResourceSetupListSUReq* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupListSUReq");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupListSUReq: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupItemSUReq* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceSetupItemSUReq", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupItemSUReq, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupItemSUReq (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupItemSUReq (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupListSUReq: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemSURes_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceSetupItemSURes_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSURes_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSURes_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemSURes_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceSetupItemSURes_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSURes_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupItemSURes_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupItemSURes_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupItemSURes_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupItemSURes_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSURes_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupItemSURes (OSCTXT* pctxt, PDUSessionResourceSetupItemSURes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupItemSURes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSURes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceSetupResponseTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceSetupResponseTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceSetupResponseTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceSetupItemSURes_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupItemSURes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupListSURes (OSCTXT* pctxt, PDUSessionResourceSetupListSURes* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupListSURes");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupListSURes: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupItemSURes* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceSetupItemSURes", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupItemSURes, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupItemSURes (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupItemSURes (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupListSURes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSwitchedItem_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceSwitchedItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSwitchedItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSwitchedItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSwitchedItem_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceSwitchedItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSwitchedItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSwitchedItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSwitchedItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSwitchedItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSwitchedItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSwitchedItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSwitchedItem (OSCTXT* pctxt, PDUSessionResourceSwitchedItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSwitchedItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSwitchedItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pathSwitchRequestAcknowledgeTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pathSwitchRequestAcknowledgeTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pathSwitchRequestAcknowledgeTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceSwitchedItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSwitchedItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSwitchedList (OSCTXT* pctxt, PDUSessionResourceSwitchedList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSwitchedList");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSwitchedList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSwitchedItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceSwitchedItem", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSwitchedItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSwitchedItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSwitchedItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSwitchedList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToBeSwitchedDLItem_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceToBeSwitchedDLItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToBeSwitchedDLItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToBeSwitchedDLItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToBeSwitchedDLItem_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceToBeSwitchedDLItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToBeSwitchedDLItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceToBeSwitchedDLItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceToBeSwitchedDLItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceToBeSwitchedDLItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceToBeSwitchedDLItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToBeSwitchedDLItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToBeSwitchedDLItem (OSCTXT* pctxt, PDUSessionResourceToBeSwitchedDLItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceToBeSwitchedDLItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToBeSwitchedDLItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pathSwitchRequestTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pathSwitchRequestTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pathSwitchRequestTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceToBeSwitchedDLItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToBeSwitchedDLItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToBeSwitchedDLList (OSCTXT* pctxt, PDUSessionResourceToBeSwitchedDLList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceToBeSwitchedDLList");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToBeSwitchedDLList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceToBeSwitchedDLItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceToBeSwitchedDLItem", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceToBeSwitchedDLItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceToBeSwitchedDLItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceToBeSwitchedDLItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToBeSwitchedDLList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToReleaseItemHOCmd_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceToReleaseItemHOCmd_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemHOCmd_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemHOCmd_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToReleaseItemHOCmd_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceToReleaseItemHOCmd_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemHOCmd_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceToReleaseItemHOCmd_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceToReleaseItemHOCmd_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceToReleaseItemHOCmd_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceToReleaseItemHOCmd_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemHOCmd_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToReleaseItemHOCmd (OSCTXT* pctxt, PDUSessionResourceToReleaseItemHOCmd* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceToReleaseItemHOCmd");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemHOCmd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode handoverPreparationUnsuccessfulTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "handoverPreparationUnsuccessfulTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->handoverPreparationUnsuccessfulTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceToReleaseItemHOCmd_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemHOCmd: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToReleaseListHOCmd (OSCTXT* pctxt, PDUSessionResourceToReleaseListHOCmd* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceToReleaseListHOCmd");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseListHOCmd: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceToReleaseItemHOCmd* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceToReleaseItemHOCmd", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceToReleaseItemHOCmd, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceToReleaseItemHOCmd (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceToReleaseItemHOCmd (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseListHOCmd: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToReleaseItemRelCmd_iE_Extensions_element (OSCTXT* pctxt, PDUSessionResourceToReleaseItemRelCmd_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemRelCmd_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemRelCmd_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToReleaseItemRelCmd_iE_Extensions (OSCTXT* pctxt, PDUSessionResourceToReleaseItemRelCmd_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemRelCmd_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceToReleaseItemRelCmd_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceToReleaseItemRelCmd_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceToReleaseItemRelCmd_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceToReleaseItemRelCmd_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemRelCmd_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToReleaseItemRelCmd (OSCTXT* pctxt, PDUSessionResourceToReleaseItemRelCmd* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceToReleaseItemRelCmd");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemRelCmd: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pDUSessionID */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionID");

   stat = asn1PD_PDUSessionID (pctxt, &pvalue->pDUSessionID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceReleaseCommandTransfer */
   RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceReleaseCommandTransfer");

   stat = pd_DynOctetString (pctxt, &pvalue->pDUSessionResourceReleaseCommandTransfer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PDUSessionResourceToReleaseItemRelCmd_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseItemRelCmd: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceToReleaseListRelCmd (OSCTXT* pctxt, PDUSessionResourceToReleaseListRelCmd* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceToReleaseListRelCmd");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseListRelCmd: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceToReleaseItemRelCmd* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDUSessionResourceToReleaseItemRelCmd", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceToReleaseItemRelCmd, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceToReleaseItemRelCmd (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceToReleaseItemRelCmd (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceToReleaseListRelCmd: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PLMNSupportItem_iE_Extensions_element (OSCTXT* pctxt, PLMNSupportItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PLMNSupportItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PLMNSupportItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PLMNSupportItem_iE_Extensions (OSCTXT* pctxt, PLMNSupportItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PLMNSupportItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PLMNSupportItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PLMNSupportItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PLMNSupportItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PLMNSupportItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PLMNSupportItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PLMNSupportItem (OSCTXT* pctxt, PLMNSupportItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PLMNSupportItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_PLMNSupportItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode pLMNIdentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNIdentity");

   stat = asn1PD_PLMNIdentity (pctxt, &pvalue->pLMNIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sliceSupportList */
   RTXCTXTPUSHELEMNAME (pctxt, "sliceSupportList");

   stat = asn1PD_SliceSupportList (pctxt, &pvalue->sliceSupportList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_PLMNSupportItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PLMNSupportItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PLMNSupportList (OSCTXT* pctxt, PLMNSupportList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMNSupportList");

   RTDIAGSTRM2 (pctxt,"asn1PD_PLMNSupportList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(12), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PLMNSupportItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PLMNSupportItem", xx1);

      rtxDListAllocNodeAndData (pctxt, PLMNSupportItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PLMNSupportItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PLMNSupportItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PLMNSupportList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PWSFailedCellIDList_choice_Extensions (OSCTXT* pctxt, PWSFailedCellIDList_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailedCellIDList_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailedCellIDList_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSFailedCellIDList (OSCTXT* pctxt, PWSFailedCellIDList* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSFailedCellIDList");

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailedCellIDList: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* eUTRA_CGI_PWSFailedList */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGI-PWSFailedList");

         pvalue->u.eUTRA_CGI_PWSFailedList = rtxMemAllocType (pctxt, 
            EUTRA_CGIList);

         if (pvalue->u.eUTRA_CGI_PWSFailedList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EUTRA_CGIList (pvalue->u.eUTRA_CGI_PWSFailedList);

         stat = asn1PD_EUTRA_CGIList (pctxt, pvalue->u.eUTRA_CGI_PWSFailedList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* nR_CGI_PWSFailedList */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "nR-CGI-PWSFailedList");

         pvalue->u.nR_CGI_PWSFailedList = rtxMemAllocType (pctxt, NR_CGIList);

         if (pvalue->u.nR_CGI_PWSFailedList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NR_CGIList (pvalue->u.nR_CGI_PWSFailedList);

         stat = asn1PD_NR_CGIList (pctxt, pvalue->u.nR_CGI_PWSFailedList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            PWSFailedCellIDList_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PWSFailedCellIDList_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_PWSFailedCellIDList_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailedCellIDList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowSetupResponseItemSURes_iE_Extensions_element (OSCTXT* pctxt, QosFlowSetupResponseItemSURes_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupResponseItemSURes_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupResponseItemSURes_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowSetupResponseItemSURes_iE_Extensions (OSCTXT* pctxt, QosFlowSetupResponseItemSURes_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupResponseItemSURes_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowSetupResponseItemSURes_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowSetupResponseItemSURes_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowSetupResponseItemSURes_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowSetupResponseItemSURes_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupResponseItemSURes_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_QosFlowSetupResponseItemSURes (OSCTXT* pctxt, QosFlowSetupResponseItemSURes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowSetupResponseItemSURes");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupResponseItemSURes: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode qosFlowIdentifier */
   RTXCTXTPUSHELEMNAME (pctxt, "qosFlowIdentifier");

   stat = asn1PD_QosFlowIdentifier (pctxt, &pvalue->qosFlowIdentifier);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_QosFlowSetupResponseItemSURes_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupResponseItemSURes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_QosFlowSetupResponseListSURes (OSCTXT* pctxt, QosFlowSetupResponseListSURes* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QosFlowSetupResponseListSURes");

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupResponseListSURes: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      QosFlowSetupResponseItemSURes* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QosFlowSetupResponseItemSURes", xx1);

      rtxDListAllocNodeAndData (pctxt, QosFlowSetupResponseItemSURes, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QosFlowSetupResponseItemSURes (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_QosFlowSetupResponseItemSURes (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_QosFlowSetupResponseListSURes: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RANStatusTransfer_TransparentContainer_iE_Extensions_element (OSCTXT* pctxt, RANStatusTransfer_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANStatusTransfer_TransparentContainer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RANStatusTransfer_TransparentContainer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RANStatusTransfer_TransparentContainer_iE_Extensions (OSCTXT* pctxt, RANStatusTransfer_TransparentContainer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANStatusTransfer_TransparentContainer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RANStatusTransfer_TransparentContainer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RANStatusTransfer_TransparentContainer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RANStatusTransfer_TransparentContainer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RANStatusTransfer_TransparentContainer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANStatusTransfer_TransparentContainer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_RANStatusTransfer_TransparentContainer (OSCTXT* pctxt, RANStatusTransfer_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RANStatusTransfer-TransparentContainer");

   RTDIAGSTRM2 (pctxt,"asn1PD_RANStatusTransfer_TransparentContainer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode dRBsSubjectToStatusTransferList */
   RTXCTXTPUSHELEMNAME (pctxt, "dRBsSubjectToStatusTransferList");

   stat = asn1PD_DRBsSubjectToStatusTransferList (pctxt, &pvalue->dRBsSubjectToStatusTransferList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_RANStatusTransfer_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANStatusTransfer_TransparentContainer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_associatedLogicalNG_connectionItem_iE_Extensions_element (OSCTXT* pctxt, UE_associatedLogicalNG_connectionItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_associatedLogicalNG_connectionItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_associatedLogicalNG_connectionItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UE_associatedLogicalNG_connectionItem_iE_Extensions (OSCTXT* pctxt, UE_associatedLogicalNG_connectionItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_associatedLogicalNG_connectionItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UE_associatedLogicalNG_connectionItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UE_associatedLogicalNG_connectionItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UE_associatedLogicalNG_connectionItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UE_associatedLogicalNG_connectionItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_associatedLogicalNG_connectionItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UE_associatedLogicalNG_connectionItem (OSCTXT* pctxt, UE_associatedLogicalNG_connectionItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "UE-associatedLogicalNG-connectionItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_associatedLogicalNG_connectionItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode aMF_UE_NGAP_ID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "aMF-UE-NGAP-ID");

      pvalue->m.aMF_UE_NGAP_IDPresent = 1;

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->aMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rAN_UE_NGAP_ID */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAN-UE-NGAP-ID");

      pvalue->m.rAN_UE_NGAP_IDPresent = 1;

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->rAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UE_associatedLogicalNG_connectionItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_associatedLogicalNG_connectionItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_associatedLogicalNG_connectionList (OSCTXT* pctxt, UE_associatedLogicalNG_connectionList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;
   int lstat;
   OSSIZE total = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-associatedLogicalNG-connectionList");

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_associatedLogicalNG_connectionList: start\n");

   rtxDListInit (pvalue);

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   for (;;) {
      /* decode length determinant */

      lstat = pd_Length64 (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_RTERR (pctxt, lstat);
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         UE_associatedLogicalNG_connectionItem* pdata;
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "UE-associatedLogicalNG-connectionItem", xx1);

         rtxDListAllocNodeAndData (pctxt, UE_associatedLogicalNG_connectionItem, &pnode, &pdata);

         if (pnode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_associatedLogicalNG_connectionItem (pdata);

         rtxDListAppendNode (pvalue, pnode);
         stat = asn1PD_UE_associatedLogicalNG_connectionItem (pctxt, pdata);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }

      if (lstat == 0) break;
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_associatedLogicalNG_connectionList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ResetType_choice_Extensions (OSCTXT* pctxt, ResetType_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetType_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetType_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_ResetType (OSCTXT* pctxt, ResetType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetType");

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetType: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* nG_Interface */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "nG-Interface");

         stat = asn1PD_ResetAll (pctxt, &pvalue->u.nG_Interface);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* partOfNG_Interface */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "partOfNG-Interface");

         pvalue->u.partOfNG_Interface = rtxMemAllocType (pctxt, 
            UE_associatedLogicalNG_connectionList);

         if (pvalue->u.partOfNG_Interface == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_associatedLogicalNG_connectionList (pvalue->u.partOfNG_Interface);

         stat = asn1PD_UE_associatedLogicalNG_connectionList (pctxt, pvalue->u.partOfNG_Interface);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            ResetType_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ResetType_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_ResetType_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ResetType: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SCTP_TLAs (OSCTXT* pctxt, SCTP_TLAs* pvalue)
{
   int stat = 0;
   OSUINT8 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SCTP-TLAs");

   RTDIAGSTRM2 (pctxt,"asn1PD_SCTP_TLAs: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToByte (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TransportLayerAddress", xx1);

      asn1Init_TransportLayerAddress (&pvalue->elem[xx1]);

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SCTP_TLAs: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecurityContext_iE_Extensions_element (OSCTXT* pctxt, SecurityContext_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityContext_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityContext_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SecurityContext_iE_Extensions (OSCTXT* pctxt, SecurityContext_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityContext_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SecurityContext_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SecurityContext_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecurityContext_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SecurityContext_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityContext_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SecurityContext (OSCTXT* pctxt, SecurityContext* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityContext");

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityContext: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nextHopChainingCount */
   RTXCTXTPUSHELEMNAME (pctxt, "nextHopChainingCount");

   stat = asn1PD_NextHopChainingCount (pctxt, &pvalue->nextHopChainingCount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nextHopNH */
   RTXCTXTPUSHELEMNAME (pctxt, "nextHopNH");

   stat = asn1PD_SecurityKey (pctxt, &pvalue->nextHopNH);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SecurityContext_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecurityContext: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ServedGUAMIItem_iE_Extensions_element (OSCTXT* pctxt, ServedGUAMIItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ServedGUAMIItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ServedGUAMIItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_ServedGUAMIItem_iE_Extensions (OSCTXT* pctxt, ServedGUAMIItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ServedGUAMIItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ServedGUAMIItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ServedGUAMIItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ServedGUAMIItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ServedGUAMIItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ServedGUAMIItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_ServedGUAMIItem (OSCTXT* pctxt, ServedGUAMIItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ServedGUAMIItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_ServedGUAMIItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode gUAMI */
   RTXCTXTPUSHELEMNAME (pctxt, "gUAMI");

   stat = asn1PD_GUAMI (pctxt, &pvalue->gUAMI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode backupAMFName */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "backupAMFName");

      pvalue->m.backupAMFNamePresent = 1;

      stat = asn1PD_AMFName (pctxt, &pvalue->backupAMFName);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ServedGUAMIItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ServedGUAMIItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ServedGUAMIList (OSCTXT* pctxt, ServedGUAMIList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ServedGUAMIList");

   RTDIAGSTRM2 (pctxt,"asn1PD_ServedGUAMIList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ServedGUAMIItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ServedGUAMIItem", xx1);

      rtxDListAllocNodeAndData (pctxt, ServedGUAMIItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ServedGUAMIItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ServedGUAMIItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ServedGUAMIList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TargetRANNodeID_iE_Extensions_element (OSCTXT* pctxt, TargetRANNodeID_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetRANNodeID_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetRANNodeID_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TargetRANNodeID_iE_Extensions (OSCTXT* pctxt, TargetRANNodeID_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetRANNodeID_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TargetRANNodeID_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TargetRANNodeID_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TargetRANNodeID_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TargetRANNodeID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetRANNodeID_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TargetRANNodeID (OSCTXT* pctxt, TargetRANNodeID* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TargetRANNodeID");

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetRANNodeID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode globalRANNodeID */
   RTXCTXTPUSHELEMNAME (pctxt, "globalRANNodeID");

   stat = asn1PD_GlobalRANNodeID (pctxt, &pvalue->globalRANNodeID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode selectedTAI */
   RTXCTXTPUSHELEMNAME (pctxt, "selectedTAI");

   stat = asn1PD_TAI (pctxt, &pvalue->selectedTAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TargetRANNodeID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetRANNodeID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SourceRANNodeID_iE_Extensions_element (OSCTXT* pctxt, SourceRANNodeID_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceRANNodeID_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceRANNodeID_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SourceRANNodeID_iE_Extensions (OSCTXT* pctxt, SourceRANNodeID_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceRANNodeID_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SourceRANNodeID_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SourceRANNodeID_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SourceRANNodeID_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SourceRANNodeID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceRANNodeID_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SourceRANNodeID (OSCTXT* pctxt, SourceRANNodeID* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SourceRANNodeID");

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceRANNodeID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode globalRANNodeID */
   RTXCTXTPUSHELEMNAME (pctxt, "globalRANNodeID");

   stat = asn1PD_GlobalRANNodeID (pctxt, &pvalue->globalRANNodeID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode selectedTAI */
   RTXCTXTPUSHELEMNAME (pctxt, "selectedTAI");

   stat = asn1PD_TAI (pctxt, &pvalue->selectedTAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SourceRANNodeID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceRANNodeID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_XnTLAs (OSCTXT* pctxt, XnTLAs* pvalue)
{
   int stat = 0;
   OSUINT8 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "XnTLAs");

   RTDIAGSTRM2 (pctxt,"asn1PD_XnTLAs: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToByte (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TransportLayerAddress", xx1);

      asn1Init_TransportLayerAddress (&pvalue->elem[xx1]);

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_XnTLAs: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_XnGTP_TLAs (OSCTXT* pctxt, XnGTP_TLAs* pvalue)
{
   int stat = 0;
   OSUINT8 xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "XnGTP-TLAs");

   RTDIAGSTRM2 (pctxt,"asn1PD_XnGTP_TLAs: start\n");

   /* decode length determinant */

   PU_NEWFIELD (pctxt, "n");

   stat = rtxDecBitsToByte (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 16){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TransportLayerAddress", xx1);

      asn1Init_TransportLayerAddress (&pvalue->elem[xx1]);

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_XnGTP_TLAs: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_XnExtTLA_Item_iE_Extensions_element (OSCTXT* pctxt, XnExtTLA_Item_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_XnExtTLA_Item_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _XnExtTLA_Item_ExtIEs_id_SCTP_TLAs */
   case ASN1V_id_SCTP_TLAs:
      pvalue->extensionValue.t = T_NGAP_IEs_XnExtTLA_Item_ExtIEs_id_SCTP_TLAs;

      RTXCTXTPUSHELEMNAME (pctxt, "_XnExtTLA_Item_ExtIEs_id_SCTP_TLAs");

      pvalue->extensionValue.u._XnExtTLA_Item_ExtIEs_id_SCTP_TLAs
          = rtxMemAllocType (pctxt, SCTP_TLAs);

      if (pvalue->extensionValue.u._XnExtTLA_Item_ExtIEs_id_SCTP_TLAs == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SCTP_TLAs (pvalue->extensionValue.
         u._XnExtTLA_Item_ExtIEs_id_SCTP_TLAs);

      stat = asn1PD_SCTP_TLAs (pctxt, pvalue->extensionValue.
         u._XnExtTLA_Item_ExtIEs_id_SCTP_TLAs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_XnExtTLA_Item_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_XnExtTLA_Item_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_XnExtTLA_Item_iE_Extensions (OSCTXT* pctxt, XnExtTLA_Item_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_XnExtTLA_Item_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      XnExtTLA_Item_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, XnExtTLA_Item_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_XnExtTLA_Item_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_XnExtTLA_Item_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_XnExtTLA_Item_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_XnExtTLA_Item (OSCTXT* pctxt, XnExtTLA_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "XnExtTLA-Item");

   RTDIAGSTRM2 (pctxt,"asn1PD_XnExtTLA_Item: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode iPsecTLA */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iPsecTLA");

      pvalue->m.iPsecTLAPresent = 1;

      stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->iPsecTLA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode gTP_TLAs */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "gTP-TLAs");

      pvalue->m.gTP_TLAsPresent = 1;

      stat = asn1PD_XnGTP_TLAs (pctxt, &pvalue->gTP_TLAs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_XnExtTLA_Item_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_XnExtTLA_Item: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_XnExtTLAs (OSCTXT* pctxt, XnExtTLAs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "XnExtTLAs");

   RTDIAGSTRM2 (pctxt,"asn1PD_XnExtTLAs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      XnExtTLA_Item* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "XnExtTLA-Item", xx1);

      rtxDListAllocNodeAndData (pctxt, XnExtTLA_Item, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_XnExtTLA_Item (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_XnExtTLA_Item (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_XnExtTLAs: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_XnTNLConfigurationInfo_iE_Extensions_element (OSCTXT* pctxt, XnTNLConfigurationInfo_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_XnTNLConfigurationInfo_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_XnTNLConfigurationInfo_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_XnTNLConfigurationInfo_iE_Extensions (OSCTXT* pctxt, XnTNLConfigurationInfo_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_XnTNLConfigurationInfo_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      XnTNLConfigurationInfo_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, XnTNLConfigurationInfo_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_XnTNLConfigurationInfo_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_XnTNLConfigurationInfo_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_XnTNLConfigurationInfo_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_XnTNLConfigurationInfo (OSCTXT* pctxt, XnTNLConfigurationInfo* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "XnTNLConfigurationInfo");

   RTDIAGSTRM2 (pctxt,"asn1PD_XnTNLConfigurationInfo: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode xnTransportLayerAddresses */
   RTXCTXTPUSHELEMNAME (pctxt, "xnTransportLayerAddresses");

   stat = asn1PD_XnTLAs (pctxt, &pvalue->xnTransportLayerAddresses);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode xnExtendedTransportLayerAddresses */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "xnExtendedTransportLayerAddresses");

      pvalue->m.xnExtendedTransportLayerAddressesPresent = 1;

      stat = asn1PD_XnExtTLAs (pctxt, &pvalue->xnExtendedTransportLayerAddresses);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_XnTNLConfigurationInfo_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_XnTNLConfigurationInfo: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SONInformationReply_iE_Extensions_element (OSCTXT* pctxt, SONInformationReply_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformationReply_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformationReply_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SONInformationReply_iE_Extensions (OSCTXT* pctxt, SONInformationReply_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformationReply_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SONInformationReply_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SONInformationReply_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SONInformationReply_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SONInformationReply_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformationReply_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SONInformationReply (OSCTXT* pctxt, SONInformationReply* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SONInformationReply");

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformationReply: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode xnTNLConfigurationInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "xnTNLConfigurationInfo");

      pvalue->m.xnTNLConfigurationInfoPresent = 1;

      stat = asn1PD_XnTNLConfigurationInfo (pctxt, &pvalue->xnTNLConfigurationInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SONInformationReply_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformationReply: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SONInformation_choice_Extensions (OSCTXT* pctxt, SONInformation_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformation_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformation_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SONInformation (OSCTXT* pctxt, SONInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SONInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformation: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* sONInformationRequest */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "sONInformationRequest");

         stat = asn1PD_SONInformationRequest (pctxt, &pvalue->u.sONInformationRequest);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sONInformationReply */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sONInformationReply");

         pvalue->u.sONInformationReply = rtxMemAllocType (pctxt, 
            SONInformationReply);

         if (pvalue->u.sONInformationReply == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SONInformationReply (pvalue->u.sONInformationReply);

         stat = asn1PD_SONInformationReply (pctxt, pvalue->u.sONInformationReply);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            SONInformation_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SONInformation_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_SONInformation_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SONInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SONConfigurationTransfer_iE_Extensions_element (OSCTXT* pctxt, SONConfigurationTransfer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SONConfigurationTransfer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SONConfigurationTransfer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SONConfigurationTransfer_iE_Extensions (OSCTXT* pctxt, SONConfigurationTransfer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SONConfigurationTransfer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SONConfigurationTransfer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SONConfigurationTransfer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SONConfigurationTransfer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SONConfigurationTransfer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SONConfigurationTransfer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SONConfigurationTransfer (OSCTXT* pctxt, SONConfigurationTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "SONConfigurationTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_SONConfigurationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode targetRANNodeID */
   RTXCTXTPUSHELEMNAME (pctxt, "targetRANNodeID");

   stat = asn1PD_TargetRANNodeID (pctxt, &pvalue->targetRANNodeID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sourceRANNodeID */
   RTXCTXTPUSHELEMNAME (pctxt, "sourceRANNodeID");

   stat = asn1PD_SourceRANNodeID (pctxt, &pvalue->sourceRANNodeID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sONInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "sONInformation");

   stat = asn1PD_SONInformation (pctxt, &pvalue->sONInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode xnTNLConfigurationInfo */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "xnTNLConfigurationInfo");

      pvalue->m.xnTNLConfigurationInfoPresent = 1;

      stat = asn1PD_XnTNLConfigurationInfo (pctxt, &pvalue->xnTNLConfigurationInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SONConfigurationTransfer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SONConfigurationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEHistoryInformation (OSCTXT* pctxt, UEHistoryInformation* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UEHistoryInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEHistoryInformation: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LastVisitedCellItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "LastVisitedCellItem", xx1);

      rtxDListAllocNodeAndData (pctxt, LastVisitedCellItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LastVisitedCellItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LastVisitedCellItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEHistoryInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions_element (OSCTXT* pctxt, SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions (OSCTXT* pctxt, SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer (OSCTXT* pctxt, SourceNGRANNode_ToTargetNGRANNode_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "SourceNGRANNode-ToTargetNGRANNode-TransparentContainer");

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode rRCContainer */
   RTXCTXTPUSHELEMNAME (pctxt, "rRCContainer");

   stat = asn1PD_RRCContainer (pctxt, &pvalue->rRCContainer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pDUSessionResourceInformationList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pDUSessionResourceInformationList");

      pvalue->m.pDUSessionResourceInformationListPresent = 1;

      stat = asn1PD_PDUSessionResourceInformationList (pctxt, &pvalue->pDUSessionResourceInformationList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode e_RABInformationList */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "e-RABInformationList");

      pvalue->m.e_RABInformationListPresent = 1;

      stat = asn1PD_E_RABInformationList (pctxt, &pvalue->e_RABInformationList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode targetCell_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "targetCell-ID");

   stat = asn1PD_NGRAN_CGI (pctxt, &pvalue->targetCell_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode indexToRFSP */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "indexToRFSP");

      pvalue->m.indexToRFSPPresent = 1;

      stat = asn1PD_IndexToRFSP (pctxt, &pvalue->indexToRFSP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uEHistoryInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "uEHistoryInformation");

   stat = asn1PD_UEHistoryInformation (pctxt, &pvalue->uEHistoryInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceNGRANNode_ToTargetNGRANNode_TransparentContainer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SourceToTarget_AMFInformationReroute_iE_Extensions_element (OSCTXT* pctxt, SourceToTarget_AMFInformationReroute_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceToTarget_AMFInformationReroute_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceToTarget_AMFInformationReroute_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SourceToTarget_AMFInformationReroute_iE_Extensions (OSCTXT* pctxt, SourceToTarget_AMFInformationReroute_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceToTarget_AMFInformationReroute_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SourceToTarget_AMFInformationReroute_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SourceToTarget_AMFInformationReroute_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SourceToTarget_AMFInformationReroute_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SourceToTarget_AMFInformationReroute_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceToTarget_AMFInformationReroute_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SourceToTarget_AMFInformationReroute (OSCTXT* pctxt, SourceToTarget_AMFInformationReroute* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "SourceToTarget-AMFInformationReroute");

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceToTarget_AMFInformationReroute: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode configuredNSSAI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "configuredNSSAI");

      pvalue->m.configuredNSSAIPresent = 1;

      stat = asn1PD_ConfiguredNSSAI (pctxt, &pvalue->configuredNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rejectedNSSAIinPLMN */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rejectedNSSAIinPLMN");

      pvalue->m.rejectedNSSAIinPLMNPresent = 1;

      stat = asn1PD_RejectedNSSAIinPLMN (pctxt, &pvalue->rejectedNSSAIinPLMN);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rejectedNSSAIinTA */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rejectedNSSAIinTA");

      pvalue->m.rejectedNSSAIinTAPresent = 1;

      stat = asn1PD_RejectedNSSAIinTA (pctxt, &pvalue->rejectedNSSAIinTA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SourceToTarget_AMFInformationReroute_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SourceToTarget_AMFInformationReroute: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedTAItem_iE_Extensions_element (OSCTXT* pctxt, SupportedTAItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SupportedTAItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SupportedTAItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SupportedTAItem_iE_Extensions (OSCTXT* pctxt, SupportedTAItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SupportedTAItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SupportedTAItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SupportedTAItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SupportedTAItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SupportedTAItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SupportedTAItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_SupportedTAItem (OSCTXT* pctxt, SupportedTAItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedTAItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_SupportedTAItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode tAC */
   RTXCTXTPUSHELEMNAME (pctxt, "tAC");

   stat = asn1PD_TAC (pctxt, &pvalue->tAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode broadcastPLMNList */
   RTXCTXTPUSHELEMNAME (pctxt, "broadcastPLMNList");

   stat = asn1PD_BroadcastPLMNList (pctxt, &pvalue->broadcastPLMNList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_SupportedTAItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SupportedTAItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SupportedTAList (OSCTXT* pctxt, SupportedTAList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedTAList");

   RTDIAGSTRM2 (pctxt,"asn1PD_SupportedTAList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SupportedTAItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedTAItem", xx1);

      rtxDListAllocNodeAndData (pctxt, SupportedTAItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SupportedTAItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SupportedTAItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SupportedTAList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAIListForPagingItem_iE_Extensions_element (OSCTXT* pctxt, TAIListForPagingItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForPagingItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForPagingItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TAIListForPagingItem_iE_Extensions (OSCTXT* pctxt, TAIListForPagingItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForPagingItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAIListForPagingItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TAIListForPagingItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAIListForPagingItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAIListForPagingItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForPagingItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TAIListForPagingItem (OSCTXT* pctxt, TAIListForPagingItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TAIListForPagingItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForPagingItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode tAI */
   RTXCTXTPUSHELEMNAME (pctxt, "tAI");

   stat = asn1PD_TAI (pctxt, &pvalue->tAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TAIListForPagingItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForPagingItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAIListForPaging (OSCTXT* pctxt, TAIListForPaging* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAIListForPaging");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForPaging: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAIListForPagingItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAIListForPagingItem", xx1);

      rtxDListAllocNodeAndData (pctxt, TAIListForPagingItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAIListForPagingItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAIListForPagingItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForPaging: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAIListForRestart (OSCTXT* pctxt, TAIListForRestart* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAIListForRestart");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForRestart: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2048), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAI* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAI", xx1);

      rtxDListAllocNodeAndData (pctxt, TAI, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAI (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAI (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForRestart: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TAIListForWarning (OSCTXT* pctxt, TAIListForWarning* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAIListForWarning");

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForWarning: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TAI* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TAI", xx1);

      rtxDListAllocNodeAndData (pctxt, TAI, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAI (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TAI (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TAIListForWarning: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TargeteNB_ID_iE_Extensions_element (OSCTXT* pctxt, TargeteNB_ID_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TargeteNB_ID_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TargeteNB_ID_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TargeteNB_ID_iE_Extensions (OSCTXT* pctxt, TargeteNB_ID_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TargeteNB_ID_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TargeteNB_ID_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TargeteNB_ID_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TargeteNB_ID_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TargeteNB_ID_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TargeteNB_ID_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TargeteNB_ID (OSCTXT* pctxt, TargeteNB_ID* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TargeteNB-ID");

   RTDIAGSTRM2 (pctxt,"asn1PD_TargeteNB_ID: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode globalENB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "globalENB-ID");

   stat = asn1PD_GlobalNgENB_ID (pctxt, &pvalue->globalENB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode selected_EPS_TAI */
   RTXCTXTPUSHELEMNAME (pctxt, "selected-EPS-TAI");

   stat = asn1PD_EPS_TAI (pctxt, &pvalue->selected_EPS_TAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TargeteNB_ID_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TargeteNB_ID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TargetID_choice_Extensions (OSCTXT* pctxt, TargetID_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetID_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetID_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TargetID (OSCTXT* pctxt, TargetID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetID");

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetID: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* targetRANNodeID */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "targetRANNodeID");

         pvalue->u.targetRANNodeID = rtxMemAllocType (pctxt, TargetRANNodeID);

         if (pvalue->u.targetRANNodeID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TargetRANNodeID (pvalue->u.targetRANNodeID);

         stat = asn1PD_TargetRANNodeID (pctxt, pvalue->u.targetRANNodeID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* targeteNB_ID */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "targeteNB-ID");

         pvalue->u.targeteNB_ID = rtxMemAllocType (pctxt, TargeteNB_ID);

         if (pvalue->u.targeteNB_ID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TargeteNB_ID (pvalue->u.targeteNB_ID);

         stat = asn1PD_TargeteNB_ID (pctxt, pvalue->u.targeteNB_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            TargetID_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TargetID_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_TargetID_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetID: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions_element (OSCTXT* pctxt, TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions (OSCTXT* pctxt, TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer (OSCTXT* pctxt, TargetNGRANNode_ToSourceNGRANNode_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TargetNGRANNode-ToSourceNGRANNode-TransparentContainer");

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode rRCContainer */
   RTXCTXTPUSHELEMNAME (pctxt, "rRCContainer");

   stat = asn1PD_RRCContainer (pctxt, &pvalue->rRCContainer);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TargetNGRANNode_ToSourceNGRANNode_TransparentContainer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TNLAssociationItem_iE_Extensions_element (OSCTXT* pctxt, TNLAssociationItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAssociationItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAssociationItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TNLAssociationItem_iE_Extensions (OSCTXT* pctxt, TNLAssociationItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAssociationItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TNLAssociationItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TNLAssociationItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TNLAssociationItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TNLAssociationItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAssociationItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TNLAssociationItem (OSCTXT* pctxt, TNLAssociationItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TNLAssociationItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAssociationItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode tNLAssociationAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "tNLAssociationAddress");

   stat = asn1PD_CPTransportLayerInformation (pctxt, &pvalue->tNLAssociationAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TNLAssociationItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAssociationItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TNLAssociationList (OSCTXT* pctxt, TNLAssociationList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TNLAssociationList");

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAssociationList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TNLAssociationItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TNLAssociationItem", xx1);

      rtxDListAllocNodeAndData (pctxt, TNLAssociationItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TNLAssociationItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TNLAssociationItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TNLAssociationList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TraceActivation_iE_Extensions_element (OSCTXT* pctxt, TraceActivation_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceActivation_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceActivation_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TraceActivation_iE_Extensions (OSCTXT* pctxt, TraceActivation_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceActivation_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TraceActivation_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TraceActivation_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TraceActivation_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TraceActivation_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceActivation_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_TraceActivation (OSCTXT* pctxt, TraceActivation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TraceActivation");

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceActivation: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nGRANTraceID */
   RTXCTXTPUSHELEMNAME (pctxt, "nGRANTraceID");

   stat = asn1PD_NGRANTraceID (pctxt, &pvalue->nGRANTraceID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode interfacesToTrace */
   RTXCTXTPUSHELEMNAME (pctxt, "interfacesToTrace");

   stat = asn1PD_InterfacesToTrace (pctxt, &pvalue->interfacesToTrace);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode traceDepth */
   RTXCTXTPUSHELEMNAME (pctxt, "traceDepth");

   stat = asn1PD_TraceDepth (pctxt, &pvalue->traceDepth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode traceCollectionEntityIPAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "traceCollectionEntityIPAddress");

   stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->traceCollectionEntityIPAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_TraceActivation_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceActivation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEAggregateMaximumBitRate_iE_Extensions_element (OSCTXT* pctxt, UEAggregateMaximumBitRate_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEAggregateMaximumBitRate_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEAggregateMaximumBitRate_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEAggregateMaximumBitRate_iE_Extensions (OSCTXT* pctxt, UEAggregateMaximumBitRate_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEAggregateMaximumBitRate_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEAggregateMaximumBitRate_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEAggregateMaximumBitRate_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEAggregateMaximumBitRate_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEAggregateMaximumBitRate_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEAggregateMaximumBitRate_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UEAggregateMaximumBitRate (OSCTXT* pctxt, UEAggregateMaximumBitRate* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UEAggregateMaximumBitRate");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEAggregateMaximumBitRate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode uEAggregateMaximumBitRateDL */
   RTXCTXTPUSHELEMNAME (pctxt, "uEAggregateMaximumBitRateDL");

   stat = asn1PD_BitRate (pctxt, &pvalue->uEAggregateMaximumBitRateDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uEAggregateMaximumBitRateUL */
   RTXCTXTPUSHELEMNAME (pctxt, "uEAggregateMaximumBitRateUL");

   stat = asn1PD_BitRate (pctxt, &pvalue->uEAggregateMaximumBitRateUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UEAggregateMaximumBitRate_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEAggregateMaximumBitRate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_NGAP_ID_pair_iE_Extensions_element (OSCTXT* pctxt, UE_NGAP_ID_pair_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_NGAP_ID_pair_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_NGAP_ID_pair_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UE_NGAP_ID_pair_iE_Extensions (OSCTXT* pctxt, UE_NGAP_ID_pair_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_NGAP_ID_pair_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UE_NGAP_ID_pair_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UE_NGAP_ID_pair_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UE_NGAP_ID_pair_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UE_NGAP_ID_pair_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_NGAP_ID_pair_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UE_NGAP_ID_pair (OSCTXT* pctxt, UE_NGAP_ID_pair* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UE-NGAP-ID-pair");

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_NGAP_ID_pair: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode aMF_UE_NGAP_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "aMF-UE-NGAP-ID");

   stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->aMF_UE_NGAP_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rAN_UE_NGAP_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAN-UE-NGAP-ID");

   stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->rAN_UE_NGAP_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UE_NGAP_ID_pair_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_NGAP_ID_pair: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UE_NGAP_IDs_choice_Extensions (OSCTXT* pctxt, UE_NGAP_IDs_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_NGAP_IDs_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_NGAP_IDs_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UE_NGAP_IDs (OSCTXT* pctxt, UE_NGAP_IDs* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-NGAP-IDs");

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_NGAP_IDs: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* uE_NGAP_ID_pair */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "uE-NGAP-ID-pair");

         pvalue->u.uE_NGAP_ID_pair = rtxMemAllocType (pctxt, UE_NGAP_ID_pair);

         if (pvalue->u.uE_NGAP_ID_pair == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_NGAP_ID_pair (pvalue->u.uE_NGAP_ID_pair);

         stat = asn1PD_UE_NGAP_ID_pair (pctxt, pvalue->u.uE_NGAP_ID_pair);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* aMF_UE_NGAP_ID */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "aMF-UE-NGAP-ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->u.aMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            UE_NGAP_IDs_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_NGAP_IDs_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_UE_NGAP_IDs_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UE_NGAP_IDs: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEPagingIdentity_choice_Extensions (OSCTXT* pctxt, UEPagingIdentity_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPagingIdentity_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPagingIdentity_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UEPagingIdentity (OSCTXT* pctxt, UEPagingIdentity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UEPagingIdentity");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPagingIdentity: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   {
      OSBOOL b = 0;
      DEC_BIT (pctxt, &b);
      ui = b;
   }
   pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* fiveG_S_TMSI */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "fiveG-S-TMSI");

         pvalue->u.fiveG_S_TMSI = rtxMemAllocType (pctxt, FiveG_S_TMSI);

         if (pvalue->u.fiveG_S_TMSI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FiveG_S_TMSI (pvalue->u.fiveG_S_TMSI);

         stat = asn1PD_FiveG_S_TMSI (pctxt, pvalue->u.fiveG_S_TMSI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            UEPagingIdentity_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEPagingIdentity_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_UEPagingIdentity_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPagingIdentity: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEPresenceInAreaOfInterestItem_iE_Extensions_element (OSCTXT* pctxt, UEPresenceInAreaOfInterestItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPresenceInAreaOfInterestItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPresenceInAreaOfInterestItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEPresenceInAreaOfInterestItem_iE_Extensions (OSCTXT* pctxt, UEPresenceInAreaOfInterestItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPresenceInAreaOfInterestItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEPresenceInAreaOfInterestItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEPresenceInAreaOfInterestItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEPresenceInAreaOfInterestItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEPresenceInAreaOfInterestItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPresenceInAreaOfInterestItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UEPresenceInAreaOfInterestItem (OSCTXT* pctxt, UEPresenceInAreaOfInterestItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UEPresenceInAreaOfInterestItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPresenceInAreaOfInterestItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode locationReportingReferenceID */
   RTXCTXTPUSHELEMNAME (pctxt, "locationReportingReferenceID");

   stat = asn1PD_LocationReportingReferenceID (pctxt, &pvalue->locationReportingReferenceID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uEPresence */
   RTXCTXTPUSHELEMNAME (pctxt, "uEPresence");

   stat = asn1PD_UEPresence (pctxt, &pvalue->uEPresence);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UEPresenceInAreaOfInterestItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPresenceInAreaOfInterestItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEPresenceInAreaOfInterestList (OSCTXT* pctxt, UEPresenceInAreaOfInterestList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UEPresenceInAreaOfInterestList");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPresenceInAreaOfInterestList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEPresenceInAreaOfInterestItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UEPresenceInAreaOfInterestItem", xx1);

      rtxDListAllocNodeAndData (pctxt, UEPresenceInAreaOfInterestItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEPresenceInAreaOfInterestItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEPresenceInAreaOfInterestItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEPresenceInAreaOfInterestList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityForPaging_iE_Extensions_element (OSCTXT* pctxt, UERadioCapabilityForPaging_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityForPaging_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityForPaging_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityForPaging_iE_Extensions (OSCTXT* pctxt, UERadioCapabilityForPaging_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityForPaging_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UERadioCapabilityForPaging_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UERadioCapabilityForPaging_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityForPaging_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UERadioCapabilityForPaging_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityForPaging_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityForPaging (OSCTXT* pctxt, UERadioCapabilityForPaging* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityForPaging");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityForPaging: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode uERadioCapabilityForPagingOfNR */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uERadioCapabilityForPagingOfNR");

      pvalue->m.uERadioCapabilityForPagingOfNRPresent = 1;

      stat = asn1PD_UERadioCapabilityForPagingOfNR (pctxt, &pvalue->uERadioCapabilityForPagingOfNR);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uERadioCapabilityForPagingOfEUTRA */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uERadioCapabilityForPagingOfEUTRA");

      pvalue->m.uERadioCapabilityForPagingOfEUTRAPresent = 1;

      stat = asn1PD_UERadioCapabilityForPagingOfEUTRA (pctxt, &pvalue->uERadioCapabilityForPagingOfEUTRA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UERadioCapabilityForPaging_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityForPaging: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UESecurityCapabilities_iE_Extensions_element (OSCTXT* pctxt, UESecurityCapabilities_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UESecurityCapabilities_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UESecurityCapabilities_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UESecurityCapabilities_iE_Extensions (OSCTXT* pctxt, UESecurityCapabilities_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UESecurityCapabilities_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UESecurityCapabilities_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UESecurityCapabilities_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UESecurityCapabilities_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UESecurityCapabilities_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UESecurityCapabilities_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UESecurityCapabilities (OSCTXT* pctxt, UESecurityCapabilities* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UESecurityCapabilities");

   RTDIAGSTRM2 (pctxt,"asn1PD_UESecurityCapabilities: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nRencryptionAlgorithms */
   RTXCTXTPUSHELEMNAME (pctxt, "nRencryptionAlgorithms");

   stat = asn1PD_NRencryptionAlgorithms (pctxt, &pvalue->nRencryptionAlgorithms);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nRintegrityProtectionAlgorithms */
   RTXCTXTPUSHELEMNAME (pctxt, "nRintegrityProtectionAlgorithms");

   stat = asn1PD_NRintegrityProtectionAlgorithms (pctxt, &pvalue->nRintegrityProtectionAlgorithms);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eUTRAencryptionAlgorithms */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRAencryptionAlgorithms");

   stat = asn1PD_EUTRAencryptionAlgorithms (pctxt, &pvalue->eUTRAencryptionAlgorithms);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eUTRAintegrityProtectionAlgorithms */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRAintegrityProtectionAlgorithms");

   stat = asn1PD_EUTRAintegrityProtectionAlgorithms (pctxt, &pvalue->eUTRAintegrityProtectionAlgorithms);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UESecurityCapabilities_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UESecurityCapabilities: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UnavailableGUAMIItem_iE_Extensions_element (OSCTXT* pctxt, UnavailableGUAMIItem_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UnavailableGUAMIItem_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UnavailableGUAMIItem_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UnavailableGUAMIItem_iE_Extensions (OSCTXT* pctxt, UnavailableGUAMIItem_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UnavailableGUAMIItem_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UnavailableGUAMIItem_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UnavailableGUAMIItem_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnavailableGUAMIItem_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UnavailableGUAMIItem_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UnavailableGUAMIItem_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UnavailableGUAMIItem (OSCTXT* pctxt, UnavailableGUAMIItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "UnavailableGUAMIItem");

   RTDIAGSTRM2 (pctxt,"asn1PD_UnavailableGUAMIItem: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode gUAMI */
   RTXCTXTPUSHELEMNAME (pctxt, "gUAMI");

   stat = asn1PD_GUAMI (pctxt, &pvalue->gUAMI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timerApproachForGUAMIRemoval */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timerApproachForGUAMIRemoval");

      pvalue->m.timerApproachForGUAMIRemovalPresent = 1;

      stat = asn1PD_TimerApproachForGUAMIRemoval (pctxt, &pvalue->timerApproachForGUAMIRemoval);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode backupAMFName */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "backupAMFName");

      pvalue->m.backupAMFNamePresent = 1;

      stat = asn1PD_AMFName (pctxt, &pvalue->backupAMFName);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UnavailableGUAMIItem_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UnavailableGUAMIItem: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UnavailableGUAMIList (OSCTXT* pctxt, UnavailableGUAMIList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UnavailableGUAMIList");

   RTDIAGSTRM2 (pctxt,"asn1PD_UnavailableGUAMIList: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UnavailableGUAMIItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UnavailableGUAMIItem", xx1);

      rtxDListAllocNodeAndData (pctxt, UnavailableGUAMIItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnavailableGUAMIItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UnavailableGUAMIItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UnavailableGUAMIList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UserLocationInformationEUTRA_iE_Extensions_element (OSCTXT* pctxt, UserLocationInformationEUTRA_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationEUTRA_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UserLocationInformationEUTRA_ExtIEs_id_PSCellInformation */
   case ASN1V_id_PSCellInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_UserLocationInformationEUTRA_ExtIEs_id_PSCellInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_UserLocationInformationEUTRA_ExtIEs_id_PSCellInformation");

      pvalue->extensionValue.
         u._UserLocationInformationEUTRA_ExtIEs_id_PSCellInformation
          = rtxMemAllocType (pctxt, NGRAN_CGI);

      if (pvalue->extensionValue.
         u._UserLocationInformationEUTRA_ExtIEs_id_PSCellInformation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGRAN_CGI (pvalue->extensionValue.
         u._UserLocationInformationEUTRA_ExtIEs_id_PSCellInformation);

      stat = asn1PD_NGRAN_CGI (pctxt, pvalue->extensionValue.
         u._UserLocationInformationEUTRA_ExtIEs_id_PSCellInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_UserLocationInformationEUTRA_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationEUTRA_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UserLocationInformationEUTRA_iE_Extensions (OSCTXT* pctxt, UserLocationInformationEUTRA_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationEUTRA_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UserLocationInformationEUTRA_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UserLocationInformationEUTRA_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformationEUTRA_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UserLocationInformationEUTRA_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationEUTRA_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UserLocationInformationEUTRA (OSCTXT* pctxt, UserLocationInformationEUTRA* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UserLocationInformationEUTRA");

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationEUTRA: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode eUTRA_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGI");

   stat = asn1PD_EUTRA_CGI (pctxt, &pvalue->eUTRA_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tAI */
   RTXCTXTPUSHELEMNAME (pctxt, "tAI");

   stat = asn1PD_TAI (pctxt, &pvalue->tAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeStamp */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timeStamp");

      pvalue->m.timeStampPresent = 1;

      stat = asn1PD_TimeStamp (pctxt, &pvalue->timeStamp);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UserLocationInformationEUTRA_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationEUTRA: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UserLocationInformationNR_iE_Extensions_element (OSCTXT* pctxt, UserLocationInformationNR_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationNR_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UserLocationInformationNR_ExtIEs_id_PSCellInformation */
   case ASN1V_id_PSCellInformation:
      pvalue->extensionValue.
         t = T_NGAP_IEs_UserLocationInformationNR_ExtIEs_id_PSCellInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_UserLocationInformationNR_ExtIEs_id_PSCellInformation");

      pvalue->extensionValue.
         u._UserLocationInformationNR_ExtIEs_id_PSCellInformation
          = rtxMemAllocType (pctxt, NGRAN_CGI);

      if (pvalue->extensionValue.
         u._UserLocationInformationNR_ExtIEs_id_PSCellInformation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGRAN_CGI (pvalue->extensionValue.
         u._UserLocationInformationNR_ExtIEs_id_PSCellInformation);

      stat = asn1PD_NGRAN_CGI (pctxt, pvalue->extensionValue.
         u._UserLocationInformationNR_ExtIEs_id_PSCellInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->extensionValue.t = T_NGAP_IEs_UserLocationInformationNR_ExtIEs_UNDEF_;
      pvalue->extensionValue.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->extensionValue.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->extensionValue.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->extensionValue.u.extElem1->numocts = openTypeLen;
      pvalue->extensionValue.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationNR_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UserLocationInformationNR_iE_Extensions (OSCTXT* pctxt, UserLocationInformationNR_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationNR_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UserLocationInformationNR_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UserLocationInformationNR_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformationNR_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UserLocationInformationNR_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationNR_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UserLocationInformationNR (OSCTXT* pctxt, UserLocationInformationNR* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UserLocationInformationNR");

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationNR: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode nR_CGI */
   RTXCTXTPUSHELEMNAME (pctxt, "nR-CGI");

   stat = asn1PD_NR_CGI (pctxt, &pvalue->nR_CGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tAI */
   RTXCTXTPUSHELEMNAME (pctxt, "tAI");

   stat = asn1PD_TAI (pctxt, &pvalue->tAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode timeStamp */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "timeStamp");

      pvalue->m.timeStampPresent = 1;

      stat = asn1PD_TimeStamp (pctxt, &pvalue->timeStamp);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UserLocationInformationNR_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationNR: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UserLocationInformationN3IWF_iE_Extensions_element (OSCTXT* pctxt, UserLocationInformationN3IWF_iE_Extensions_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationN3IWF_iE_Extensions_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationN3IWF_iE_Extensions_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UserLocationInformationN3IWF_iE_Extensions (OSCTXT* pctxt, UserLocationInformationN3IWF_iE_Extensions* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationN3IWF_iE_Extensions: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UserLocationInformationN3IWF_iE_Extensions_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UserLocationInformationN3IWF_iE_Extensions_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformationN3IWF_iE_Extensions_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UserLocationInformationN3IWF_iE_Extensions_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationN3IWF_iE_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UserLocationInformationN3IWF (OSCTXT* pctxt, UserLocationInformationN3IWF* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UserLocationInformationN3IWF");

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationN3IWF: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   PU_NEWFIELD (pctxt, "optional bits");

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   PU_SETBITCOUNT (pctxt);

   /* decode root elements */
   /* decode iPAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "iPAddress");

   stat = asn1PD_TransportLayerAddress (pctxt, &pvalue->iPAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode portNumber */
   RTXCTXTPUSHELEMNAME (pctxt, "portNumber");

   stat = asn1PD_PortNumber (pctxt, &pvalue->portNumber);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_UserLocationInformationN3IWF_iE_Extensions (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformationN3IWF: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UserLocationInformation_choice_Extensions (OSCTXT* pctxt, UserLocationInformation_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformation_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformation_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_UserLocationInformation (OSCTXT* pctxt, UserLocationInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UserLocationInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformation: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* userLocationInformationEUTRA */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "userLocationInformationEUTRA");

         pvalue->u.userLocationInformationEUTRA = rtxMemAllocType (pctxt, 
            UserLocationInformationEUTRA);

         if (pvalue->u.userLocationInformationEUTRA == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformationEUTRA (pvalue->u.userLocationInformationEUTRA);

         stat = asn1PD_UserLocationInformationEUTRA (pctxt, pvalue->u.userLocationInformationEUTRA);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* userLocationInformationNR */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "userLocationInformationNR");

         pvalue->u.userLocationInformationNR = rtxMemAllocType (pctxt, 
            UserLocationInformationNR);

         if (pvalue->u.userLocationInformationNR == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformationNR (pvalue->u.userLocationInformationNR);

         stat = asn1PD_UserLocationInformationNR (pctxt, pvalue->u.userLocationInformationNR);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* userLocationInformationN3IWF */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "userLocationInformationN3IWF");

         pvalue->u.userLocationInformationN3IWF = rtxMemAllocType (pctxt, 
            UserLocationInformationN3IWF);

         if (pvalue->u.userLocationInformationN3IWF == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformationN3IWF (pvalue->u.userLocationInformationN3IWF);

         stat = asn1PD_UserLocationInformationN3IWF (pctxt, pvalue->u.userLocationInformationN3IWF);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            UserLocationInformation_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_UserLocationInformation_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UserLocationInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_WarningAreaList_choice_Extensions (OSCTXT* pctxt, WarningAreaList_choice_Extensions* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningAreaList_choice_Extensions: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningAreaList_choice_Extensions: end\n");

   return (stat);
}

EXTERN int asn1PD_WarningAreaList (OSCTXT* pctxt, WarningAreaList* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "WarningAreaList");

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningAreaList: start\n");

   RTXCTXTPUSHELEMNAME (pctxt, "t");
   PU_NEWFIELD (pctxt, "<choice-index>");

   stat = rtxDecBits (pctxt, &ui, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   PU_SETBITCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   switch (ui) {
      /* eUTRA_CGIListForWarning */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "eUTRA-CGIListForWarning");

         pvalue->u.eUTRA_CGIListForWarning = rtxMemAllocType (pctxt, 
            EUTRA_CGIListForWarning);

         if (pvalue->u.eUTRA_CGIListForWarning == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EUTRA_CGIListForWarning (pvalue->u.eUTRA_CGIListForWarning);

         stat = asn1PD_EUTRA_CGIListForWarning (pctxt, pvalue->u.eUTRA_CGIListForWarning);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* nR_CGIListForWarning */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "nR-CGIListForWarning");

         pvalue->u.nR_CGIListForWarning = rtxMemAllocType (pctxt, 
            NR_CGIListForWarning);

         if (pvalue->u.nR_CGIListForWarning == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NR_CGIListForWarning (pvalue->u.nR_CGIListForWarning);

         stat = asn1PD_NR_CGIListForWarning (pctxt, pvalue->u.nR_CGIListForWarning);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* tAIListForWarning */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "tAIListForWarning");

         pvalue->u.tAIListForWarning = rtxMemAllocType (pctxt, 
            TAIListForWarning);

         if (pvalue->u.tAIListForWarning == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TAIListForWarning (pvalue->u.tAIListForWarning);

         stat = asn1PD_TAIListForWarning (pctxt, pvalue->u.tAIListForWarning);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* emergencyAreaIDList */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "emergencyAreaIDList");

         pvalue->u.emergencyAreaIDList = rtxMemAllocType (pctxt, 
            EmergencyAreaIDList);

         if (pvalue->u.emergencyAreaIDList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EmergencyAreaIDList (pvalue->u.emergencyAreaIDList);

         stat = asn1PD_EmergencyAreaIDList (pctxt, pvalue->u.emergencyAreaIDList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* choice_Extensions */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "choice-Extensions");

         pvalue->u.choice_Extensions = rtxMemAllocType (pctxt, 
            WarningAreaList_choice_Extensions);

         if (pvalue->u.choice_Extensions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_WarningAreaList_choice_Extensions (pvalue->u.choice_Extensions);

         stat = asn1PD_WarningAreaList_choice_Extensions (pctxt, pvalue->u.choice_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WarningAreaList: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

