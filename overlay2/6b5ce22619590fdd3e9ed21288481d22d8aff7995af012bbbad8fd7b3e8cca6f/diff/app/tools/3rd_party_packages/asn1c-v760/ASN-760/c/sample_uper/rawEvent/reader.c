/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.6.A, Date: 30-Sep-2021.
 */
#include "rd.h"
#include "rtsrc/asn1CRawEvtHndlr.h"
#include "rtsrc/rtPrint.h"
#include "rtsrc/rtBCD.h"
#include "rtxsrc/rtxCommon.h"

#include <stdio.h>
#include <stdlib.h>

typedef struct {
   OSSIZE indent;
} EvtTrack;

static void indent(OSSIZE cnt)
{
   for(size_t i = 0; i < cnt; i++) {
      printf("   ");
   }
}

ASN1RawEventResp compEvt (OSCTXT* pctxt, OSSIZE componentID,
         OSBOOL nestedValues)
{
   /* Report every event we receive */
   EvtTrack* ptrack = (EvtTrack*)pctxt->pUserData;
   indent(ptrack->indent);
   printf("Component " OSSIZEFMT "\n", componentID);
   
   if (componentID == RAWID_RAWEVENTS_PDU_RECORD) {
      /* Decode the Record ourselves, and print it.  Then tell the
         parser we've consumed it. */
      Record rec;
      asn1PD_Record(pctxt, &rec);
      printf("The Record is:\n");
      asn1Print_Record("record", &rec);
      
      return ASN1RER_CONSUMED;
   }
   else if (componentID == RAWID_RAWEVENTS_PDU_VALUES ||
            componentID == RAWID_RAWEVENTS__SEQOFVALUETABLE_ELEMENT ||
            componentID == RAWID_RAWEVENTS_VALUETABLE_DATA) {
      /* We want to get events for the above elements */
      ptrack->indent++;
      return ASN1RER_PARSE;
   }
   else return ASN1RER_QUIET_PARSE;
}

void endCompEvt (OSCTXT* pctxt, OSSIZE componentID)
{
   EvtTrack* ptrack = (EvtTrack*)pctxt->pUserData;
   ptrack->indent--;   
}

ASN1RawEventResp actualType (OSCTXT* pctxt, OSSIZE actualTypeID, OSSIZE len)
{
   EvtTrack* ptrack = (EvtTrack*)pctxt->pUserData;
   indent(ptrack->indent);
   
   /* All branches here return ASN1RER_CONSUMED or ASN1RER_QUIET_PARSE, so
      we won't receive an end component event.  Decrement indent here.
   */
   ptrack->indent--;
   
   if (actualTypeID == 0) {
      printf("Actual type event for unknown type"
         " having length of " OSSIZEFMT "\n", len);
      return ASN1RER_QUIET_PARSE;
   }
   else if (actualTypeID == RAWID_RAWEVENTS_VALUETABLE_DATA_T_RECORD)
   {
      /* Open type's actual type is Record.  Decode it ourselves, and print it.
         Then tell the parser we've consumed it. */
      Record rec;
      asn1PD_Record(pctxt, &rec);
      printf("Open type is Record:\n");
      asn1Print_Record("record", &rec);
      
      return ASN1RER_CONSUMED;
   }   
   else {
      printf("Actual type event for " OSSIZEFMT 
         " having length of " OSSIZEFMT "\n", actualTypeID, len);
      return ASN1RER_QUIET_PARSE;
   }
}



int main (int argc, char** argv)
{
   OSCTXT      ctxt;
   OSOCTET*    pMsgBuf;
   OSBOOL      aligned = TRUE;
   const char* filename = "message.per";
   OSBOOL      trace = TRUE, verbose = FALSE;
   int         i, stat;
   OSSIZE      len;
   Asn1CRawEventHandler handler;
   EvtTrack    track;


   handler.component = compEvt;
   handler.endComponent = endCompEvt;
   handler.actualType = actualType;
   
   track.indent = 0;
   
   /* Process command line arguments */
   if (argc > 1) {
      for (i = 1; i < argc; i++) {
         if (!strcmp (argv[i], "-v")) verbose = TRUE;
         else if (!strcmp (argv[i], "-i")) filename = argv[++i];
         else if (!strcmp (argv[i], "-a")) aligned = TRUE;
         else if (!strcmp (argv[i], "-u")) {
            aligned = FALSE;
            filename = "message.uper";
         }
         else if (!strcmp (argv[i], "-notrace")) trace = FALSE;
         else {
            printf ("usage: reader [-v] [-i <filename>] [-a|-u] [-notrace]\n");
            printf ("   -v  verbose mode: print trace info\n");
            printf ("   -i <filename>  read encoded msg from <filename>\n");
            printf ("   -a  use PER aligned encoding\n");
            printf ("   -u  use PER unaligned encoding\n");
            printf ("   -notrace  do not display trace info\n");
            return 1;
         }
      }
   }

   /* Initialize context structure */  
   stat = rtInitContext (&ctxt);
   if (stat != 0) {
      rtxErrPrint (&ctxt);
      return stat;
   }
   rtxSetDiag (&ctxt, verbose);

   /* Read input file into a memory buffer */
   if (0 != rtxFileReadBinary (&ctxt, filename, &pMsgBuf, &len)) {
      printf ("Error opening %s for read access\n", filename);
      return -1;
   }

   pu_setBuffer (&ctxt, pMsgBuf, len, aligned);
   pu_setTrace (&ctxt, trace);   

   rtAddRawEventHandler(&ctxt, &handler);
   ctxt.pUserData = &track;
   
   /* Call compiler generated parse function */
   stat = asn1PP_PDU (&ctxt, ASN1RER_PARSE);
   if (stat != 0) {
      printf ("decode of data failed\n");
      rtxErrPrint (&ctxt);
      rtFreeContext (&ctxt);
      return -1;
   }

      rtFreeContext (&ctxt);

   return 0;
}
