/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.6.0, Date: 15-Feb-2022.
 */
#include "NGAP-PDU-Contents.h"
#include "NGAP-Constants.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PD__UplinkNASTransport_IEs_Value (OSCTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkNASTransport_IEs_Value *pvalue = (_UplinkNASTransport_IEs_Value*) pvalue_;
   RTDIAGSTRM2 (pctxt,"asn1PD__UplinkNASTransport_IEs_Value: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD__UplinkNASTransport_IEs_Value: end\n");

   return (stat);
}

EXTERN int asn1PD__UplinkNASTransport_IEs_Value_1 (OSCTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkNASTransport_IEs_Value_1 *pvalue = (_UplinkNASTransport_IEs_Value_1*) pvalue_;
   RTDIAGSTRM2 (pctxt,"asn1PD__UplinkNASTransport_IEs_Value_1: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD__UplinkNASTransport_IEs_Value_1: end\n");

   return (stat);
}

EXTERN int asn1PD__UplinkNASTransport_IEs_Value_2 (OSCTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _UplinkNASTransport_IEs_Value_2 *pvalue = (_UplinkNASTransport_IEs_Value_2*) pvalue_;
   RTDIAGSTRM2 (pctxt,"asn1PD__UplinkNASTransport_IEs_Value_2: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD__UplinkNASTransport_IEs_Value_2: end\n");

   return (stat);
}

EXTERN int asn1PD__RerouteNASRequest_IEs_Value (OSCTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RerouteNASRequest_IEs_Value *pvalue = (_RerouteNASRequest_IEs_Value*) pvalue_;
   RTDIAGSTRM2 (pctxt,"asn1PD__RerouteNASRequest_IEs_Value: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD__RerouteNASRequest_IEs_Value: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupRequest_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceSetupRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceSetupRequestIEs_id_RANPagingPriority */
      case ASN1V_id_RANPagingPriority:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_RANPagingPriority;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_RANPagingPriority");

         stat = asn1PD_RANPagingPriority (pctxt, &pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_RANPagingPriority);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceSetupRequestIEs_id_NAS_PDU */
      case ASN1V_id_NAS_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_NAS_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_NAS_PDU");

         pvalue->value.u._PDUSessionResourceSetupRequestIEs_id_NAS_PDU
             = rtxMemAllocType (pctxt, NAS_PDU);

         if (pvalue->value.u._PDUSessionResourceSetupRequestIEs_id_NAS_PDU
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NAS_PDU (pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_NAS_PDU);

         stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_NAS_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq */
      case ASN1V_id_PDUSessionResourceSetupListSUReq:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq");

         pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq
             = rtxMemAllocType (pctxt, PDUSessionResourceSetupListSUReq);

         if (pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceSetupListSUReq (pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq
            );

         stat = asn1PD_PDUSessionResourceSetupListSUReq (pctxt, pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate */
      case ASN1V_id_UEAggregateMaximumBitRate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate");

         pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate
             = rtxMemAllocType (pctxt, UEAggregateMaximumBitRate);

         if (pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEAggregateMaximumBitRate ((UEAggregateMaximumBitRate*)pvalue
            ->value.
            u._PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate
            );

         stat = asn1PD_UEAggregateMaximumBitRate (pctxt, 
            (UEAggregateMaximumBitRate*)pvalue->value.
            u._PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupRequest_protocolIEs (OSCTXT* pctxt, PDUSessionResourceSetupRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupRequest (OSCTXT* pctxt, PDUSessionResourceSetupRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceSetupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupResponse_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceSetupResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes */
      case ASN1V_id_PDUSessionResourceSetupListSURes:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes");

         pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes
             = rtxMemAllocType (pctxt, PDUSessionResourceSetupListSURes);

         if (pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceSetupListSURes (pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes
            );

         stat = asn1PD_PDUSessionResourceSetupListSURes (pctxt, pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes */
      case ASN1V_id_PDUSessionResourceFailedToSetupListSURes:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes");

         pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes
             = rtxMemAllocType (pctxt, 
            PDUSessionResourceFailedToSetupListSURes);

         if (pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceFailedToSetupListSURes (pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes
            );

         stat = asn1PD_PDUSessionResourceFailedToSetupListSURes (pctxt, pvalue
            ->value.
            u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.
            u._PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupResponse_protocolIEs (OSCTXT* pctxt, PDUSessionResourceSetupResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupResponse (OSCTXT* pctxt, PDUSessionResourceSetupResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceSetupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseCommand_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceReleaseCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority */
      case ASN1V_id_RANPagingPriority:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority");

         stat = asn1PD_RANPagingPriority (pctxt, &pvalue->value.
            u._PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceReleaseCommandIEs_id_NAS_PDU */
      case ASN1V_id_NAS_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_NAS_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_NAS_PDU");

         pvalue->value.u._PDUSessionResourceReleaseCommandIEs_id_NAS_PDU
             = rtxMemAllocType (pctxt, NAS_PDU);

         if (pvalue->value.u._PDUSessionResourceReleaseCommandIEs_id_NAS_PDU
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NAS_PDU (pvalue->value.
            u._PDUSessionResourceReleaseCommandIEs_id_NAS_PDU);

         stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
            u._PDUSessionResourceReleaseCommandIEs_id_NAS_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd */
      case ASN1V_id_PDUSessionResourceToReleaseListRelCmd:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd");

         pvalue->value.
            u._PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd
             = rtxMemAllocType (pctxt, PDUSessionResourceToReleaseListRelCmd);

         if (pvalue->value.
            u._PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceToReleaseListRelCmd (pvalue->value.
            u._PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd
            );

         stat = asn1PD_PDUSessionResourceToReleaseListRelCmd (pctxt, pvalue->
            value.
            u._PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseCommand_protocolIEs (OSCTXT* pctxt, PDUSessionResourceReleaseCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleaseCommand_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleaseCommand_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleaseCommand_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleaseCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseCommand (OSCTXT* pctxt, PDUSessionResourceReleaseCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleaseCommand");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceReleaseCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseResponse_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceReleaseResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes */
      case ASN1V_id_PDUSessionResourceReleasedListRelRes:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes");

         pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes
             = rtxMemAllocType (pctxt, PDUSessionResourceReleasedListRelRes);

         if (pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceReleasedListRelRes (pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes
            );

         stat = asn1PD_PDUSessionResourceReleasedListRelRes (pctxt, pvalue->
            value.
            u._PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation");

         pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.
            u._PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation
            );

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.
            u._PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseResponse_protocolIEs (OSCTXT* pctxt, PDUSessionResourceReleaseResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleaseResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleaseResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleaseResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleaseResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseResponse (OSCTXT* pctxt, PDUSessionResourceReleaseResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleaseResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceReleaseResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyRequest_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyRequestIEs_id_RANPagingPriority */
      case ASN1V_id_RANPagingPriority:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_RANPagingPriority;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_RANPagingPriority");

         stat = asn1PD_RANPagingPriority (pctxt, &pvalue->value.
            u._PDUSessionResourceModifyRequestIEs_id_RANPagingPriority);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq */
      case ASN1V_id_PDUSessionResourceModifyListModReq:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq");

         pvalue->value.
            u._PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq
             = rtxMemAllocType (pctxt, PDUSessionResourceModifyListModReq);

         if (pvalue->value.
            u._PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceModifyListModReq (pvalue->value.
            u._PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq
            );

         stat = asn1PD_PDUSessionResourceModifyListModReq (pctxt, pvalue->value
            .
            u._PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyRequest_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyRequest (OSCTXT* pctxt, PDUSessionResourceModifyRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceModifyRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyResponse_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes */
      case ASN1V_id_PDUSessionResourceModifyListModRes:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes");

         pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes
             = rtxMemAllocType (pctxt, PDUSessionResourceModifyListModRes);

         if (pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceModifyListModRes (pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes
            );

         stat = asn1PD_PDUSessionResourceModifyListModRes (pctxt, pvalue->value
            .
            u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes */
      case ASN1V_id_PDUSessionResourceFailedToModifyListModRes:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes");

         pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes
             = rtxMemAllocType (pctxt, 
            PDUSessionResourceFailedToModifyListModRes);

         if (pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceFailedToModifyListModRes (pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes
            );

         stat = asn1PD_PDUSessionResourceFailedToModifyListModRes (pctxt, 
            pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyResponseIEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_UserLocationInformation");

         pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.
            u._PDUSessionResourceModifyResponseIEs_id_UserLocationInformation
            );

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_UserLocationInformation
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.
            u._PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyResponse_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyResponse (OSCTXT* pctxt, PDUSessionResourceModifyResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceModifyResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotify_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceNotify_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList */
      case ASN1V_id_PDUSessionResourceNotifyList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList");

         pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList
             = rtxMemAllocType (pctxt, PDUSessionResourceNotifyList);

         if (pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceNotifyList (pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList);

         stat = asn1PD_PDUSessionResourceNotifyList (pctxt, pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot */
      case ASN1V_id_PDUSessionResourceReleasedListNot:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot");

         pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot
             = rtxMemAllocType (pctxt, PDUSessionResourceReleasedListNot);

         if (pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceReleasedListNot (pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot
            );

         stat = asn1PD_PDUSessionResourceReleasedListNot (pctxt, pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceNotifyIEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_UserLocationInformation");

         pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_UserLocationInformation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.u._PDUSessionResourceNotifyIEs_id_UserLocationInformation);

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._PDUSessionResourceNotifyIEs_id_UserLocationInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotify_protocolIEs (OSCTXT* pctxt, PDUSessionResourceNotify_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceNotify_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceNotify_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceNotify_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceNotify_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotify (OSCTXT* pctxt, PDUSessionResourceNotify* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceNotify");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceNotify_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndication_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd */
      case ASN1V_id_PDUSessionResourceModifyListModInd:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd");

         pvalue->value.
            u._PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd
             = rtxMemAllocType (pctxt, PDUSessionResourceModifyListModInd);

         if (pvalue->value.
            u._PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceModifyListModInd (pvalue->value.
            u._PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd
            );

         stat = asn1PD_PDUSessionResourceModifyListModInd (pctxt, pvalue->value
            .
            u._PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyIndicationIEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationIEs_id_UserLocationInformation");

         pvalue->value.
            u._PDUSessionResourceModifyIndicationIEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.
            u._PDUSessionResourceModifyIndicationIEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.
            u._PDUSessionResourceModifyIndicationIEs_id_UserLocationInformation
            );

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._PDUSessionResourceModifyIndicationIEs_id_UserLocationInformation
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndication_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndication (OSCTXT* pctxt, PDUSessionResourceModifyIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceModifyIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyConfirm_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyConfirm_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm */
      case ASN1V_id_PDUSessionResourceModifyListModCfm:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm");

         pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm
             = rtxMemAllocType (pctxt, PDUSessionResourceModifyListModCfm);

         if (pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceModifyListModCfm (pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm
            );

         stat = asn1PD_PDUSessionResourceModifyListModCfm (pctxt, pvalue->value
            .
            u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm */
      case ASN1V_id_PDUSessionResourceFailedToModifyListModCfm:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm");

         pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm
             = rtxMemAllocType (pctxt, 
            PDUSessionResourceFailedToModifyListModCfm);

         if (pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceFailedToModifyListModCfm (pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm
            );

         stat = asn1PD_PDUSessionResourceFailedToModifyListModCfm (pctxt, 
            pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.
            u._PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyConfirm_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyConfirm_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyConfirm_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyConfirm_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyConfirm_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyConfirm_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyConfirm (OSCTXT* pctxt, PDUSessionResourceModifyConfirm* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyConfirm");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceModifyConfirm_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupRequest_protocolIEs_element (OSCTXT* pctxt, InitialContextSetupRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_OldAMF */
      case ASN1V_id_OldAMF:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_OldAMF;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_OldAMF");

         stat = asn1PD_AMFName (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_OldAMF);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate */
      case ASN1V_id_UEAggregateMaximumBitRate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate
             = rtxMemAllocType (pctxt, UEAggregateMaximumBitRate);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEAggregateMaximumBitRate ((UEAggregateMaximumBitRate*)pvalue
            ->value.
            u._InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate);

         stat = asn1PD_UEAggregateMaximumBitRate (pctxt, 
            (UEAggregateMaximumBitRate*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive */
      case ASN1V_id_CoreNetworkAssistanceInformationForInactive:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive
             = rtxMemAllocType (pctxt, 
            CoreNetworkAssistanceInformationForInactive);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CoreNetworkAssistanceInformationForInactive (
            (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive
            );

         stat = asn1PD_CoreNetworkAssistanceInformationForInactive (pctxt, 
            (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_GUAMI */
      case ASN1V_id_GUAMI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_GUAMI;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_GUAMI");

         pvalue->value.u._InitialContextSetupRequestIEs_id_GUAMI
             = rtxMemAllocType (pctxt, GUAMI);

         if (pvalue->value.u._InitialContextSetupRequestIEs_id_GUAMI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GUAMI ((GUAMI*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_GUAMI);

         stat = asn1PD_GUAMI (pctxt, (GUAMI*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_GUAMI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq */
      case ASN1V_id_PDUSessionResourceSetupListCxtReq:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq
             = rtxMemAllocType (pctxt, PDUSessionResourceSetupListCxtReq);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceSetupListCxtReq (pvalue->value.
            u._InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq
            );

         stat = asn1PD_PDUSessionResourceSetupListCxtReq (pctxt, pvalue->value.
            u._InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_AllowedNSSAI */
      case ASN1V_id_AllowedNSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_AllowedNSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_AllowedNSSAI");

         pvalue->value.u._InitialContextSetupRequestIEs_id_AllowedNSSAI
             = rtxMemAllocType (pctxt, AllowedNSSAI);

         if (pvalue->value.u._InitialContextSetupRequestIEs_id_AllowedNSSAI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AllowedNSSAI (pvalue->value.
            u._InitialContextSetupRequestIEs_id_AllowedNSSAI);

         stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
            u._InitialContextSetupRequestIEs_id_AllowedNSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_UESecurityCapabilities */
      case ASN1V_id_UESecurityCapabilities:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UESecurityCapabilities;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UESecurityCapabilities");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_UESecurityCapabilities
             = rtxMemAllocType (pctxt, UESecurityCapabilities);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_UESecurityCapabilities
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UESecurityCapabilities ((UESecurityCapabilities*)pvalue->
            value.u._InitialContextSetupRequestIEs_id_UESecurityCapabilities);

         stat = asn1PD_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)
            pvalue->value.
            u._InitialContextSetupRequestIEs_id_UESecurityCapabilities);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_SecurityKey */
      case ASN1V_id_SecurityKey:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_SecurityKey;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_SecurityKey");

         pvalue->value.u._InitialContextSetupRequestIEs_id_SecurityKey
             = rtxMemAllocTypeZ (pctxt, SecurityKey);

         if (pvalue->value.u._InitialContextSetupRequestIEs_id_SecurityKey
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SecurityKey (pctxt, (SecurityKey*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_SecurityKey);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_TraceActivation */
      case ASN1V_id_TraceActivation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_TraceActivation;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_TraceActivation");

         pvalue->value.u._InitialContextSetupRequestIEs_id_TraceActivation
             = rtxMemAllocType (pctxt, TraceActivation);

         if (pvalue->value.u._InitialContextSetupRequestIEs_id_TraceActivation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TraceActivation ((TraceActivation*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_TraceActivation);

         stat = asn1PD_TraceActivation (pctxt, (TraceActivation*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_TraceActivation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_MobilityRestrictionList */
      case ASN1V_id_MobilityRestrictionList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_MobilityRestrictionList;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_MobilityRestrictionList");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_MobilityRestrictionList
             = rtxMemAllocType (pctxt, MobilityRestrictionList);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_MobilityRestrictionList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MobilityRestrictionList ((MobilityRestrictionList*)pvalue->
            value.u._InitialContextSetupRequestIEs_id_MobilityRestrictionList
            );

         stat = asn1PD_MobilityRestrictionList (pctxt, 
            (MobilityRestrictionList*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_MobilityRestrictionList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_UERadioCapability */
      case ASN1V_id_UERadioCapability:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UERadioCapability;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UERadioCapability");

         pvalue->value.u._InitialContextSetupRequestIEs_id_UERadioCapability
             = rtxMemAllocType (pctxt, UERadioCapability);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_UERadioCapability == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapability (pvalue->value.
            u._InitialContextSetupRequestIEs_id_UERadioCapability);

         stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
            u._InitialContextSetupRequestIEs_id_UERadioCapability);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_IndexToRFSP */
      case ASN1V_id_IndexToRFSP:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_IndexToRFSP;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_IndexToRFSP");

         stat = asn1PD_IndexToRFSP (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_IndexToRFSP);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_MaskedIMEISV */
      case ASN1V_id_MaskedIMEISV:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_MaskedIMEISV;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_MaskedIMEISV");

         pvalue->value.u._InitialContextSetupRequestIEs_id_MaskedIMEISV
             = rtxMemAllocTypeZ (pctxt, MaskedIMEISV);

         if (pvalue->value.u._InitialContextSetupRequestIEs_id_MaskedIMEISV
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MaskedIMEISV (pctxt, (MaskedIMEISV*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_MaskedIMEISV);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_NAS_PDU */
      case ASN1V_id_NAS_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_NAS_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_NAS_PDU");

         pvalue->value.u._InitialContextSetupRequestIEs_id_NAS_PDU
             = rtxMemAllocType (pctxt, NAS_PDU);

         if (pvalue->value.u._InitialContextSetupRequestIEs_id_NAS_PDU
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NAS_PDU (pvalue->value.
            u._InitialContextSetupRequestIEs_id_NAS_PDU);

         stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
            u._InitialContextSetupRequestIEs_id_NAS_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator */
      case ASN1V_id_EmergencyFallbackIndicator:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator
             = rtxMemAllocType (pctxt, EmergencyFallbackIndicator);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EmergencyFallbackIndicator ((EmergencyFallbackIndicator*)
            pvalue->value.
            u._InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator);

         stat = asn1PD_EmergencyFallbackIndicator (pctxt, 
            (EmergencyFallbackIndicator*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest */
      case ASN1V_id_RRCInactiveTransitionReportRequest:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest");

         stat = asn1PD_RRCInactiveTransitionReportRequest (pctxt, &pvalue->
            value.
            u._InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging */
      case ASN1V_id_UERadioCapabilityForPaging:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging
             = rtxMemAllocType (pctxt, UERadioCapabilityForPaging);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityForPaging ((UERadioCapabilityForPaging*)
            pvalue->value.
            u._InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging);

         stat = asn1PD_UERadioCapabilityForPaging (pctxt, 
            (UERadioCapabilityForPaging*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_RedirectionVoiceFallback */
      case ASN1V_id_RedirectionVoiceFallback:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_RedirectionVoiceFallback;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_RedirectionVoiceFallback");

         stat = asn1PD_RedirectionVoiceFallback (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_RedirectionVoiceFallback);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_LocationReportingRequestType */
      case ASN1V_id_LocationReportingRequestType:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_LocationReportingRequestType;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_LocationReportingRequestType");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_LocationReportingRequestType
             = rtxMemAllocType (pctxt, LocationReportingRequestType);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_LocationReportingRequestType
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LocationReportingRequestType ((LocationReportingRequestType*)
            pvalue->value.
            u._InitialContextSetupRequestIEs_id_LocationReportingRequestType);

         stat = asn1PD_LocationReportingRequestType (pctxt, 
            (LocationReportingRequestType*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_LocationReportingRequestType);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_CNAssistedRANTuning */
      case ASN1V_id_CNAssistedRANTuning:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_CNAssistedRANTuning;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_CNAssistedRANTuning");

         pvalue->value.u._InitialContextSetupRequestIEs_id_CNAssistedRANTuning
             = rtxMemAllocType (pctxt, CNAssistedRANTuning);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_CNAssistedRANTuning == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CNAssistedRANTuning ((CNAssistedRANTuning*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_CNAssistedRANTuning);

         stat = asn1PD_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue
            ->value.u._InitialContextSetupRequestIEs_id_CNAssistedRANTuning);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_SRVCCOperationPossible */
      case ASN1V_id_SRVCCOperationPossible:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_SRVCCOperationPossible;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_SRVCCOperationPossible");

         stat = asn1PD_SRVCCOperationPossible (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_SRVCCOperationPossible);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_IAB_Authorized */
      case ASN1V_id_IAB_Authorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_IAB_Authorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_IAB_Authorized");

         stat = asn1PD_IAB_Authorized (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_IAB_Authorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_Enhanced_CoverageRestriction */
      case ASN1V_id_Enhanced_CoverageRestriction:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_Enhanced_CoverageRestriction;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_Enhanced_CoverageRestriction");

         stat = asn1PD_Enhanced_CoverageRestriction (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_Enhanced_CoverageRestriction);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_Extended_ConnectedTime */
      case ASN1V_id_Extended_ConnectedTime:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_Extended_ConnectedTime;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_Extended_ConnectedTime");

         stat = asn1PD_Extended_ConnectedTime (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_Extended_ConnectedTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_UE_DifferentiationInfo */
      case ASN1V_id_UE_DifferentiationInfo:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UE_DifferentiationInfo;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UE_DifferentiationInfo");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_UE_DifferentiationInfo
             = rtxMemAllocType (pctxt, UE_DifferentiationInfo);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_UE_DifferentiationInfo
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_DifferentiationInfo ((UE_DifferentiationInfo*)pvalue->
            value.u._InitialContextSetupRequestIEs_id_UE_DifferentiationInfo);

         stat = asn1PD_UE_DifferentiationInfo (pctxt, (UE_DifferentiationInfo*)
            pvalue->value.
            u._InitialContextSetupRequestIEs_id_UE_DifferentiationInfo);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_NRV2XServicesAuthorized */
      case ASN1V_id_NRV2XServicesAuthorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_NRV2XServicesAuthorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_NRV2XServicesAuthorized");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_NRV2XServicesAuthorized
             = rtxMemAllocType (pctxt, NRV2XServicesAuthorized);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_NRV2XServicesAuthorized
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRV2XServicesAuthorized ((NRV2XServicesAuthorized*)pvalue->
            value.u._InitialContextSetupRequestIEs_id_NRV2XServicesAuthorized
            );

         stat = asn1PD_NRV2XServicesAuthorized (pctxt, 
            (NRV2XServicesAuthorized*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_NRV2XServicesAuthorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_LTEV2XServicesAuthorized */
      case ASN1V_id_LTEV2XServicesAuthorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_LTEV2XServicesAuthorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_LTEV2XServicesAuthorized");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_LTEV2XServicesAuthorized
             = rtxMemAllocType (pctxt, LTEV2XServicesAuthorized);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_LTEV2XServicesAuthorized
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LTEV2XServicesAuthorized ((LTEV2XServicesAuthorized*)pvalue->
            value.u._InitialContextSetupRequestIEs_id_LTEV2XServicesAuthorized
            );

         stat = asn1PD_LTEV2XServicesAuthorized (pctxt, 
            (LTEV2XServicesAuthorized*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_LTEV2XServicesAuthorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_NRUESidelinkAggregateMaximumBitrate */
      case ASN1V_id_NRUESidelinkAggregateMaximumBitrate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_NRUESidelinkAggregateMaximumBitrate;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_NRUESidelinkAggregateMaximumBitrate");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_NRUESidelinkAggregateMaximumBitrate
             = rtxMemAllocType (pctxt, NRUESidelinkAggregateMaximumBitrate);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_NRUESidelinkAggregateMaximumBitrate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRUESidelinkAggregateMaximumBitrate (
            (NRUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_NRUESidelinkAggregateMaximumBitrate
            );

         stat = asn1PD_NRUESidelinkAggregateMaximumBitrate (pctxt, 
            (NRUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_NRUESidelinkAggregateMaximumBitrate
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate */
      case ASN1V_id_LTEUESidelinkAggregateMaximumBitrate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate
             = rtxMemAllocType (pctxt, LTEUESidelinkAggregateMaximumBitrate);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LTEUESidelinkAggregateMaximumBitrate (
            (LTEUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate
            );

         stat = asn1PD_LTEUESidelinkAggregateMaximumBitrate (pctxt, 
            (LTEUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_PC5QoSParameters */
      case ASN1V_id_PC5QoSParameters:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_PC5QoSParameters;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_PC5QoSParameters");

         pvalue->value.u._InitialContextSetupRequestIEs_id_PC5QoSParameters
             = rtxMemAllocType (pctxt, PC5QoSParameters);

         if (pvalue->value.u._InitialContextSetupRequestIEs_id_PC5QoSParameters
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PC5QoSParameters ((PC5QoSParameters*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_PC5QoSParameters);

         stat = asn1PD_PC5QoSParameters (pctxt, (PC5QoSParameters*)pvalue->
            value.u._InitialContextSetupRequestIEs_id_PC5QoSParameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_CEmodeBrestricted */
      case ASN1V_id_CEmodeBrestricted:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_CEmodeBrestricted;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_CEmodeBrestricted");

         stat = asn1PD_CEmodeBrestricted (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_CEmodeBrestricted);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_UE_UP_CIoT_Support */
      case ASN1V_id_UE_UP_CIoT_Support:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UE_UP_CIoT_Support;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UE_UP_CIoT_Support");

         stat = asn1PD_UE_UP_CIoT_Support (pctxt, &pvalue->value.
            u._InitialContextSetupRequestIEs_id_UE_UP_CIoT_Support);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_RGLevelWirelineAccessCharacteristics */
      case ASN1V_id_RGLevelWirelineAccessCharacteristics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_RGLevelWirelineAccessCharacteristics;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_RGLevelWirelineAccessCharacteristics");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_RGLevelWirelineAccessCharacteristics
             = rtxMemAllocType (pctxt, RGLevelWirelineAccessCharacteristics);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_RGLevelWirelineAccessCharacteristics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RGLevelWirelineAccessCharacteristics (pvalue->value.
            u._InitialContextSetupRequestIEs_id_RGLevelWirelineAccessCharacteristics
            );

         stat = asn1PD_RGLevelWirelineAccessCharacteristics (pctxt, pvalue->
            value.
            u._InitialContextSetupRequestIEs_id_RGLevelWirelineAccessCharacteristics
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_ManagementBasedMDTPLMNList */
      case ASN1V_id_ManagementBasedMDTPLMNList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_ManagementBasedMDTPLMNList;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_ManagementBasedMDTPLMNList");

         pvalue->value.
            u._InitialContextSetupRequestIEs_id_ManagementBasedMDTPLMNList
             = rtxMemAllocType (pctxt, MDTPLMNList);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_ManagementBasedMDTPLMNList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MDTPLMNList ((MDTPLMNList*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_ManagementBasedMDTPLMNList);

         stat = asn1PD_MDTPLMNList (pctxt, (MDTPLMNList*)pvalue->value.
            u._InitialContextSetupRequestIEs_id_ManagementBasedMDTPLMNList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupRequestIEs_id_UERadioCapabilityID */
      case ASN1V_id_UERadioCapabilityID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UERadioCapabilityID;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UERadioCapabilityID");

         pvalue->value.u._InitialContextSetupRequestIEs_id_UERadioCapabilityID
             = rtxMemAllocType (pctxt, UERadioCapabilityID);

         if (pvalue->value.
            u._InitialContextSetupRequestIEs_id_UERadioCapabilityID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityID (pvalue->value.
            u._InitialContextSetupRequestIEs_id_UERadioCapabilityID);

         stat = asn1PD_UERadioCapabilityID (pctxt, pvalue->value.
            u._InitialContextSetupRequestIEs_id_UERadioCapabilityID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupRequest_protocolIEs (OSCTXT* pctxt, InitialContextSetupRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InitialContextSetupRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, InitialContextSetupRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InitialContextSetupRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_InitialContextSetupRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupRequest (OSCTXT* pctxt, InitialContextSetupRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialContextSetupRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_InitialContextSetupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupResponse_protocolIEs_element (OSCTXT* pctxt, InitialContextSetupResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes */
      case ASN1V_id_PDUSessionResourceSetupListCxtRes:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes");

         pvalue->value.
            u._InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes
             = rtxMemAllocType (pctxt, PDUSessionResourceSetupListCxtRes);

         if (pvalue->value.
            u._InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceSetupListCxtRes (pvalue->value.
            u._InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes
            );

         stat = asn1PD_PDUSessionResourceSetupListCxtRes (pctxt, pvalue->value.
            u._InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes */
      case ASN1V_id_PDUSessionResourceFailedToSetupListCxtRes:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes");

         pvalue->value.
            u._InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes
             = rtxMemAllocType (pctxt, 
            PDUSessionResourceFailedToSetupListCxtRes);

         if (pvalue->value.
            u._InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceFailedToSetupListCxtRes (pvalue->value.
            u._InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes
            );

         stat = asn1PD_PDUSessionResourceFailedToSetupListCxtRes (pctxt, pvalue
            ->value.
            u._InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._InitialContextSetupResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._InitialContextSetupResponseIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._InitialContextSetupResponseIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._InitialContextSetupResponseIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupResponse_protocolIEs (OSCTXT* pctxt, InitialContextSetupResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InitialContextSetupResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, InitialContextSetupResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InitialContextSetupResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_InitialContextSetupResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupResponse (OSCTXT* pctxt, InitialContextSetupResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialContextSetupResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_InitialContextSetupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupFailure_protocolIEs_element (OSCTXT* pctxt, InitialContextSetupFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail */
      case ASN1V_id_PDUSessionResourceFailedToSetupListCxtFail:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail");

         pvalue->value.
            u._InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail
             = rtxMemAllocType (pctxt, 
            PDUSessionResourceFailedToSetupListCxtFail);

         if (pvalue->value.
            u._InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceFailedToSetupListCxtFail (pvalue->value.
            u._InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail
            );

         stat = asn1PD_PDUSessionResourceFailedToSetupListCxtFail (pctxt, 
            pvalue->value.
            u._InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupFailureIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_Cause");

         pvalue->value.u._InitialContextSetupFailureIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._InitialContextSetupFailureIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._InitialContextSetupFailureIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._InitialContextSetupFailureIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialContextSetupFailureIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._InitialContextSetupFailureIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._InitialContextSetupFailureIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._InitialContextSetupFailureIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._InitialContextSetupFailureIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupFailure_protocolIEs (OSCTXT* pctxt, InitialContextSetupFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InitialContextSetupFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, InitialContextSetupFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InitialContextSetupFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_InitialContextSetupFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupFailure (OSCTXT* pctxt, InitialContextSetupFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialContextSetupFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_InitialContextSetupFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseRequest_protocolIEs_element (OSCTXT* pctxt, UEContextReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq */
      case ASN1V_id_PDUSessionResourceListCxtRelReq:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq");

         pvalue->value.
            u._UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq
             = rtxMemAllocType (pctxt, PDUSessionResourceListCxtRelReq);

         if (pvalue->value.
            u._UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceListCxtRelReq (pvalue->value.
            u._UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq
            );

         stat = asn1PD_PDUSessionResourceListCxtRelReq (pctxt, pvalue->value.
            u._UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextReleaseRequest_IEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_Cause");

         pvalue->value.u._UEContextReleaseRequest_IEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._UEContextReleaseRequest_IEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._UEContextReleaseRequest_IEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._UEContextReleaseRequest_IEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseRequest_protocolIEs (OSCTXT* pctxt, UEContextReleaseRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextReleaseRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextReleaseRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextReleaseRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextReleaseRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseRequest (OSCTXT* pctxt, UEContextReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextReleaseRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseCommand_protocolIEs_element (OSCTXT* pctxt, UEContextReleaseCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextReleaseCommand_IEs_id_UE_NGAP_IDs */
      case ASN1V_id_UE_NGAP_IDs:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseCommand_IEs_id_UE_NGAP_IDs;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseCommand_IEs_id_UE_NGAP_IDs");

         pvalue->value.u._UEContextReleaseCommand_IEs_id_UE_NGAP_IDs
             = rtxMemAllocType (pctxt, UE_NGAP_IDs);

         if (pvalue->value.u._UEContextReleaseCommand_IEs_id_UE_NGAP_IDs
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_NGAP_IDs ((UE_NGAP_IDs*)pvalue->value.
            u._UEContextReleaseCommand_IEs_id_UE_NGAP_IDs);

         stat = asn1PD_UE_NGAP_IDs (pctxt, (UE_NGAP_IDs*)pvalue->value.
            u._UEContextReleaseCommand_IEs_id_UE_NGAP_IDs);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextReleaseCommand_IEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseCommand_IEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseCommand_IEs_id_Cause");

         pvalue->value.u._UEContextReleaseCommand_IEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._UEContextReleaseCommand_IEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._UEContextReleaseCommand_IEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._UEContextReleaseCommand_IEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextReleaseCommand_IEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseCommand_protocolIEs (OSCTXT* pctxt, UEContextReleaseCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextReleaseCommand_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextReleaseCommand_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextReleaseCommand_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextReleaseCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseCommand (OSCTXT* pctxt, UEContextReleaseCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextReleaseCommand");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextReleaseCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseComplete_protocolIEs_element (OSCTXT* pctxt, UEContextReleaseComplete_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextReleaseComplete_IEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_UserLocationInformation");

         pvalue->value.
            u._UEContextReleaseComplete_IEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.
            u._UEContextReleaseComplete_IEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.u._UEContextReleaseComplete_IEs_id_UserLocationInformation);

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._UEContextReleaseComplete_IEs_id_UserLocationInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging */
      case ASN1V_id_InfoOnRecommendedCellsAndRANNodesForPaging:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging");

         pvalue->value.
            u._UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
             = rtxMemAllocType (pctxt, 
            InfoOnRecommendedCellsAndRANNodesForPaging);

         if (pvalue->value.
            u._UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_InfoOnRecommendedCellsAndRANNodesForPaging (
            (InfoOnRecommendedCellsAndRANNodesForPaging*)pvalue->value.
            u._UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
            );

         stat = asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging (pctxt, 
            (InfoOnRecommendedCellsAndRANNodesForPaging*)pvalue->value.
            u._UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl */
      case ASN1V_id_PDUSessionResourceListCxtRelCpl:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl");

         pvalue->value.
            u._UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl
             = rtxMemAllocType (pctxt, PDUSessionResourceListCxtRelCpl);

         if (pvalue->value.
            u._UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceListCxtRelCpl (pvalue->value.
            u._UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl
            );

         stat = asn1PD_PDUSessionResourceListCxtRelCpl (pctxt, pvalue->value.
            u._UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextReleaseComplete_IEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._UEContextReleaseComplete_IEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._UEContextReleaseComplete_IEs_id_CriticalityDiagnostics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._UEContextReleaseComplete_IEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._UEContextReleaseComplete_IEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextReleaseComplete_IEs_id_PagingAssisDataforCEcapabUE */
      case ASN1V_id_PagingAssisDataforCEcapabUE:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_PagingAssisDataforCEcapabUE;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_PagingAssisDataforCEcapabUE");

         pvalue->value.
            u._UEContextReleaseComplete_IEs_id_PagingAssisDataforCEcapabUE
             = rtxMemAllocType (pctxt, PagingAssisDataforCEcapabUE);

         if (pvalue->value.
            u._UEContextReleaseComplete_IEs_id_PagingAssisDataforCEcapabUE
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PagingAssisDataforCEcapabUE ((PagingAssisDataforCEcapabUE*)
            pvalue->value.
            u._UEContextReleaseComplete_IEs_id_PagingAssisDataforCEcapabUE);

         stat = asn1PD_PagingAssisDataforCEcapabUE (pctxt, 
            (PagingAssisDataforCEcapabUE*)pvalue->value.
            u._UEContextReleaseComplete_IEs_id_PagingAssisDataforCEcapabUE);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseComplete_protocolIEs (OSCTXT* pctxt, UEContextReleaseComplete_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextReleaseComplete_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextReleaseComplete_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextReleaseComplete_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextReleaseComplete_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseComplete (OSCTXT* pctxt, UEContextReleaseComplete* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextReleaseComplete");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextReleaseComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextResumeRequest_protocolIEs_element (OSCTXT* pctxt, UEContextResumeRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextResumeRequestIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeRequestIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeRequestIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextResumeRequestIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeRequestIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeRequestIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeRequestIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextResumeRequestIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeRequestIEs_id_RRC_Resume_Cause */
      case ASN1V_id_RRC_Resume_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeRequestIEs_id_RRC_Resume_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeRequestIEs_id_RRC_Resume_Cause");

         stat = asn1PD_RRCEstablishmentCause (pctxt, &pvalue->value.
            u._UEContextResumeRequestIEs_id_RRC_Resume_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeRequestIEs_id_PDUSessionResourceResumeListRESReq */
      case ASN1V_id_PDUSessionResourceResumeListRESReq:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeRequestIEs_id_PDUSessionResourceResumeListRESReq;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeRequestIEs_id_PDUSessionResourceResumeListRESReq");

         pvalue->value.
            u._UEContextResumeRequestIEs_id_PDUSessionResourceResumeListRESReq
             = rtxMemAllocType (pctxt, PDUSessionResourceResumeListRESReq);

         if (pvalue->value.
            u._UEContextResumeRequestIEs_id_PDUSessionResourceResumeListRESReq
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceResumeListRESReq (pvalue->value.
            u._UEContextResumeRequestIEs_id_PDUSessionResourceResumeListRESReq
            );

         stat = asn1PD_PDUSessionResourceResumeListRESReq (pctxt, pvalue->value
            .u._UEContextResumeRequestIEs_id_PDUSessionResourceResumeListRESReq
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeRequestIEs_id_PDUSessionResourceFailedToResumeListRESReq */
      case ASN1V_id_PDUSessionResourceFailedToResumeListRESReq:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeRequestIEs_id_PDUSessionResourceFailedToResumeListRESReq;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeRequestIEs_id_PDUSessionResourceFailedToResumeListRESReq");

         pvalue->value.
            u._UEContextResumeRequestIEs_id_PDUSessionResourceFailedToResumeListRESReq
             = rtxMemAllocType (pctxt, 
            PDUSessionResourceFailedToResumeListRESReq);

         if (pvalue->value.
            u._UEContextResumeRequestIEs_id_PDUSessionResourceFailedToResumeListRESReq
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceFailedToResumeListRESReq (pvalue->value.
            u._UEContextResumeRequestIEs_id_PDUSessionResourceFailedToResumeListRESReq
            );

         stat = asn1PD_PDUSessionResourceFailedToResumeListRESReq (pctxt, 
            pvalue->value.
            u._UEContextResumeRequestIEs_id_PDUSessionResourceFailedToResumeListRESReq
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeRequestIEs_id_Suspend_Request_Indication */
      case ASN1V_id_Suspend_Request_Indication:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeRequestIEs_id_Suspend_Request_Indication;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeRequestIEs_id_Suspend_Request_Indication");

         stat = asn1PD_Suspend_Request_Indication (pctxt, &pvalue->value.
            u._UEContextResumeRequestIEs_id_Suspend_Request_Indication);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging */
      case ASN1V_id_InfoOnRecommendedCellsAndRANNodesForPaging:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging");

         pvalue->value.
            u._UEContextResumeRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
             = rtxMemAllocType (pctxt, 
            InfoOnRecommendedCellsAndRANNodesForPaging);

         if (pvalue->value.
            u._UEContextResumeRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_InfoOnRecommendedCellsAndRANNodesForPaging (
            (InfoOnRecommendedCellsAndRANNodesForPaging*)pvalue->value.
            u._UEContextResumeRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
            );

         stat = asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging (pctxt, 
            (InfoOnRecommendedCellsAndRANNodesForPaging*)pvalue->value.
            u._UEContextResumeRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeRequestIEs_id_PagingAssisDataforCEcapabUE */
      case ASN1V_id_PagingAssisDataforCEcapabUE:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeRequestIEs_id_PagingAssisDataforCEcapabUE;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeRequestIEs_id_PagingAssisDataforCEcapabUE");

         pvalue->value.
            u._UEContextResumeRequestIEs_id_PagingAssisDataforCEcapabUE
             = rtxMemAllocType (pctxt, PagingAssisDataforCEcapabUE);

         if (pvalue->value.
            u._UEContextResumeRequestIEs_id_PagingAssisDataforCEcapabUE
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PagingAssisDataforCEcapabUE ((PagingAssisDataforCEcapabUE*)
            pvalue->value.
            u._UEContextResumeRequestIEs_id_PagingAssisDataforCEcapabUE);

         stat = asn1PD_PagingAssisDataforCEcapabUE (pctxt, 
            (PagingAssisDataforCEcapabUE*)pvalue->value.
            u._UEContextResumeRequestIEs_id_PagingAssisDataforCEcapabUE);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextResumeRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextResumeRequest_protocolIEs (OSCTXT* pctxt, UEContextResumeRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextResumeRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextResumeRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextResumeRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextResumeRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextResumeRequest (OSCTXT* pctxt, UEContextResumeRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextResumeRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextResumeRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextResumeResponse_protocolIEs_element (OSCTXT* pctxt, UEContextResumeResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextResumeResponseIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeResponseIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeResponseIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextResumeResponseIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeResponseIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeResponseIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeResponseIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextResumeResponseIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeResponseIEs_id_PDUSessionResourceResumeListRESRes */
      case ASN1V_id_PDUSessionResourceResumeListRESRes:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeResponseIEs_id_PDUSessionResourceResumeListRESRes;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeResponseIEs_id_PDUSessionResourceResumeListRESRes");

         pvalue->value.
            u._UEContextResumeResponseIEs_id_PDUSessionResourceResumeListRESRes
             = rtxMemAllocType (pctxt, PDUSessionResourceResumeListRESRes);

         if (pvalue->value.
            u._UEContextResumeResponseIEs_id_PDUSessionResourceResumeListRESRes
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceResumeListRESRes (pvalue->value.
            u._UEContextResumeResponseIEs_id_PDUSessionResourceResumeListRESRes
            );

         stat = asn1PD_PDUSessionResourceResumeListRESRes (pctxt, pvalue->value
            .
            u._UEContextResumeResponseIEs_id_PDUSessionResourceResumeListRESRes
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeResponseIEs_id_PDUSessionResourceFailedToResumeListRESRes */
      case ASN1V_id_PDUSessionResourceFailedToResumeListRESRes:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeResponseIEs_id_PDUSessionResourceFailedToResumeListRESRes;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeResponseIEs_id_PDUSessionResourceFailedToResumeListRESRes");

         pvalue->value.
            u._UEContextResumeResponseIEs_id_PDUSessionResourceFailedToResumeListRESRes
             = rtxMemAllocType (pctxt, 
            PDUSessionResourceFailedToResumeListRESRes);

         if (pvalue->value.
            u._UEContextResumeResponseIEs_id_PDUSessionResourceFailedToResumeListRESRes
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceFailedToResumeListRESRes (pvalue->value.
            u._UEContextResumeResponseIEs_id_PDUSessionResourceFailedToResumeListRESRes
            );

         stat = asn1PD_PDUSessionResourceFailedToResumeListRESRes (pctxt, 
            pvalue->value.
            u._UEContextResumeResponseIEs_id_PDUSessionResourceFailedToResumeListRESRes
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeResponseIEs_id_SecurityContext */
      case ASN1V_id_SecurityContext:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeResponseIEs_id_SecurityContext;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeResponseIEs_id_SecurityContext");

         pvalue->value.u._UEContextResumeResponseIEs_id_SecurityContext
             = rtxMemAllocType (pctxt, SecurityContext);

         if (pvalue->value.u._UEContextResumeResponseIEs_id_SecurityContext
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityContext ((SecurityContext*)pvalue->value.
            u._UEContextResumeResponseIEs_id_SecurityContext);

         stat = asn1PD_SecurityContext (pctxt, (SecurityContext*)pvalue->value.
            u._UEContextResumeResponseIEs_id_SecurityContext);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeResponseIEs_id_Suspend_Response_Indication */
      case ASN1V_id_Suspend_Response_Indication:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeResponseIEs_id_Suspend_Response_Indication;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeResponseIEs_id_Suspend_Response_Indication");

         stat = asn1PD_Suspend_Response_Indication (pctxt, &pvalue->value.
            u._UEContextResumeResponseIEs_id_Suspend_Response_Indication);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeResponseIEs_id_Extended_ConnectedTime */
      case ASN1V_id_Extended_ConnectedTime:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeResponseIEs_id_Extended_ConnectedTime;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeResponseIEs_id_Extended_ConnectedTime");

         stat = asn1PD_Extended_ConnectedTime (pctxt, &pvalue->value.
            u._UEContextResumeResponseIEs_id_Extended_ConnectedTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.u._UEContextResumeResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._UEContextResumeResponseIEs_id_CriticalityDiagnostics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._UEContextResumeResponseIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._UEContextResumeResponseIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextResumeResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextResumeResponse_protocolIEs (OSCTXT* pctxt, UEContextResumeResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextResumeResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextResumeResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextResumeResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextResumeResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextResumeResponse (OSCTXT* pctxt, UEContextResumeResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextResumeResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextResumeResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextResumeFailure_protocolIEs_element (OSCTXT* pctxt, UEContextResumeFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextResumeFailureIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeFailureIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeFailureIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextResumeFailureIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeFailureIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeFailureIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeFailureIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextResumeFailureIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeFailureIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeFailureIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeFailureIEs_id_Cause");

         pvalue->value.u._UEContextResumeFailureIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._UEContextResumeFailureIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._UEContextResumeFailureIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._UEContextResumeFailureIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextResumeFailureIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextResumeFailureIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextResumeFailureIEs_id_CriticalityDiagnostics");

         pvalue->value.u._UEContextResumeFailureIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._UEContextResumeFailureIEs_id_CriticalityDiagnostics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._UEContextResumeFailureIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._UEContextResumeFailureIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextResumeFailureIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextResumeFailure_protocolIEs (OSCTXT* pctxt, UEContextResumeFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextResumeFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextResumeFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextResumeFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextResumeFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextResumeFailure (OSCTXT* pctxt, UEContextResumeFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextResumeFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeFailure: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextResumeFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextResumeFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextSuspendRequest_protocolIEs_element (OSCTXT* pctxt, UEContextSuspendRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextSuspendRequestIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendRequestIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendRequestIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextSuspendRequestIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextSuspendRequestIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendRequestIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendRequestIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextSuspendRequestIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextSuspendRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging */
      case ASN1V_id_InfoOnRecommendedCellsAndRANNodesForPaging:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging");

         pvalue->value.
            u._UEContextSuspendRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
             = rtxMemAllocType (pctxt, 
            InfoOnRecommendedCellsAndRANNodesForPaging);

         if (pvalue->value.
            u._UEContextSuspendRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_InfoOnRecommendedCellsAndRANNodesForPaging (
            (InfoOnRecommendedCellsAndRANNodesForPaging*)pvalue->value.
            u._UEContextSuspendRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
            );

         stat = asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging (pctxt, 
            (InfoOnRecommendedCellsAndRANNodesForPaging*)pvalue->value.
            u._UEContextSuspendRequestIEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextSuspendRequestIEs_id_PagingAssisDataforCEcapabUE */
      case ASN1V_id_PagingAssisDataforCEcapabUE:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendRequestIEs_id_PagingAssisDataforCEcapabUE;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendRequestIEs_id_PagingAssisDataforCEcapabUE");

         pvalue->value.
            u._UEContextSuspendRequestIEs_id_PagingAssisDataforCEcapabUE
             = rtxMemAllocType (pctxt, PagingAssisDataforCEcapabUE);

         if (pvalue->value.
            u._UEContextSuspendRequestIEs_id_PagingAssisDataforCEcapabUE
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PagingAssisDataforCEcapabUE ((PagingAssisDataforCEcapabUE*)
            pvalue->value.
            u._UEContextSuspendRequestIEs_id_PagingAssisDataforCEcapabUE);

         stat = asn1PD_PagingAssisDataforCEcapabUE (pctxt, 
            (PagingAssisDataforCEcapabUE*)pvalue->value.
            u._UEContextSuspendRequestIEs_id_PagingAssisDataforCEcapabUE);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextSuspendRequestIEs_id_PDUSessionResourceSuspendListSUSReq */
      case ASN1V_id_PDUSessionResourceSuspendListSUSReq:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendRequestIEs_id_PDUSessionResourceSuspendListSUSReq;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendRequestIEs_id_PDUSessionResourceSuspendListSUSReq");

         pvalue->value.
            u._UEContextSuspendRequestIEs_id_PDUSessionResourceSuspendListSUSReq
             = rtxMemAllocType (pctxt, PDUSessionResourceSuspendListSUSReq);

         if (pvalue->value.
            u._UEContextSuspendRequestIEs_id_PDUSessionResourceSuspendListSUSReq
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceSuspendListSUSReq (pvalue->value.
            u._UEContextSuspendRequestIEs_id_PDUSessionResourceSuspendListSUSReq
            );

         stat = asn1PD_PDUSessionResourceSuspendListSUSReq (pctxt, pvalue->
            value.
            u._UEContextSuspendRequestIEs_id_PDUSessionResourceSuspendListSUSReq
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextSuspendRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextSuspendRequest_protocolIEs (OSCTXT* pctxt, UEContextSuspendRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextSuspendRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextSuspendRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextSuspendRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextSuspendRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextSuspendRequest (OSCTXT* pctxt, UEContextSuspendRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextSuspendRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextSuspendRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextSuspendResponse_protocolIEs_element (OSCTXT* pctxt, UEContextSuspendResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextSuspendResponseIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendResponseIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendResponseIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextSuspendResponseIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextSuspendResponseIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendResponseIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendResponseIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextSuspendResponseIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextSuspendResponseIEs_id_SecurityContext */
      case ASN1V_id_SecurityContext:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendResponseIEs_id_SecurityContext;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendResponseIEs_id_SecurityContext");

         pvalue->value.u._UEContextSuspendResponseIEs_id_SecurityContext
             = rtxMemAllocType (pctxt, SecurityContext);

         if (pvalue->value.u._UEContextSuspendResponseIEs_id_SecurityContext
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityContext ((SecurityContext*)pvalue->value.
            u._UEContextSuspendResponseIEs_id_SecurityContext);

         stat = asn1PD_SecurityContext (pctxt, (SecurityContext*)pvalue->value.
            u._UEContextSuspendResponseIEs_id_SecurityContext);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextSuspendResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.u._UEContextSuspendResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._UEContextSuspendResponseIEs_id_CriticalityDiagnostics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._UEContextSuspendResponseIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._UEContextSuspendResponseIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextSuspendResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextSuspendResponse_protocolIEs (OSCTXT* pctxt, UEContextSuspendResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextSuspendResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextSuspendResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextSuspendResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextSuspendResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextSuspendResponse (OSCTXT* pctxt, UEContextSuspendResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextSuspendResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextSuspendResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextSuspendFailure_protocolIEs_element (OSCTXT* pctxt, UEContextSuspendFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextSuspendFailureIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendFailureIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendFailureIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextSuspendFailureIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextSuspendFailureIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendFailureIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendFailureIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextSuspendFailureIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextSuspendFailureIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendFailureIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendFailureIEs_id_Cause");

         pvalue->value.u._UEContextSuspendFailureIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._UEContextSuspendFailureIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._UEContextSuspendFailureIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._UEContextSuspendFailureIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextSuspendFailureIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextSuspendFailureIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextSuspendFailureIEs_id_CriticalityDiagnostics");

         pvalue->value.u._UEContextSuspendFailureIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._UEContextSuspendFailureIEs_id_CriticalityDiagnostics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._UEContextSuspendFailureIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._UEContextSuspendFailureIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextSuspendFailureIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextSuspendFailure_protocolIEs (OSCTXT* pctxt, UEContextSuspendFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextSuspendFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextSuspendFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextSuspendFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextSuspendFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextSuspendFailure (OSCTXT* pctxt, UEContextSuspendFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextSuspendFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendFailure: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextSuspendFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextSuspendFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextModificationRequest_protocolIEs_element (OSCTXT* pctxt, UEContextModificationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_RANPagingPriority */
      case ASN1V_id_RANPagingPriority:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_RANPagingPriority;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_RANPagingPriority");

         stat = asn1PD_RANPagingPriority (pctxt, &pvalue->value.
            u._UEContextModificationRequestIEs_id_RANPagingPriority);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_SecurityKey */
      case ASN1V_id_SecurityKey:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_SecurityKey;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_SecurityKey");

         pvalue->value.u._UEContextModificationRequestIEs_id_SecurityKey
             = rtxMemAllocTypeZ (pctxt, SecurityKey);

         if (pvalue->value.u._UEContextModificationRequestIEs_id_SecurityKey
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SecurityKey (pctxt, (SecurityKey*)pvalue->value.
            u._UEContextModificationRequestIEs_id_SecurityKey);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_IndexToRFSP */
      case ASN1V_id_IndexToRFSP:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_IndexToRFSP;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_IndexToRFSP");

         stat = asn1PD_IndexToRFSP (pctxt, &pvalue->value.
            u._UEContextModificationRequestIEs_id_IndexToRFSP);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate */
      case ASN1V_id_UEAggregateMaximumBitRate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate
             = rtxMemAllocType (pctxt, UEAggregateMaximumBitRate);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEAggregateMaximumBitRate ((UEAggregateMaximumBitRate*)pvalue
            ->value.
            u._UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate);

         stat = asn1PD_UEAggregateMaximumBitRate (pctxt, 
            (UEAggregateMaximumBitRate*)pvalue->value.
            u._UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_UESecurityCapabilities */
      case ASN1V_id_UESecurityCapabilities:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_UESecurityCapabilities;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_UESecurityCapabilities");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_UESecurityCapabilities
             = rtxMemAllocType (pctxt, UESecurityCapabilities);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_UESecurityCapabilities
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UESecurityCapabilities ((UESecurityCapabilities*)pvalue->
            value.u._UEContextModificationRequestIEs_id_UESecurityCapabilities
            );

         stat = asn1PD_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)
            pvalue->value.
            u._UEContextModificationRequestIEs_id_UESecurityCapabilities);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive */
      case ASN1V_id_CoreNetworkAssistanceInformationForInactive:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive
             = rtxMemAllocType (pctxt, 
            CoreNetworkAssistanceInformationForInactive);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CoreNetworkAssistanceInformationForInactive (
            (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
            u._UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive
            );

         stat = asn1PD_CoreNetworkAssistanceInformationForInactive (pctxt, 
            (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
            u._UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_EmergencyFallbackIndicator */
      case ASN1V_id_EmergencyFallbackIndicator:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_EmergencyFallbackIndicator;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_EmergencyFallbackIndicator");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_EmergencyFallbackIndicator
             = rtxMemAllocType (pctxt, EmergencyFallbackIndicator);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_EmergencyFallbackIndicator
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EmergencyFallbackIndicator ((EmergencyFallbackIndicator*)
            pvalue->value.
            u._UEContextModificationRequestIEs_id_EmergencyFallbackIndicator);

         stat = asn1PD_EmergencyFallbackIndicator (pctxt, 
            (EmergencyFallbackIndicator*)pvalue->value.
            u._UEContextModificationRequestIEs_id_EmergencyFallbackIndicator);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID */
      case ASN1V_id_NewAMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest */
      case ASN1V_id_RRCInactiveTransitionReportRequest:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest");

         stat = asn1PD_RRCInactiveTransitionReportRequest (pctxt, &pvalue->
            value.
            u._UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_NewGUAMI */
      case ASN1V_id_NewGUAMI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_NewGUAMI;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_NewGUAMI");

         pvalue->value.u._UEContextModificationRequestIEs_id_NewGUAMI
             = rtxMemAllocType (pctxt, GUAMI);

         if (pvalue->value.u._UEContextModificationRequestIEs_id_NewGUAMI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GUAMI ((GUAMI*)pvalue->value.
            u._UEContextModificationRequestIEs_id_NewGUAMI);

         stat = asn1PD_GUAMI (pctxt, (GUAMI*)pvalue->value.
            u._UEContextModificationRequestIEs_id_NewGUAMI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_CNAssistedRANTuning */
      case ASN1V_id_CNAssistedRANTuning:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_CNAssistedRANTuning;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_CNAssistedRANTuning");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_CNAssistedRANTuning
             = rtxMemAllocType (pctxt, CNAssistedRANTuning);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_CNAssistedRANTuning == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CNAssistedRANTuning ((CNAssistedRANTuning*)pvalue->value.
            u._UEContextModificationRequestIEs_id_CNAssistedRANTuning);

         stat = asn1PD_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue
            ->value.u._UEContextModificationRequestIEs_id_CNAssistedRANTuning
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_SRVCCOperationPossible */
      case ASN1V_id_SRVCCOperationPossible:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_SRVCCOperationPossible;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_SRVCCOperationPossible");

         stat = asn1PD_SRVCCOperationPossible (pctxt, &pvalue->value.
            u._UEContextModificationRequestIEs_id_SRVCCOperationPossible);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_IAB_Authorized */
      case ASN1V_id_IAB_Authorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_IAB_Authorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_IAB_Authorized");

         stat = asn1PD_IAB_Authorized (pctxt, &pvalue->value.
            u._UEContextModificationRequestIEs_id_IAB_Authorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_NRV2XServicesAuthorized */
      case ASN1V_id_NRV2XServicesAuthorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_NRV2XServicesAuthorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_NRV2XServicesAuthorized");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_NRV2XServicesAuthorized
             = rtxMemAllocType (pctxt, NRV2XServicesAuthorized);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_NRV2XServicesAuthorized
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRV2XServicesAuthorized ((NRV2XServicesAuthorized*)pvalue->
            value.u._UEContextModificationRequestIEs_id_NRV2XServicesAuthorized
            );

         stat = asn1PD_NRV2XServicesAuthorized (pctxt, 
            (NRV2XServicesAuthorized*)pvalue->value.
            u._UEContextModificationRequestIEs_id_NRV2XServicesAuthorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_LTEV2XServicesAuthorized */
      case ASN1V_id_LTEV2XServicesAuthorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_LTEV2XServicesAuthorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_LTEV2XServicesAuthorized");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_LTEV2XServicesAuthorized
             = rtxMemAllocType (pctxt, LTEV2XServicesAuthorized);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_LTEV2XServicesAuthorized
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LTEV2XServicesAuthorized ((LTEV2XServicesAuthorized*)pvalue->
            value.
            u._UEContextModificationRequestIEs_id_LTEV2XServicesAuthorized);

         stat = asn1PD_LTEV2XServicesAuthorized (pctxt, 
            (LTEV2XServicesAuthorized*)pvalue->value.
            u._UEContextModificationRequestIEs_id_LTEV2XServicesAuthorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_NRUESidelinkAggregateMaximumBitrate */
      case ASN1V_id_NRUESidelinkAggregateMaximumBitrate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_NRUESidelinkAggregateMaximumBitrate;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_NRUESidelinkAggregateMaximumBitrate");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_NRUESidelinkAggregateMaximumBitrate
             = rtxMemAllocType (pctxt, NRUESidelinkAggregateMaximumBitrate);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_NRUESidelinkAggregateMaximumBitrate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRUESidelinkAggregateMaximumBitrate (
            (NRUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._UEContextModificationRequestIEs_id_NRUESidelinkAggregateMaximumBitrate
            );

         stat = asn1PD_NRUESidelinkAggregateMaximumBitrate (pctxt, 
            (NRUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._UEContextModificationRequestIEs_id_NRUESidelinkAggregateMaximumBitrate
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate */
      case ASN1V_id_LTEUESidelinkAggregateMaximumBitrate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate
             = rtxMemAllocType (pctxt, LTEUESidelinkAggregateMaximumBitrate);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LTEUESidelinkAggregateMaximumBitrate (
            (LTEUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._UEContextModificationRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate
            );

         stat = asn1PD_LTEUESidelinkAggregateMaximumBitrate (pctxt, 
            (LTEUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._UEContextModificationRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_PC5QoSParameters */
      case ASN1V_id_PC5QoSParameters:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_PC5QoSParameters;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_PC5QoSParameters");

         pvalue->value.u._UEContextModificationRequestIEs_id_PC5QoSParameters
             = rtxMemAllocType (pctxt, PC5QoSParameters);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_PC5QoSParameters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PC5QoSParameters ((PC5QoSParameters*)pvalue->value.
            u._UEContextModificationRequestIEs_id_PC5QoSParameters);

         stat = asn1PD_PC5QoSParameters (pctxt, (PC5QoSParameters*)pvalue->
            value.u._UEContextModificationRequestIEs_id_PC5QoSParameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_UERadioCapabilityID */
      case ASN1V_id_UERadioCapabilityID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_UERadioCapabilityID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_UERadioCapabilityID");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_UERadioCapabilityID
             = rtxMemAllocType (pctxt, UERadioCapabilityID);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_UERadioCapabilityID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityID (pvalue->value.
            u._UEContextModificationRequestIEs_id_UERadioCapabilityID);

         stat = asn1PD_UERadioCapabilityID (pctxt, pvalue->value.
            u._UEContextModificationRequestIEs_id_UERadioCapabilityID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationRequestIEs_id_RGLevelWirelineAccessCharacteristics */
      case ASN1V_id_RGLevelWirelineAccessCharacteristics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_RGLevelWirelineAccessCharacteristics;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_RGLevelWirelineAccessCharacteristics");

         pvalue->value.
            u._UEContextModificationRequestIEs_id_RGLevelWirelineAccessCharacteristics
             = rtxMemAllocType (pctxt, RGLevelWirelineAccessCharacteristics);

         if (pvalue->value.
            u._UEContextModificationRequestIEs_id_RGLevelWirelineAccessCharacteristics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RGLevelWirelineAccessCharacteristics (pvalue->value.
            u._UEContextModificationRequestIEs_id_RGLevelWirelineAccessCharacteristics
            );

         stat = asn1PD_RGLevelWirelineAccessCharacteristics (pctxt, pvalue->
            value.
            u._UEContextModificationRequestIEs_id_RGLevelWirelineAccessCharacteristics
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationRequest_protocolIEs (OSCTXT* pctxt, UEContextModificationRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextModificationRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextModificationRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextModificationRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextModificationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationRequest (OSCTXT* pctxt, UEContextModificationRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextModificationRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextModificationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextModificationResponse_protocolIEs_element (OSCTXT* pctxt, UEContextModificationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationResponseIEs_id_RRCState */
      case ASN1V_id_RRCState:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_RRCState;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_RRCState");

         stat = asn1PD_RRCState (pctxt, &pvalue->value.
            u._UEContextModificationResponseIEs_id_RRCState);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationResponseIEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_UserLocationInformation");

         pvalue->value.
            u._UEContextModificationResponseIEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.
            u._UEContextModificationResponseIEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.
            u._UEContextModificationResponseIEs_id_UserLocationInformation);

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._UEContextModificationResponseIEs_id_UserLocationInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._UEContextModificationResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._UEContextModificationResponseIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._UEContextModificationResponseIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._UEContextModificationResponseIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationResponse_protocolIEs (OSCTXT* pctxt, UEContextModificationResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextModificationResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextModificationResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextModificationResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextModificationResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationResponse (OSCTXT* pctxt, UEContextModificationResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextModificationResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextModificationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextModificationFailure_protocolIEs_element (OSCTXT* pctxt, UEContextModificationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationFailureIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_Cause");

         pvalue->value.u._UEContextModificationFailureIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._UEContextModificationFailureIEs_id_Cause
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._UEContextModificationFailureIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._UEContextModificationFailureIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEContextModificationFailureIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._UEContextModificationFailureIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._UEContextModificationFailureIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._UEContextModificationFailureIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._UEContextModificationFailureIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEContextModificationFailureIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationFailure_protocolIEs (OSCTXT* pctxt, UEContextModificationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextModificationFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextModificationFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextModificationFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextModificationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationFailure (OSCTXT* pctxt, UEContextModificationFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextModificationFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextModificationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCInactiveTransitionReport_protocolIEs_element (OSCTXT* pctxt, RRCInactiveTransitionReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RRCInactiveTransitionReportIEs_id_RRCState */
      case ASN1V_id_RRCState:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_RRCState;

         RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_RRCState");

         stat = asn1PD_RRCState (pctxt, &pvalue->value.
            u._RRCInactiveTransitionReportIEs_id_RRCState);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RRCInactiveTransitionReportIEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_UserLocationInformation");

         pvalue->value.
            u._RRCInactiveTransitionReportIEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.
            u._RRCInactiveTransitionReportIEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.u._RRCInactiveTransitionReportIEs_id_UserLocationInformation
            );

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._RRCInactiveTransitionReportIEs_id_UserLocationInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RRCInactiveTransitionReport_protocolIEs (OSCTXT* pctxt, RRCInactiveTransitionReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RRCInactiveTransitionReport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RRCInactiveTransitionReport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RRCInactiveTransitionReport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RRCInactiveTransitionReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RRCInactiveTransitionReport (OSCTXT* pctxt, RRCInactiveTransitionReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCInactiveTransitionReport");

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RRCInactiveTransitionReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RetrieveUEInformation_protocolIEs_element (OSCTXT* pctxt, RetrieveUEInformation_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RetrieveUEInformation_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _RetrieveUEInformationIEs_id_FiveG_S_TMSI */
      case ASN1V_id_FiveG_S_TMSI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RetrieveUEInformationIEs_id_FiveG_S_TMSI;

         RTXCTXTPUSHELEMNAME (pctxt, "_RetrieveUEInformationIEs_id_FiveG_S_TMSI");

         pvalue->value.u._RetrieveUEInformationIEs_id_FiveG_S_TMSI
             = rtxMemAllocType (pctxt, FiveG_S_TMSI);

         if (pvalue->value.u._RetrieveUEInformationIEs_id_FiveG_S_TMSI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FiveG_S_TMSI (pvalue->value.
            u._RetrieveUEInformationIEs_id_FiveG_S_TMSI);

         stat = asn1PD_FiveG_S_TMSI (pctxt, pvalue->value.
            u._RetrieveUEInformationIEs_id_FiveG_S_TMSI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_RetrieveUEInformationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RetrieveUEInformation_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RetrieveUEInformation_protocolIEs (OSCTXT* pctxt, RetrieveUEInformation_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RetrieveUEInformation_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RetrieveUEInformation_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RetrieveUEInformation_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RetrieveUEInformation_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RetrieveUEInformation_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RetrieveUEInformation_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RetrieveUEInformation (OSCTXT* pctxt, RetrieveUEInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RetrieveUEInformation");

   RTDIAGSTRM2 (pctxt,"asn1PD_RetrieveUEInformation: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RetrieveUEInformation_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RetrieveUEInformation: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEInformationTransfer_protocolIEs_element (OSCTXT* pctxt, UEInformationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEInformationTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UEInformationTransferIEs_id_FiveG_S_TMSI */
      case ASN1V_id_FiveG_S_TMSI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEInformationTransferIEs_id_FiveG_S_TMSI;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEInformationTransferIEs_id_FiveG_S_TMSI");

         pvalue->value.u._UEInformationTransferIEs_id_FiveG_S_TMSI
             = rtxMemAllocType (pctxt, FiveG_S_TMSI);

         if (pvalue->value.u._UEInformationTransferIEs_id_FiveG_S_TMSI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FiveG_S_TMSI ((FiveG_S_TMSI*)pvalue->value.
            u._UEInformationTransferIEs_id_FiveG_S_TMSI);

         stat = asn1PD_FiveG_S_TMSI (pctxt, (FiveG_S_TMSI*)pvalue->value.
            u._UEInformationTransferIEs_id_FiveG_S_TMSI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEInformationTransferIEs_id_NB_IoT_UEPriority */
      case ASN1V_id_NB_IoT_UEPriority:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEInformationTransferIEs_id_NB_IoT_UEPriority;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEInformationTransferIEs_id_NB_IoT_UEPriority");

         stat = asn1PD_NB_IoT_UEPriority (pctxt, &pvalue->value.
            u._UEInformationTransferIEs_id_NB_IoT_UEPriority);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEInformationTransferIEs_id_UERadioCapability */
      case ASN1V_id_UERadioCapability:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEInformationTransferIEs_id_UERadioCapability;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEInformationTransferIEs_id_UERadioCapability");

         pvalue->value.u._UEInformationTransferIEs_id_UERadioCapability
             = rtxMemAllocType (pctxt, UERadioCapability);

         if (pvalue->value.u._UEInformationTransferIEs_id_UERadioCapability
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapability (pvalue->value.
            u._UEInformationTransferIEs_id_UERadioCapability);

         stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
            u._UEInformationTransferIEs_id_UERadioCapability);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEInformationTransferIEs_id_S_NSSAI */
      case ASN1V_id_S_NSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEInformationTransferIEs_id_S_NSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEInformationTransferIEs_id_S_NSSAI");

         pvalue->value.u._UEInformationTransferIEs_id_S_NSSAI
             = rtxMemAllocType (pctxt, S_NSSAI);

         if (pvalue->value.u._UEInformationTransferIEs_id_S_NSSAI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_S_NSSAI ((S_NSSAI*)pvalue->value.
            u._UEInformationTransferIEs_id_S_NSSAI);

         stat = asn1PD_S_NSSAI (pctxt, (S_NSSAI*)pvalue->value.
            u._UEInformationTransferIEs_id_S_NSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEInformationTransferIEs_id_AllowedNSSAI */
      case ASN1V_id_AllowedNSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEInformationTransferIEs_id_AllowedNSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEInformationTransferIEs_id_AllowedNSSAI");

         pvalue->value.u._UEInformationTransferIEs_id_AllowedNSSAI
             = rtxMemAllocType (pctxt, AllowedNSSAI);

         if (pvalue->value.u._UEInformationTransferIEs_id_AllowedNSSAI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AllowedNSSAI (pvalue->value.
            u._UEInformationTransferIEs_id_AllowedNSSAI);

         stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
            u._UEInformationTransferIEs_id_AllowedNSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UEInformationTransferIEs_id_UE_DifferentiationInfo */
      case ASN1V_id_UE_DifferentiationInfo:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UEInformationTransferIEs_id_UE_DifferentiationInfo;

         RTXCTXTPUSHELEMNAME (pctxt, "_UEInformationTransferIEs_id_UE_DifferentiationInfo");

         pvalue->value.u._UEInformationTransferIEs_id_UE_DifferentiationInfo
             = rtxMemAllocType (pctxt, UE_DifferentiationInfo);

         if (pvalue->value.
            u._UEInformationTransferIEs_id_UE_DifferentiationInfo == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_DifferentiationInfo ((UE_DifferentiationInfo*)pvalue->
            value.u._UEInformationTransferIEs_id_UE_DifferentiationInfo);

         stat = asn1PD_UE_DifferentiationInfo (pctxt, (UE_DifferentiationInfo*)
            pvalue->value.u._UEInformationTransferIEs_id_UE_DifferentiationInfo
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UEInformationTransferIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEInformationTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEInformationTransfer_protocolIEs (OSCTXT* pctxt, UEInformationTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEInformationTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEInformationTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEInformationTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEInformationTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEInformationTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEInformationTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEInformationTransfer (OSCTXT* pctxt, UEInformationTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEInformationTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEInformationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEInformationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEInformationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RANCPRelocationIndication_protocolIEs_element (OSCTXT* pctxt, RANCPRelocationIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANCPRelocationIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _RANCPRelocationIndicationIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANCPRelocationIndicationIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANCPRelocationIndicationIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._RANCPRelocationIndicationIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANCPRelocationIndicationIEs_id_FiveG_S_TMSI */
      case ASN1V_id_FiveG_S_TMSI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANCPRelocationIndicationIEs_id_FiveG_S_TMSI;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANCPRelocationIndicationIEs_id_FiveG_S_TMSI");

         pvalue->value.u._RANCPRelocationIndicationIEs_id_FiveG_S_TMSI
             = rtxMemAllocType (pctxt, FiveG_S_TMSI);

         if (pvalue->value.u._RANCPRelocationIndicationIEs_id_FiveG_S_TMSI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FiveG_S_TMSI ((FiveG_S_TMSI*)pvalue->value.
            u._RANCPRelocationIndicationIEs_id_FiveG_S_TMSI);

         stat = asn1PD_FiveG_S_TMSI (pctxt, (FiveG_S_TMSI*)pvalue->value.
            u._RANCPRelocationIndicationIEs_id_FiveG_S_TMSI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANCPRelocationIndicationIEs_id_EUTRA_CGI */
      case ASN1V_id_EUTRA_CGI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANCPRelocationIndicationIEs_id_EUTRA_CGI;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANCPRelocationIndicationIEs_id_EUTRA_CGI");

         pvalue->value.u._RANCPRelocationIndicationIEs_id_EUTRA_CGI
             = rtxMemAllocType (pctxt, EUTRA_CGI);

         if (pvalue->value.u._RANCPRelocationIndicationIEs_id_EUTRA_CGI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EUTRA_CGI ((EUTRA_CGI*)pvalue->value.
            u._RANCPRelocationIndicationIEs_id_EUTRA_CGI);

         stat = asn1PD_EUTRA_CGI (pctxt, (EUTRA_CGI*)pvalue->value.
            u._RANCPRelocationIndicationIEs_id_EUTRA_CGI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANCPRelocationIndicationIEs_id_TAI */
      case ASN1V_id_TAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANCPRelocationIndicationIEs_id_TAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANCPRelocationIndicationIEs_id_TAI");

         pvalue->value.u._RANCPRelocationIndicationIEs_id_TAI
             = rtxMemAllocType (pctxt, TAI);

         if (pvalue->value.u._RANCPRelocationIndicationIEs_id_TAI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TAI ((TAI*)pvalue->value.
            u._RANCPRelocationIndicationIEs_id_TAI);

         stat = asn1PD_TAI (pctxt, (TAI*)pvalue->value.
            u._RANCPRelocationIndicationIEs_id_TAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANCPRelocationIndicationIEs_id_UL_CP_SecurityInformation */
      case ASN1V_id_UL_CP_SecurityInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANCPRelocationIndicationIEs_id_UL_CP_SecurityInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANCPRelocationIndicationIEs_id_UL_CP_SecurityInformation");

         pvalue->value.
            u._RANCPRelocationIndicationIEs_id_UL_CP_SecurityInformation
             = rtxMemAllocType (pctxt, UL_CP_SecurityInformation);

         if (pvalue->value.
            u._RANCPRelocationIndicationIEs_id_UL_CP_SecurityInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UL_CP_SecurityInformation ((UL_CP_SecurityInformation*)pvalue
            ->value.
            u._RANCPRelocationIndicationIEs_id_UL_CP_SecurityInformation);

         stat = asn1PD_UL_CP_SecurityInformation (pctxt, 
            (UL_CP_SecurityInformation*)pvalue->value.
            u._RANCPRelocationIndicationIEs_id_UL_CP_SecurityInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_RANCPRelocationIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RANCPRelocationIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RANCPRelocationIndication_protocolIEs (OSCTXT* pctxt, RANCPRelocationIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANCPRelocationIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RANCPRelocationIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RANCPRelocationIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RANCPRelocationIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RANCPRelocationIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANCPRelocationIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RANCPRelocationIndication (OSCTXT* pctxt, RANCPRelocationIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANCPRelocationIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_RANCPRelocationIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RANCPRelocationIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANCPRelocationIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverRequired_protocolIEs_element (OSCTXT* pctxt, HandoverRequired_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _HandoverRequiredIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverRequiredIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequiredIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverRequiredIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequiredIEs_id_HandoverType */
      case ASN1V_id_HandoverType:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_HandoverType;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_HandoverType");

         stat = asn1PD_HandoverType (pctxt, &pvalue->value.
            u._HandoverRequiredIEs_id_HandoverType);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequiredIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_Cause");

         pvalue->value.u._HandoverRequiredIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._HandoverRequiredIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.u._HandoverRequiredIEs_id_Cause
            );

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._HandoverRequiredIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequiredIEs_id_TargetID */
      case ASN1V_id_TargetID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_TargetID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_TargetID");

         pvalue->value.u._HandoverRequiredIEs_id_TargetID
             = rtxMemAllocType (pctxt, TargetID);

         if (pvalue->value.u._HandoverRequiredIEs_id_TargetID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TargetID ((TargetID*)pvalue->value.
            u._HandoverRequiredIEs_id_TargetID);

         stat = asn1PD_TargetID (pctxt, (TargetID*)pvalue->value.
            u._HandoverRequiredIEs_id_TargetID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequiredIEs_id_DirectForwardingPathAvailability */
      case ASN1V_id_DirectForwardingPathAvailability:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_DirectForwardingPathAvailability;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_DirectForwardingPathAvailability");

         stat = asn1PD_DirectForwardingPathAvailability (pctxt, &pvalue->value.
            u._HandoverRequiredIEs_id_DirectForwardingPathAvailability);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequiredIEs_id_PDUSessionResourceListHORqd */
      case ASN1V_id_PDUSessionResourceListHORqd:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_PDUSessionResourceListHORqd;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_PDUSessionResourceListHORqd");

         pvalue->value.u._HandoverRequiredIEs_id_PDUSessionResourceListHORqd
             = rtxMemAllocType (pctxt, PDUSessionResourceListHORqd);

         if (pvalue->value.
            u._HandoverRequiredIEs_id_PDUSessionResourceListHORqd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceListHORqd (pvalue->value.
            u._HandoverRequiredIEs_id_PDUSessionResourceListHORqd);

         stat = asn1PD_PDUSessionResourceListHORqd (pctxt, pvalue->value.
            u._HandoverRequiredIEs_id_PDUSessionResourceListHORqd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequiredIEs_id_SourceToTarget_TransparentContainer */
      case ASN1V_id_SourceToTarget_TransparentContainer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_SourceToTarget_TransparentContainer;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_SourceToTarget_TransparentContainer");

         pvalue->value.
            u._HandoverRequiredIEs_id_SourceToTarget_TransparentContainer
             = rtxMemAllocType (pctxt, SourceToTarget_TransparentContainer);

         if (pvalue->value.
            u._HandoverRequiredIEs_id_SourceToTarget_TransparentContainer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SourceToTarget_TransparentContainer (pvalue->value.
            u._HandoverRequiredIEs_id_SourceToTarget_TransparentContainer);

         stat = asn1PD_SourceToTarget_TransparentContainer (pctxt, pvalue->
            value.u._HandoverRequiredIEs_id_SourceToTarget_TransparentContainer
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequiredIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequired_protocolIEs (OSCTXT* pctxt, HandoverRequired_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverRequired_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverRequired_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverRequired_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverRequired_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequired (OSCTXT* pctxt, HandoverRequired* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequired");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverRequired_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCommand_protocolIEs_element (OSCTXT* pctxt, HandoverCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _HandoverCommandIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverCommandIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCommandIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverCommandIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCommandIEs_id_HandoverType */
      case ASN1V_id_HandoverType:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_HandoverType;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_HandoverType");

         stat = asn1PD_HandoverType (pctxt, &pvalue->value.
            u._HandoverCommandIEs_id_HandoverType);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCommandIEs_id_NASSecurityParametersFromNGRAN */
      case ASN1V_id_NASSecurityParametersFromNGRAN:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_NASSecurityParametersFromNGRAN;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_NASSecurityParametersFromNGRAN");

         pvalue->value.u._HandoverCommandIEs_id_NASSecurityParametersFromNGRAN
             = rtxMemAllocType (pctxt, NASSecurityParametersFromNGRAN);

         if (pvalue->value.
            u._HandoverCommandIEs_id_NASSecurityParametersFromNGRAN == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NASSecurityParametersFromNGRAN (pvalue->value.
            u._HandoverCommandIEs_id_NASSecurityParametersFromNGRAN);

         stat = asn1PD_NASSecurityParametersFromNGRAN (pctxt, pvalue->value.
            u._HandoverCommandIEs_id_NASSecurityParametersFromNGRAN);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCommandIEs_id_PDUSessionResourceHandoverList */
      case ASN1V_id_PDUSessionResourceHandoverList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_PDUSessionResourceHandoverList;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_PDUSessionResourceHandoverList");

         pvalue->value.u._HandoverCommandIEs_id_PDUSessionResourceHandoverList
             = rtxMemAllocType (pctxt, PDUSessionResourceHandoverList);

         if (pvalue->value.
            u._HandoverCommandIEs_id_PDUSessionResourceHandoverList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceHandoverList (pvalue->value.
            u._HandoverCommandIEs_id_PDUSessionResourceHandoverList);

         stat = asn1PD_PDUSessionResourceHandoverList (pctxt, pvalue->value.
            u._HandoverCommandIEs_id_PDUSessionResourceHandoverList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd */
      case ASN1V_id_PDUSessionResourceToReleaseListHOCmd:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd");

         pvalue->value.
            u._HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd
             = rtxMemAllocType (pctxt, PDUSessionResourceToReleaseListHOCmd);

         if (pvalue->value.
            u._HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceToReleaseListHOCmd (pvalue->value.
            u._HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd);

         stat = asn1PD_PDUSessionResourceToReleaseListHOCmd (pctxt, pvalue->
            value.u._HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCommandIEs_id_TargetToSource_TransparentContainer */
      case ASN1V_id_TargetToSource_TransparentContainer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_TargetToSource_TransparentContainer;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_TargetToSource_TransparentContainer");

         pvalue->value.
            u._HandoverCommandIEs_id_TargetToSource_TransparentContainer
             = rtxMemAllocType (pctxt, TargetToSource_TransparentContainer);

         if (pvalue->value.
            u._HandoverCommandIEs_id_TargetToSource_TransparentContainer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TargetToSource_TransparentContainer (pvalue->value.
            u._HandoverCommandIEs_id_TargetToSource_TransparentContainer);

         stat = asn1PD_TargetToSource_TransparentContainer (pctxt, pvalue->
            value.u._HandoverCommandIEs_id_TargetToSource_TransparentContainer
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCommandIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_CriticalityDiagnostics");

         pvalue->value.u._HandoverCommandIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.u._HandoverCommandIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._HandoverCommandIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.u._HandoverCommandIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverCommandIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCommand_protocolIEs (OSCTXT* pctxt, HandoverCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverCommand_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverCommand_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverCommand_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCommand (OSCTXT* pctxt, HandoverCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCommand");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationFailure_protocolIEs_element (OSCTXT* pctxt, HandoverPreparationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverPreparationFailureIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_Cause");

         pvalue->value.u._HandoverPreparationFailureIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._HandoverPreparationFailureIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._HandoverPreparationFailureIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._HandoverPreparationFailureIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverPreparationFailureIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._HandoverPreparationFailureIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._HandoverPreparationFailureIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._HandoverPreparationFailureIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._HandoverPreparationFailureIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverPreparationFailureIEs_id_TargettoSource_Failure_TransparentContainer */
      case ASN1V_id_TargettoSource_Failure_TransparentContainer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_TargettoSource_Failure_TransparentContainer;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_TargettoSource_Failure_TransparentContainer");

         pvalue->value.
            u._HandoverPreparationFailureIEs_id_TargettoSource_Failure_TransparentContainer
             = rtxMemAllocType (pctxt, 
            TargettoSource_Failure_TransparentContainer);

         if (pvalue->value.
            u._HandoverPreparationFailureIEs_id_TargettoSource_Failure_TransparentContainer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TargettoSource_Failure_TransparentContainer (pvalue->value.
            u._HandoverPreparationFailureIEs_id_TargettoSource_Failure_TransparentContainer
            );

         stat = asn1PD_TargettoSource_Failure_TransparentContainer (pctxt, 
            pvalue->value.
            u._HandoverPreparationFailureIEs_id_TargettoSource_Failure_TransparentContainer
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationFailure_protocolIEs (OSCTXT* pctxt, HandoverPreparationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverPreparationFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverPreparationFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverPreparationFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverPreparationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationFailure (OSCTXT* pctxt, HandoverPreparationFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverPreparationFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverPreparationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverRequest_protocolIEs_element (OSCTXT* pctxt, HandoverRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _HandoverRequestIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverRequestIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_HandoverType */
      case ASN1V_id_HandoverType:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_HandoverType;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_HandoverType");

         stat = asn1PD_HandoverType (pctxt, &pvalue->value.
            u._HandoverRequestIEs_id_HandoverType);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_Cause");

         pvalue->value.u._HandoverRequestIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._HandoverRequestIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.u._HandoverRequestIEs_id_Cause
            );

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._HandoverRequestIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_UEAggregateMaximumBitRate */
      case ASN1V_id_UEAggregateMaximumBitRate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_UEAggregateMaximumBitRate;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_UEAggregateMaximumBitRate");

         pvalue->value.u._HandoverRequestIEs_id_UEAggregateMaximumBitRate
             = rtxMemAllocType (pctxt, UEAggregateMaximumBitRate);

         if (pvalue->value.u._HandoverRequestIEs_id_UEAggregateMaximumBitRate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEAggregateMaximumBitRate ((UEAggregateMaximumBitRate*)pvalue
            ->value.u._HandoverRequestIEs_id_UEAggregateMaximumBitRate);

         stat = asn1PD_UEAggregateMaximumBitRate (pctxt, 
            (UEAggregateMaximumBitRate*)pvalue->value.
            u._HandoverRequestIEs_id_UEAggregateMaximumBitRate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive */
      case ASN1V_id_CoreNetworkAssistanceInformationForInactive:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive");

         pvalue->value.
            u._HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive
             = rtxMemAllocType (pctxt, 
            CoreNetworkAssistanceInformationForInactive);

         if (pvalue->value.
            u._HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CoreNetworkAssistanceInformationForInactive (
            (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
            u._HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive
            );

         stat = asn1PD_CoreNetworkAssistanceInformationForInactive (pctxt, 
            (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
            u._HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_UESecurityCapabilities */
      case ASN1V_id_UESecurityCapabilities:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_UESecurityCapabilities;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_UESecurityCapabilities");

         pvalue->value.u._HandoverRequestIEs_id_UESecurityCapabilities
             = rtxMemAllocType (pctxt, UESecurityCapabilities);

         if (pvalue->value.u._HandoverRequestIEs_id_UESecurityCapabilities
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UESecurityCapabilities ((UESecurityCapabilities*)pvalue->
            value.u._HandoverRequestIEs_id_UESecurityCapabilities);

         stat = asn1PD_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)
            pvalue->value.u._HandoverRequestIEs_id_UESecurityCapabilities);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_SecurityContext */
      case ASN1V_id_SecurityContext:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_SecurityContext;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_SecurityContext");

         pvalue->value.u._HandoverRequestIEs_id_SecurityContext
             = rtxMemAllocType (pctxt, SecurityContext);

         if (pvalue->value.u._HandoverRequestIEs_id_SecurityContext == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityContext ((SecurityContext*)pvalue->value.
            u._HandoverRequestIEs_id_SecurityContext);

         stat = asn1PD_SecurityContext (pctxt, (SecurityContext*)pvalue->value.
            u._HandoverRequestIEs_id_SecurityContext);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_NewSecurityContextInd */
      case ASN1V_id_NewSecurityContextInd:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_NewSecurityContextInd;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_NewSecurityContextInd");

         stat = asn1PD_NewSecurityContextInd (pctxt, &pvalue->value.
            u._HandoverRequestIEs_id_NewSecurityContextInd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_NASC */
      case ASN1V_id_NASC:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_NASC;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_NASC");

         pvalue->value.u._HandoverRequestIEs_id_NASC = rtxMemAllocType (pctxt, 
            NAS_PDU);

         if (pvalue->value.u._HandoverRequestIEs_id_NASC == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NAS_PDU (pvalue->value.u._HandoverRequestIEs_id_NASC);

         stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
            u._HandoverRequestIEs_id_NASC);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq */
      case ASN1V_id_PDUSessionResourceSetupListHOReq:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq");

         pvalue->value.
            u._HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq
             = rtxMemAllocType (pctxt, PDUSessionResourceSetupListHOReq);

         if (pvalue->value.
            u._HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceSetupListHOReq (pvalue->value.
            u._HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq);

         stat = asn1PD_PDUSessionResourceSetupListHOReq (pctxt, pvalue->value.
            u._HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_AllowedNSSAI */
      case ASN1V_id_AllowedNSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_AllowedNSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_AllowedNSSAI");

         pvalue->value.u._HandoverRequestIEs_id_AllowedNSSAI
             = rtxMemAllocType (pctxt, AllowedNSSAI);

         if (pvalue->value.u._HandoverRequestIEs_id_AllowedNSSAI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AllowedNSSAI (pvalue->value.
            u._HandoverRequestIEs_id_AllowedNSSAI);

         stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
            u._HandoverRequestIEs_id_AllowedNSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_TraceActivation */
      case ASN1V_id_TraceActivation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_TraceActivation;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_TraceActivation");

         pvalue->value.u._HandoverRequestIEs_id_TraceActivation
             = rtxMemAllocType (pctxt, TraceActivation);

         if (pvalue->value.u._HandoverRequestIEs_id_TraceActivation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TraceActivation ((TraceActivation*)pvalue->value.
            u._HandoverRequestIEs_id_TraceActivation);

         stat = asn1PD_TraceActivation (pctxt, (TraceActivation*)pvalue->value.
            u._HandoverRequestIEs_id_TraceActivation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_MaskedIMEISV */
      case ASN1V_id_MaskedIMEISV:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_MaskedIMEISV;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_MaskedIMEISV");

         pvalue->value.u._HandoverRequestIEs_id_MaskedIMEISV
             = rtxMemAllocTypeZ (pctxt, MaskedIMEISV);

         if (pvalue->value.u._HandoverRequestIEs_id_MaskedIMEISV == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MaskedIMEISV (pctxt, (MaskedIMEISV*)pvalue->value.
            u._HandoverRequestIEs_id_MaskedIMEISV);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_SourceToTarget_TransparentContainer */
      case ASN1V_id_SourceToTarget_TransparentContainer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_SourceToTarget_TransparentContainer;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_SourceToTarget_TransparentContainer");

         pvalue->value.
            u._HandoverRequestIEs_id_SourceToTarget_TransparentContainer
             = rtxMemAllocType (pctxt, SourceToTarget_TransparentContainer);

         if (pvalue->value.
            u._HandoverRequestIEs_id_SourceToTarget_TransparentContainer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SourceToTarget_TransparentContainer (pvalue->value.
            u._HandoverRequestIEs_id_SourceToTarget_TransparentContainer);

         stat = asn1PD_SourceToTarget_TransparentContainer (pctxt, pvalue->
            value.u._HandoverRequestIEs_id_SourceToTarget_TransparentContainer
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_MobilityRestrictionList */
      case ASN1V_id_MobilityRestrictionList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_MobilityRestrictionList;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_MobilityRestrictionList");

         pvalue->value.u._HandoverRequestIEs_id_MobilityRestrictionList
             = rtxMemAllocType (pctxt, MobilityRestrictionList);

         if (pvalue->value.u._HandoverRequestIEs_id_MobilityRestrictionList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MobilityRestrictionList ((MobilityRestrictionList*)pvalue->
            value.u._HandoverRequestIEs_id_MobilityRestrictionList);

         stat = asn1PD_MobilityRestrictionList (pctxt, 
            (MobilityRestrictionList*)pvalue->value.
            u._HandoverRequestIEs_id_MobilityRestrictionList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_LocationReportingRequestType */
      case ASN1V_id_LocationReportingRequestType:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_LocationReportingRequestType;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_LocationReportingRequestType");

         pvalue->value.u._HandoverRequestIEs_id_LocationReportingRequestType
             = rtxMemAllocType (pctxt, LocationReportingRequestType);

         if (pvalue->value.
            u._HandoverRequestIEs_id_LocationReportingRequestType == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LocationReportingRequestType ((LocationReportingRequestType*)
            pvalue->value.u._HandoverRequestIEs_id_LocationReportingRequestType
            );

         stat = asn1PD_LocationReportingRequestType (pctxt, 
            (LocationReportingRequestType*)pvalue->value.
            u._HandoverRequestIEs_id_LocationReportingRequestType);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_RRCInactiveTransitionReportRequest */
      case ASN1V_id_RRCInactiveTransitionReportRequest:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_RRCInactiveTransitionReportRequest;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_RRCInactiveTransitionReportRequest");

         stat = asn1PD_RRCInactiveTransitionReportRequest (pctxt, &pvalue->
            value.u._HandoverRequestIEs_id_RRCInactiveTransitionReportRequest
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_GUAMI */
      case ASN1V_id_GUAMI:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_GUAMI;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_GUAMI");

         pvalue->value.u._HandoverRequestIEs_id_GUAMI
             = rtxMemAllocType (pctxt, GUAMI);

         if (pvalue->value.u._HandoverRequestIEs_id_GUAMI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GUAMI ((GUAMI*)pvalue->value.u._HandoverRequestIEs_id_GUAMI
            );

         stat = asn1PD_GUAMI (pctxt, (GUAMI*)pvalue->value.
            u._HandoverRequestIEs_id_GUAMI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_RedirectionVoiceFallback */
      case ASN1V_id_RedirectionVoiceFallback:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_RedirectionVoiceFallback;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_RedirectionVoiceFallback");

         stat = asn1PD_RedirectionVoiceFallback (pctxt, &pvalue->value.
            u._HandoverRequestIEs_id_RedirectionVoiceFallback);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_CNAssistedRANTuning */
      case ASN1V_id_CNAssistedRANTuning:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_CNAssistedRANTuning;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_CNAssistedRANTuning");

         pvalue->value.u._HandoverRequestIEs_id_CNAssistedRANTuning
             = rtxMemAllocType (pctxt, CNAssistedRANTuning);

         if (pvalue->value.u._HandoverRequestIEs_id_CNAssistedRANTuning
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CNAssistedRANTuning ((CNAssistedRANTuning*)pvalue->value.
            u._HandoverRequestIEs_id_CNAssistedRANTuning);

         stat = asn1PD_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue
            ->value.u._HandoverRequestIEs_id_CNAssistedRANTuning);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_SRVCCOperationPossible */
      case ASN1V_id_SRVCCOperationPossible:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_SRVCCOperationPossible;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_SRVCCOperationPossible");

         stat = asn1PD_SRVCCOperationPossible (pctxt, &pvalue->value.
            u._HandoverRequestIEs_id_SRVCCOperationPossible);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_IAB_Authorized */
      case ASN1V_id_IAB_Authorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_IAB_Authorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_IAB_Authorized");

         stat = asn1PD_IAB_Authorized (pctxt, &pvalue->value.
            u._HandoverRequestIEs_id_IAB_Authorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_Enhanced_CoverageRestriction */
      case ASN1V_id_Enhanced_CoverageRestriction:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_Enhanced_CoverageRestriction;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_Enhanced_CoverageRestriction");

         stat = asn1PD_Enhanced_CoverageRestriction (pctxt, &pvalue->value.
            u._HandoverRequestIEs_id_Enhanced_CoverageRestriction);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_UE_DifferentiationInfo */
      case ASN1V_id_UE_DifferentiationInfo:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_UE_DifferentiationInfo;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_UE_DifferentiationInfo");

         pvalue->value.u._HandoverRequestIEs_id_UE_DifferentiationInfo
             = rtxMemAllocType (pctxt, UE_DifferentiationInfo);

         if (pvalue->value.u._HandoverRequestIEs_id_UE_DifferentiationInfo
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_DifferentiationInfo ((UE_DifferentiationInfo*)pvalue->
            value.u._HandoverRequestIEs_id_UE_DifferentiationInfo);

         stat = asn1PD_UE_DifferentiationInfo (pctxt, (UE_DifferentiationInfo*)
            pvalue->value.u._HandoverRequestIEs_id_UE_DifferentiationInfo);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_NRV2XServicesAuthorized */
      case ASN1V_id_NRV2XServicesAuthorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_NRV2XServicesAuthorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_NRV2XServicesAuthorized");

         pvalue->value.u._HandoverRequestIEs_id_NRV2XServicesAuthorized
             = rtxMemAllocType (pctxt, NRV2XServicesAuthorized);

         if (pvalue->value.u._HandoverRequestIEs_id_NRV2XServicesAuthorized
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRV2XServicesAuthorized ((NRV2XServicesAuthorized*)pvalue->
            value.u._HandoverRequestIEs_id_NRV2XServicesAuthorized);

         stat = asn1PD_NRV2XServicesAuthorized (pctxt, 
            (NRV2XServicesAuthorized*)pvalue->value.
            u._HandoverRequestIEs_id_NRV2XServicesAuthorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_LTEV2XServicesAuthorized */
      case ASN1V_id_LTEV2XServicesAuthorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_LTEV2XServicesAuthorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_LTEV2XServicesAuthorized");

         pvalue->value.u._HandoverRequestIEs_id_LTEV2XServicesAuthorized
             = rtxMemAllocType (pctxt, LTEV2XServicesAuthorized);

         if (pvalue->value.u._HandoverRequestIEs_id_LTEV2XServicesAuthorized
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LTEV2XServicesAuthorized ((LTEV2XServicesAuthorized*)pvalue->
            value.u._HandoverRequestIEs_id_LTEV2XServicesAuthorized);

         stat = asn1PD_LTEV2XServicesAuthorized (pctxt, 
            (LTEV2XServicesAuthorized*)pvalue->value.
            u._HandoverRequestIEs_id_LTEV2XServicesAuthorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_NRUESidelinkAggregateMaximumBitrate */
      case ASN1V_id_NRUESidelinkAggregateMaximumBitrate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_NRUESidelinkAggregateMaximumBitrate;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_NRUESidelinkAggregateMaximumBitrate");

         pvalue->value.
            u._HandoverRequestIEs_id_NRUESidelinkAggregateMaximumBitrate
             = rtxMemAllocType (pctxt, NRUESidelinkAggregateMaximumBitrate);

         if (pvalue->value.
            u._HandoverRequestIEs_id_NRUESidelinkAggregateMaximumBitrate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRUESidelinkAggregateMaximumBitrate (
            (NRUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._HandoverRequestIEs_id_NRUESidelinkAggregateMaximumBitrate);

         stat = asn1PD_NRUESidelinkAggregateMaximumBitrate (pctxt, 
            (NRUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._HandoverRequestIEs_id_NRUESidelinkAggregateMaximumBitrate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate */
      case ASN1V_id_LTEUESidelinkAggregateMaximumBitrate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate");

         pvalue->value.
            u._HandoverRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate
             = rtxMemAllocType (pctxt, LTEUESidelinkAggregateMaximumBitrate);

         if (pvalue->value.
            u._HandoverRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LTEUESidelinkAggregateMaximumBitrate (
            (LTEUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._HandoverRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate);

         stat = asn1PD_LTEUESidelinkAggregateMaximumBitrate (pctxt, 
            (LTEUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._HandoverRequestIEs_id_LTEUESidelinkAggregateMaximumBitrate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_PC5QoSParameters */
      case ASN1V_id_PC5QoSParameters:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_PC5QoSParameters;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_PC5QoSParameters");

         pvalue->value.u._HandoverRequestIEs_id_PC5QoSParameters
             = rtxMemAllocType (pctxt, PC5QoSParameters);

         if (pvalue->value.u._HandoverRequestIEs_id_PC5QoSParameters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PC5QoSParameters ((PC5QoSParameters*)pvalue->value.
            u._HandoverRequestIEs_id_PC5QoSParameters);

         stat = asn1PD_PC5QoSParameters (pctxt, (PC5QoSParameters*)pvalue->
            value.u._HandoverRequestIEs_id_PC5QoSParameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_CEmodeBrestricted */
      case ASN1V_id_CEmodeBrestricted:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_CEmodeBrestricted;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_CEmodeBrestricted");

         stat = asn1PD_CEmodeBrestricted (pctxt, &pvalue->value.
            u._HandoverRequestIEs_id_CEmodeBrestricted);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_UE_UP_CIoT_Support */
      case ASN1V_id_UE_UP_CIoT_Support:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_UE_UP_CIoT_Support;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_UE_UP_CIoT_Support");

         stat = asn1PD_UE_UP_CIoT_Support (pctxt, &pvalue->value.
            u._HandoverRequestIEs_id_UE_UP_CIoT_Support);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_ManagementBasedMDTPLMNList */
      case ASN1V_id_ManagementBasedMDTPLMNList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_ManagementBasedMDTPLMNList;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_ManagementBasedMDTPLMNList");

         pvalue->value.u._HandoverRequestIEs_id_ManagementBasedMDTPLMNList
             = rtxMemAllocType (pctxt, MDTPLMNList);

         if (pvalue->value.u._HandoverRequestIEs_id_ManagementBasedMDTPLMNList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MDTPLMNList ((MDTPLMNList*)pvalue->value.
            u._HandoverRequestIEs_id_ManagementBasedMDTPLMNList);

         stat = asn1PD_MDTPLMNList (pctxt, (MDTPLMNList*)pvalue->value.
            u._HandoverRequestIEs_id_ManagementBasedMDTPLMNList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_UERadioCapabilityID */
      case ASN1V_id_UERadioCapabilityID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_UERadioCapabilityID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_UERadioCapabilityID");

         pvalue->value.u._HandoverRequestIEs_id_UERadioCapabilityID
             = rtxMemAllocType (pctxt, UERadioCapabilityID);

         if (pvalue->value.u._HandoverRequestIEs_id_UERadioCapabilityID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityID (pvalue->value.
            u._HandoverRequestIEs_id_UERadioCapabilityID);

         stat = asn1PD_UERadioCapabilityID (pctxt, pvalue->value.
            u._HandoverRequestIEs_id_UERadioCapabilityID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestIEs_id_Extended_ConnectedTime */
      case ASN1V_id_Extended_ConnectedTime:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_Extended_ConnectedTime;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_Extended_ConnectedTime");

         stat = asn1PD_Extended_ConnectedTime (pctxt, &pvalue->value.
            u._HandoverRequestIEs_id_Extended_ConnectedTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequest_protocolIEs (OSCTXT* pctxt, HandoverRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequest (OSCTXT* pctxt, HandoverRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverRequestAcknowledge_protocolIEs_element (OSCTXT* pctxt, HandoverRequestAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList */
      case ASN1V_id_PDUSessionResourceAdmittedList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList");

         pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList
             = rtxMemAllocType (pctxt, PDUSessionResourceAdmittedList);

         if (pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceAdmittedList (pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList
            );

         stat = asn1PD_PDUSessionResourceAdmittedList (pctxt, pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck */
      case ASN1V_id_PDUSessionResourceFailedToSetupListHOAck:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck");

         pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck
             = rtxMemAllocType (pctxt, 
            PDUSessionResourceFailedToSetupListHOAck);

         if (pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceFailedToSetupListHOAck (pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck
            );

         stat = asn1PD_PDUSessionResourceFailedToSetupListHOAck (pctxt, pvalue
            ->value.
            u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer */
      case ASN1V_id_TargetToSource_TransparentContainer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer");

         pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer
             = rtxMemAllocType (pctxt, TargetToSource_TransparentContainer);

         if (pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TargetToSource_TransparentContainer (pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer
            );

         stat = asn1PD_TargetToSource_TransparentContainer (pctxt, pvalue->
            value.
            u._HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequestAcknowledge_protocolIEs (OSCTXT* pctxt, HandoverRequestAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverRequestAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverRequestAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverRequestAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverRequestAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequestAcknowledge (OSCTXT* pctxt, HandoverRequestAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequestAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverRequestAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFailure_protocolIEs_element (OSCTXT* pctxt, HandoverFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _HandoverFailureIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverFailureIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverFailureIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverFailureIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverFailureIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverFailureIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverFailureIEs_id_Cause");

         pvalue->value.u._HandoverFailureIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._HandoverFailureIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.u._HandoverFailureIEs_id_Cause
            );

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._HandoverFailureIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverFailureIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverFailureIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverFailureIEs_id_CriticalityDiagnostics");

         pvalue->value.u._HandoverFailureIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.u._HandoverFailureIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._HandoverFailureIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.u._HandoverFailureIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverFailureIEs_id_TargettoSource_Failure_TransparentContainer */
      case ASN1V_id_TargettoSource_Failure_TransparentContainer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverFailureIEs_id_TargettoSource_Failure_TransparentContainer;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverFailureIEs_id_TargettoSource_Failure_TransparentContainer");

         pvalue->value.
            u._HandoverFailureIEs_id_TargettoSource_Failure_TransparentContainer
             = rtxMemAllocType (pctxt, 
            TargettoSource_Failure_TransparentContainer);

         if (pvalue->value.
            u._HandoverFailureIEs_id_TargettoSource_Failure_TransparentContainer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TargettoSource_Failure_TransparentContainer (pvalue->value.
            u._HandoverFailureIEs_id_TargettoSource_Failure_TransparentContainer
            );

         stat = asn1PD_TargettoSource_Failure_TransparentContainer (pctxt, 
            pvalue->value.
            u._HandoverFailureIEs_id_TargettoSource_Failure_TransparentContainer
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverFailureIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverFailure_protocolIEs (OSCTXT* pctxt, HandoverFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverFailure (OSCTXT* pctxt, HandoverFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverNotify_protocolIEs_element (OSCTXT* pctxt, HandoverNotify_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _HandoverNotifyIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverNotifyIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverNotifyIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverNotifyIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverNotifyIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverNotifyIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverNotifyIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverNotifyIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverNotifyIEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverNotifyIEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverNotifyIEs_id_UserLocationInformation");

         pvalue->value.u._HandoverNotifyIEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.u._HandoverNotifyIEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.u._HandoverNotifyIEs_id_UserLocationInformation);

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._HandoverNotifyIEs_id_UserLocationInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverNotifyIEs_id_NotifySourceNGRANNode */
      case ASN1V_id_NotifySourceNGRANNode:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverNotifyIEs_id_NotifySourceNGRANNode;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverNotifyIEs_id_NotifySourceNGRANNode");

         stat = asn1PD_NotifySourceNGRANNode (pctxt, &pvalue->value.
            u._HandoverNotifyIEs_id_NotifySourceNGRANNode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverNotifyIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverNotify_protocolIEs (OSCTXT* pctxt, HandoverNotify_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverNotify_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverNotify_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverNotify_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverNotify_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverNotify (OSCTXT* pctxt, HandoverNotify* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverNotify");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverNotify_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequest_protocolIEs_element (OSCTXT* pctxt, PathSwitchRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PathSwitchRequestIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PathSwitchRequestIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID */
      case ASN1V_id_SourceAMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestIEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_UserLocationInformation");

         pvalue->value.u._PathSwitchRequestIEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.u._PathSwitchRequestIEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.u._PathSwitchRequestIEs_id_UserLocationInformation);

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._PathSwitchRequestIEs_id_UserLocationInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestIEs_id_UESecurityCapabilities */
      case ASN1V_id_UESecurityCapabilities:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_UESecurityCapabilities;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_UESecurityCapabilities");

         pvalue->value.u._PathSwitchRequestIEs_id_UESecurityCapabilities
             = rtxMemAllocType (pctxt, UESecurityCapabilities);

         if (pvalue->value.u._PathSwitchRequestIEs_id_UESecurityCapabilities
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UESecurityCapabilities ((UESecurityCapabilities*)pvalue->
            value.u._PathSwitchRequestIEs_id_UESecurityCapabilities);

         stat = asn1PD_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)
            pvalue->value.u._PathSwitchRequestIEs_id_UESecurityCapabilities);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList */
      case ASN1V_id_PDUSessionResourceToBeSwitchedDLList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList");

         pvalue->value.
            u._PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList
             = rtxMemAllocType (pctxt, PDUSessionResourceToBeSwitchedDLList);

         if (pvalue->value.
            u._PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceToBeSwitchedDLList (pvalue->value.
            u._PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList);

         stat = asn1PD_PDUSessionResourceToBeSwitchedDLList (pctxt, pvalue->
            value.
            u._PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq */
      case ASN1V_id_PDUSessionResourceFailedToSetupListPSReq:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq");

         pvalue->value.
            u._PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq
             = rtxMemAllocType (pctxt, 
            PDUSessionResourceFailedToSetupListPSReq);

         if (pvalue->value.
            u._PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceFailedToSetupListPSReq (pvalue->value.
            u._PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq
            );

         stat = asn1PD_PDUSessionResourceFailedToSetupListPSReq (pctxt, pvalue
            ->value.
            u._PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestIEs_id_RRC_Resume_Cause */
      case ASN1V_id_RRC_Resume_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_RRC_Resume_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_RRC_Resume_Cause");

         stat = asn1PD_RRCEstablishmentCause (pctxt, &pvalue->value.
            u._PathSwitchRequestIEs_id_RRC_Resume_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequest_protocolIEs (OSCTXT* pctxt, PathSwitchRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathSwitchRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PathSwitchRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PathSwitchRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathSwitchRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequest (OSCTXT* pctxt, PathSwitchRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PathSwitchRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestAcknowledge_protocolIEs_element (OSCTXT* pctxt, PathSwitchRequestAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities */
      case ASN1V_id_UESecurityCapabilities:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities
             = rtxMemAllocType (pctxt, UESecurityCapabilities);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UESecurityCapabilities ((UESecurityCapabilities*)pvalue->
            value.u._PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities
            );

         stat = asn1PD_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)
            pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_SecurityContext */
      case ASN1V_id_SecurityContext:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_SecurityContext;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_SecurityContext");

         pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_SecurityContext
             = rtxMemAllocType (pctxt, SecurityContext);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_SecurityContext == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SecurityContext ((SecurityContext*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_SecurityContext);

         stat = asn1PD_SecurityContext (pctxt, (SecurityContext*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_SecurityContext);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd */
      case ASN1V_id_NewSecurityContextInd:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd");

         stat = asn1PD_NewSecurityContextInd (pctxt, &pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList */
      case ASN1V_id_PDUSessionResourceSwitchedList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList
             = rtxMemAllocType (pctxt, PDUSessionResourceSwitchedList);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceSwitchedList (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList
            );

         stat = asn1PD_PDUSessionResourceSwitchedList (pctxt, pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck */
      case ASN1V_id_PDUSessionResourceReleasedListPSAck:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck
             = rtxMemAllocType (pctxt, PDUSessionResourceReleasedListPSAck);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceReleasedListPSAck (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck
            );

         stat = asn1PD_PDUSessionResourceReleasedListPSAck (pctxt, pvalue->
            value.
            u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI */
      case ASN1V_id_AllowedNSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI");

         pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI
             = rtxMemAllocType (pctxt, AllowedNSSAI);

         if (pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AllowedNSSAI (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI);

         stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive */
      case ASN1V_id_CoreNetworkAssistanceInformationForInactive:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive
             = rtxMemAllocType (pctxt, 
            CoreNetworkAssistanceInformationForInactive);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CoreNetworkAssistanceInformationForInactive (
            (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive
            );

         stat = asn1PD_CoreNetworkAssistanceInformationForInactive (pctxt, 
            (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest */
      case ASN1V_id_RRCInactiveTransitionReportRequest:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest");

         stat = asn1PD_RRCInactiveTransitionReportRequest (pctxt, &pvalue->
            value.
            u._PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback */
      case ASN1V_id_RedirectionVoiceFallback:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback");

         stat = asn1PD_RedirectionVoiceFallback (pctxt, &pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning */
      case ASN1V_id_CNAssistedRANTuning:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning
             = rtxMemAllocType (pctxt, CNAssistedRANTuning);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CNAssistedRANTuning ((CNAssistedRANTuning*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning);

         stat = asn1PD_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue
            ->value.u._PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_SRVCCOperationPossible */
      case ASN1V_id_SRVCCOperationPossible:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_SRVCCOperationPossible;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_SRVCCOperationPossible");

         stat = asn1PD_SRVCCOperationPossible (pctxt, &pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_SRVCCOperationPossible);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_Enhanced_CoverageRestriction */
      case ASN1V_id_Enhanced_CoverageRestriction:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_Enhanced_CoverageRestriction;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_Enhanced_CoverageRestriction");

         stat = asn1PD_Enhanced_CoverageRestriction (pctxt, &pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_Enhanced_CoverageRestriction
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_Extended_ConnectedTime */
      case ASN1V_id_Extended_ConnectedTime:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_Extended_ConnectedTime;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_Extended_ConnectedTime");

         stat = asn1PD_Extended_ConnectedTime (pctxt, &pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_Extended_ConnectedTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_UE_DifferentiationInfo */
      case ASN1V_id_UE_DifferentiationInfo:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_UE_DifferentiationInfo;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_UE_DifferentiationInfo");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UE_DifferentiationInfo
             = rtxMemAllocType (pctxt, UE_DifferentiationInfo);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UE_DifferentiationInfo
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_DifferentiationInfo ((UE_DifferentiationInfo*)pvalue->
            value.u._PathSwitchRequestAcknowledgeIEs_id_UE_DifferentiationInfo
            );

         stat = asn1PD_UE_DifferentiationInfo (pctxt, (UE_DifferentiationInfo*)
            pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UE_DifferentiationInfo);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_NRV2XServicesAuthorized */
      case ASN1V_id_NRV2XServicesAuthorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_NRV2XServicesAuthorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_NRV2XServicesAuthorized");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_NRV2XServicesAuthorized
             = rtxMemAllocType (pctxt, NRV2XServicesAuthorized);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_NRV2XServicesAuthorized
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRV2XServicesAuthorized ((NRV2XServicesAuthorized*)pvalue->
            value.u._PathSwitchRequestAcknowledgeIEs_id_NRV2XServicesAuthorized
            );

         stat = asn1PD_NRV2XServicesAuthorized (pctxt, 
            (NRV2XServicesAuthorized*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_NRV2XServicesAuthorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_LTEV2XServicesAuthorized */
      case ASN1V_id_LTEV2XServicesAuthorized:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_LTEV2XServicesAuthorized;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_LTEV2XServicesAuthorized");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_LTEV2XServicesAuthorized
             = rtxMemAllocType (pctxt, LTEV2XServicesAuthorized);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_LTEV2XServicesAuthorized
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LTEV2XServicesAuthorized ((LTEV2XServicesAuthorized*)pvalue->
            value.
            u._PathSwitchRequestAcknowledgeIEs_id_LTEV2XServicesAuthorized);

         stat = asn1PD_LTEV2XServicesAuthorized (pctxt, 
            (LTEV2XServicesAuthorized*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_LTEV2XServicesAuthorized);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_NRUESidelinkAggregateMaximumBitrate */
      case ASN1V_id_NRUESidelinkAggregateMaximumBitrate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_NRUESidelinkAggregateMaximumBitrate;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_NRUESidelinkAggregateMaximumBitrate");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_NRUESidelinkAggregateMaximumBitrate
             = rtxMemAllocType (pctxt, NRUESidelinkAggregateMaximumBitrate);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_NRUESidelinkAggregateMaximumBitrate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRUESidelinkAggregateMaximumBitrate (
            (NRUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_NRUESidelinkAggregateMaximumBitrate
            );

         stat = asn1PD_NRUESidelinkAggregateMaximumBitrate (pctxt, 
            (NRUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_NRUESidelinkAggregateMaximumBitrate
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_LTEUESidelinkAggregateMaximumBitrate */
      case ASN1V_id_LTEUESidelinkAggregateMaximumBitrate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_LTEUESidelinkAggregateMaximumBitrate;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_LTEUESidelinkAggregateMaximumBitrate");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_LTEUESidelinkAggregateMaximumBitrate
             = rtxMemAllocType (pctxt, LTEUESidelinkAggregateMaximumBitrate);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_LTEUESidelinkAggregateMaximumBitrate
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LTEUESidelinkAggregateMaximumBitrate (
            (LTEUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_LTEUESidelinkAggregateMaximumBitrate
            );

         stat = asn1PD_LTEUESidelinkAggregateMaximumBitrate (pctxt, 
            (LTEUESidelinkAggregateMaximumBitrate*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_LTEUESidelinkAggregateMaximumBitrate
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_PC5QoSParameters */
      case ASN1V_id_PC5QoSParameters:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_PC5QoSParameters;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_PC5QoSParameters");

         pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_PC5QoSParameters
             = rtxMemAllocType (pctxt, PC5QoSParameters);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_PC5QoSParameters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PC5QoSParameters ((PC5QoSParameters*)pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_PC5QoSParameters);

         stat = asn1PD_PC5QoSParameters (pctxt, (PC5QoSParameters*)pvalue->
            value.u._PathSwitchRequestAcknowledgeIEs_id_PC5QoSParameters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_CEmodeBrestricted */
      case ASN1V_id_CEmodeBrestricted:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_CEmodeBrestricted;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_CEmodeBrestricted");

         stat = asn1PD_CEmodeBrestricted (pctxt, &pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_CEmodeBrestricted);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_UE_UP_CIoT_Support */
      case ASN1V_id_UE_UP_CIoT_Support:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_UE_UP_CIoT_Support;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_UE_UP_CIoT_Support");

         stat = asn1PD_UE_UP_CIoT_Support (pctxt, &pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UE_UP_CIoT_Support);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestAcknowledgeIEs_id_UERadioCapabilityID */
      case ASN1V_id_UERadioCapabilityID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_UERadioCapabilityID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_UERadioCapabilityID");

         pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UERadioCapabilityID
             = rtxMemAllocType (pctxt, UERadioCapabilityID);

         if (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UERadioCapabilityID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityID (pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UERadioCapabilityID);

         stat = asn1PD_UERadioCapabilityID (pctxt, pvalue->value.
            u._PathSwitchRequestAcknowledgeIEs_id_UERadioCapabilityID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestAcknowledge_protocolIEs (OSCTXT* pctxt, PathSwitchRequestAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathSwitchRequestAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PathSwitchRequestAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PathSwitchRequestAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathSwitchRequestAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestAcknowledge (OSCTXT* pctxt, PathSwitchRequestAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequestAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PathSwitchRequestAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestFailure_protocolIEs_element (OSCTXT* pctxt, PathSwitchRequestFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail */
      case ASN1V_id_PDUSessionResourceReleasedListPSFail:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail");

         pvalue->value.
            u._PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail
             = rtxMemAllocType (pctxt, PDUSessionResourceReleasedListPSFail);

         if (pvalue->value.
            u._PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceReleasedListPSFail (pvalue->value.
            u._PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail
            );

         stat = asn1PD_PDUSessionResourceReleasedListPSFail (pctxt, pvalue->
            value.
            u._PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PathSwitchRequestFailureIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_CriticalityDiagnostics");

         pvalue->value.u._PathSwitchRequestFailureIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._PathSwitchRequestFailureIEs_id_CriticalityDiagnostics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._PathSwitchRequestFailureIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._PathSwitchRequestFailureIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestFailure_protocolIEs (OSCTXT* pctxt, PathSwitchRequestFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathSwitchRequestFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PathSwitchRequestFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PathSwitchRequestFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathSwitchRequestFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestFailure (OSCTXT* pctxt, PathSwitchRequestFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequestFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PathSwitchRequestFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCancel_protocolIEs_element (OSCTXT* pctxt, HandoverCancel_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _HandoverCancelIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCancelIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverCancelIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCancelIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCancelIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverCancelIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCancelIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverCancelIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelIEs_id_Cause");

         pvalue->value.u._HandoverCancelIEs_id_Cause = rtxMemAllocType (pctxt, 
            Cause);

         if (pvalue->value.u._HandoverCancelIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.u._HandoverCancelIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._HandoverCancelIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverCancelIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCancel_protocolIEs (OSCTXT* pctxt, HandoverCancel_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverCancel_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverCancel_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverCancel_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverCancel_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCancel (OSCTXT* pctxt, HandoverCancel* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCancel");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverCancel_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCancelAcknowledge_protocolIEs_element (OSCTXT* pctxt, HandoverCancelAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCancelAcknowledge_protocolIEs (OSCTXT* pctxt, HandoverCancelAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverCancelAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverCancelAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverCancelAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverCancelAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCancelAcknowledge (OSCTXT* pctxt, HandoverCancelAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCancelAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverCancelAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverSuccess_protocolIEs_element (OSCTXT* pctxt, HandoverSuccess_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverSuccess_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _HandoverSuccessIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverSuccessIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverSuccessIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverSuccessIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _HandoverSuccessIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_HandoverSuccessIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_HandoverSuccessIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._HandoverSuccessIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_HandoverSuccessIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverSuccess_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverSuccess_protocolIEs (OSCTXT* pctxt, HandoverSuccess_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverSuccess_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverSuccess_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverSuccess_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverSuccess_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverSuccess_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverSuccess_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverSuccess (OSCTXT* pctxt, HandoverSuccess* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverSuccess");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverSuccess: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverSuccess_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverSuccess: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkRANEarlyStatusTransfer_protocolIEs_element (OSCTXT* pctxt, UplinkRANEarlyStatusTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANEarlyStatusTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UplinkRANEarlyStatusTransferIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkRANEarlyStatusTransferIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANEarlyStatusTransferIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UplinkRANEarlyStatusTransferIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkRANEarlyStatusTransferIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkRANEarlyStatusTransferIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANEarlyStatusTransferIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UplinkRANEarlyStatusTransferIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer */
      case ASN1V_id_EarlyStatusTransfer_TransparentContainer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer");

         pvalue->value.
            u._UplinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer
             = rtxMemAllocType (pctxt, 
            EarlyStatusTransfer_TransparentContainer);

         if (pvalue->value.
            u._UplinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EarlyStatusTransfer_TransparentContainer (
            (EarlyStatusTransfer_TransparentContainer*)pvalue->value.
            u._UplinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer
            );

         stat = asn1PD_EarlyStatusTransfer_TransparentContainer (pctxt, 
            (EarlyStatusTransfer_TransparentContainer*)pvalue->value.
            u._UplinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UplinkRANEarlyStatusTransferIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANEarlyStatusTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRANEarlyStatusTransfer_protocolIEs (OSCTXT* pctxt, UplinkRANEarlyStatusTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANEarlyStatusTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkRANEarlyStatusTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkRANEarlyStatusTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkRANEarlyStatusTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkRANEarlyStatusTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANEarlyStatusTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRANEarlyStatusTransfer (OSCTXT* pctxt, UplinkRANEarlyStatusTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkRANEarlyStatusTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANEarlyStatusTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkRANEarlyStatusTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANEarlyStatusTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkRANEarlyStatusTransfer_protocolIEs_element (OSCTXT* pctxt, DownlinkRANEarlyStatusTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANEarlyStatusTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _DownlinkRANEarlyStatusTransferIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkRANEarlyStatusTransferIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANEarlyStatusTransferIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._DownlinkRANEarlyStatusTransferIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkRANEarlyStatusTransferIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkRANEarlyStatusTransferIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANEarlyStatusTransferIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._DownlinkRANEarlyStatusTransferIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer */
      case ASN1V_id_EarlyStatusTransfer_TransparentContainer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer");

         pvalue->value.
            u._DownlinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer
             = rtxMemAllocType (pctxt, 
            EarlyStatusTransfer_TransparentContainer);

         if (pvalue->value.
            u._DownlinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EarlyStatusTransfer_TransparentContainer (
            (EarlyStatusTransfer_TransparentContainer*)pvalue->value.
            u._DownlinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer
            );

         stat = asn1PD_EarlyStatusTransfer_TransparentContainer (pctxt, 
            (EarlyStatusTransfer_TransparentContainer*)pvalue->value.
            u._DownlinkRANEarlyStatusTransferIEs_id_EarlyStatusTransfer_TransparentContainer
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_DownlinkRANEarlyStatusTransferIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANEarlyStatusTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRANEarlyStatusTransfer_protocolIEs (OSCTXT* pctxt, DownlinkRANEarlyStatusTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANEarlyStatusTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkRANEarlyStatusTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkRANEarlyStatusTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkRANEarlyStatusTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkRANEarlyStatusTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANEarlyStatusTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRANEarlyStatusTransfer (OSCTXT* pctxt, DownlinkRANEarlyStatusTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkRANEarlyStatusTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANEarlyStatusTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkRANEarlyStatusTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANEarlyStatusTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkRANStatusTransfer_protocolIEs_element (OSCTXT* pctxt, UplinkRANStatusTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer */
      case ASN1V_id_RANStatusTransfer_TransparentContainer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer");

         pvalue->value.
            u._UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
             = rtxMemAllocType (pctxt, 
            RANStatusTransfer_TransparentContainer);

         if (pvalue->value.
            u._UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RANStatusTransfer_TransparentContainer (
            (RANStatusTransfer_TransparentContainer*)pvalue->value.
            u._UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
            );

         stat = asn1PD_RANStatusTransfer_TransparentContainer (pctxt, 
            (RANStatusTransfer_TransparentContainer*)pvalue->value.
            u._UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRANStatusTransfer_protocolIEs (OSCTXT* pctxt, UplinkRANStatusTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkRANStatusTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkRANStatusTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkRANStatusTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkRANStatusTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRANStatusTransfer (OSCTXT* pctxt, UplinkRANStatusTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkRANStatusTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkRANStatusTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkRANStatusTransfer_protocolIEs_element (OSCTXT* pctxt, DownlinkRANStatusTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer */
      case ASN1V_id_RANStatusTransfer_TransparentContainer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer");

         pvalue->value.
            u._DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
             = rtxMemAllocType (pctxt, 
            RANStatusTransfer_TransparentContainer);

         if (pvalue->value.
            u._DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RANStatusTransfer_TransparentContainer (
            (RANStatusTransfer_TransparentContainer*)pvalue->value.
            u._DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
            );

         stat = asn1PD_RANStatusTransfer_TransparentContainer (pctxt, 
            (RANStatusTransfer_TransparentContainer*)pvalue->value.
            u._DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRANStatusTransfer_protocolIEs (OSCTXT* pctxt, DownlinkRANStatusTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkRANStatusTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkRANStatusTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkRANStatusTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkRANStatusTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRANStatusTransfer (OSCTXT* pctxt, DownlinkRANStatusTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkRANStatusTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkRANStatusTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_Paging_protocolIEs_element (OSCTXT* pctxt, Paging_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PagingIEs_id_UEPagingIdentity */
      case ASN1V_id_UEPagingIdentity:
         pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_UEPagingIdentity;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_UEPagingIdentity");

         pvalue->value.u._PagingIEs_id_UEPagingIdentity
             = rtxMemAllocType (pctxt, UEPagingIdentity);

         if (pvalue->value.u._PagingIEs_id_UEPagingIdentity == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEPagingIdentity ((UEPagingIdentity*)pvalue->value.
            u._PagingIEs_id_UEPagingIdentity);

         stat = asn1PD_UEPagingIdentity (pctxt, (UEPagingIdentity*)pvalue->
            value.u._PagingIEs_id_UEPagingIdentity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_PagingDRX */
      case ASN1V_id_PagingDRX:
         pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_PagingDRX;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_PagingDRX");

         stat = asn1PD_PagingDRX (pctxt, &pvalue->value.
            u._PagingIEs_id_PagingDRX);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_TAIListForPaging */
      case ASN1V_id_TAIListForPaging:
         pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_TAIListForPaging;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_TAIListForPaging");

         pvalue->value.u._PagingIEs_id_TAIListForPaging
             = rtxMemAllocType (pctxt, TAIListForPaging);

         if (pvalue->value.u._PagingIEs_id_TAIListForPaging == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TAIListForPaging (pvalue->value.
            u._PagingIEs_id_TAIListForPaging);

         stat = asn1PD_TAIListForPaging (pctxt, pvalue->value.
            u._PagingIEs_id_TAIListForPaging);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_PagingPriority */
      case ASN1V_id_PagingPriority:
         pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_PagingPriority;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_PagingPriority");

         stat = asn1PD_PagingPriority (pctxt, &pvalue->value.
            u._PagingIEs_id_PagingPriority);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_UERadioCapabilityForPaging */
      case ASN1V_id_UERadioCapabilityForPaging:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PagingIEs_id_UERadioCapabilityForPaging;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_UERadioCapabilityForPaging");

         pvalue->value.u._PagingIEs_id_UERadioCapabilityForPaging
             = rtxMemAllocType (pctxt, UERadioCapabilityForPaging);

         if (pvalue->value.u._PagingIEs_id_UERadioCapabilityForPaging == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityForPaging ((UERadioCapabilityForPaging*)
            pvalue->value.u._PagingIEs_id_UERadioCapabilityForPaging);

         stat = asn1PD_UERadioCapabilityForPaging (pctxt, 
            (UERadioCapabilityForPaging*)pvalue->value.
            u._PagingIEs_id_UERadioCapabilityForPaging);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_PagingOrigin */
      case ASN1V_id_PagingOrigin:
         pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_PagingOrigin;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_PagingOrigin");

         stat = asn1PD_PagingOrigin (pctxt, &pvalue->value.
            u._PagingIEs_id_PagingOrigin);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_AssistanceDataForPaging */
      case ASN1V_id_AssistanceDataForPaging:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PagingIEs_id_AssistanceDataForPaging;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_AssistanceDataForPaging");

         pvalue->value.u._PagingIEs_id_AssistanceDataForPaging
             = rtxMemAllocType (pctxt, AssistanceDataForPaging);

         if (pvalue->value.u._PagingIEs_id_AssistanceDataForPaging == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AssistanceDataForPaging ((AssistanceDataForPaging*)pvalue->
            value.u._PagingIEs_id_AssistanceDataForPaging);

         stat = asn1PD_AssistanceDataForPaging (pctxt, 
            (AssistanceDataForPaging*)pvalue->value.
            u._PagingIEs_id_AssistanceDataForPaging);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_NB_IoT_Paging_eDRXInfo */
      case ASN1V_id_NB_IoT_Paging_eDRXInfo:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PagingIEs_id_NB_IoT_Paging_eDRXInfo;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_NB_IoT_Paging_eDRXInfo");

         pvalue->value.u._PagingIEs_id_NB_IoT_Paging_eDRXInfo
             = rtxMemAllocType (pctxt, NB_IoT_Paging_eDRXInfo);

         if (pvalue->value.u._PagingIEs_id_NB_IoT_Paging_eDRXInfo == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NB_IoT_Paging_eDRXInfo ((NB_IoT_Paging_eDRXInfo*)pvalue->
            value.u._PagingIEs_id_NB_IoT_Paging_eDRXInfo);

         stat = asn1PD_NB_IoT_Paging_eDRXInfo (pctxt, (NB_IoT_Paging_eDRXInfo*)
            pvalue->value.u._PagingIEs_id_NB_IoT_Paging_eDRXInfo);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_NB_IoT_PagingDRX */
      case ASN1V_id_NB_IoT_PagingDRX:
         pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_NB_IoT_PagingDRX;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_NB_IoT_PagingDRX");

         stat = asn1PD_NB_IoT_PagingDRX (pctxt, &pvalue->value.
            u._PagingIEs_id_NB_IoT_PagingDRX);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_Enhanced_CoverageRestriction */
      case ASN1V_id_Enhanced_CoverageRestriction:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PagingIEs_id_Enhanced_CoverageRestriction;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_Enhanced_CoverageRestriction");

         stat = asn1PD_Enhanced_CoverageRestriction (pctxt, &pvalue->value.
            u._PagingIEs_id_Enhanced_CoverageRestriction);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_WUS_Assistance_Information */
      case ASN1V_id_WUS_Assistance_Information:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PagingIEs_id_WUS_Assistance_Information;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_WUS_Assistance_Information");

         pvalue->value.u._PagingIEs_id_WUS_Assistance_Information
             = rtxMemAllocType (pctxt, WUS_Assistance_Information);

         if (pvalue->value.u._PagingIEs_id_WUS_Assistance_Information == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_WUS_Assistance_Information ((WUS_Assistance_Information*)
            pvalue->value.u._PagingIEs_id_WUS_Assistance_Information);

         stat = asn1PD_WUS_Assistance_Information (pctxt, 
            (WUS_Assistance_Information*)pvalue->value.
            u._PagingIEs_id_WUS_Assistance_Information);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_PagingeDRXInformation */
      case ASN1V_id_PagingeDRXInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PagingIEs_id_PagingeDRXInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_PagingeDRXInformation");

         pvalue->value.u._PagingIEs_id_PagingeDRXInformation
             = rtxMemAllocType (pctxt, PagingeDRXInformation);

         if (pvalue->value.u._PagingIEs_id_PagingeDRXInformation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PagingeDRXInformation ((PagingeDRXInformation*)pvalue->value.
            u._PagingIEs_id_PagingeDRXInformation);

         stat = asn1PD_PagingeDRXInformation (pctxt, (PagingeDRXInformation*)
            pvalue->value.u._PagingIEs_id_PagingeDRXInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PagingIEs_id_CEmodeBrestricted */
      case ASN1V_id_CEmodeBrestricted:
         pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_CEmodeBrestricted;

         RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_CEmodeBrestricted");

         stat = asn1PD_CEmodeBrestricted (pctxt, &pvalue->value.
            u._PagingIEs_id_CEmodeBrestricted);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_Paging_protocolIEs (OSCTXT* pctxt, Paging_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      Paging_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, Paging_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Paging_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_Paging_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_Paging (OSCTXT* pctxt, Paging* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Paging");

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_Paging_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_InitialUEMessage_protocolIEs_element (OSCTXT* pctxt, InitialUEMessage_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _InitialUEMessage_IEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._InitialUEMessage_IEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_NAS_PDU */
      case ASN1V_id_NAS_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_NAS_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_NAS_PDU");

         pvalue->value.u._InitialUEMessage_IEs_id_NAS_PDU
             = rtxMemAllocType (pctxt, NAS_PDU);

         if (pvalue->value.u._InitialUEMessage_IEs_id_NAS_PDU == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NAS_PDU (pvalue->value.u._InitialUEMessage_IEs_id_NAS_PDU);

         stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
            u._InitialUEMessage_IEs_id_NAS_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_UserLocationInformation");

         pvalue->value.u._InitialUEMessage_IEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.u._InitialUEMessage_IEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.u._InitialUEMessage_IEs_id_UserLocationInformation);

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._InitialUEMessage_IEs_id_UserLocationInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_RRCEstablishmentCause */
      case ASN1V_id_RRCEstablishmentCause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_RRCEstablishmentCause;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_RRCEstablishmentCause");

         stat = asn1PD_RRCEstablishmentCause (pctxt, &pvalue->value.
            u._InitialUEMessage_IEs_id_RRCEstablishmentCause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_FiveG_S_TMSI */
      case ASN1V_id_FiveG_S_TMSI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_FiveG_S_TMSI;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_FiveG_S_TMSI");

         pvalue->value.u._InitialUEMessage_IEs_id_FiveG_S_TMSI
             = rtxMemAllocType (pctxt, FiveG_S_TMSI);

         if (pvalue->value.u._InitialUEMessage_IEs_id_FiveG_S_TMSI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FiveG_S_TMSI ((FiveG_S_TMSI*)pvalue->value.
            u._InitialUEMessage_IEs_id_FiveG_S_TMSI);

         stat = asn1PD_FiveG_S_TMSI (pctxt, (FiveG_S_TMSI*)pvalue->value.
            u._InitialUEMessage_IEs_id_FiveG_S_TMSI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_AMFSetID */
      case ASN1V_id_AMFSetID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_AMFSetID;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_AMFSetID");

         pvalue->value.u._InitialUEMessage_IEs_id_AMFSetID
             = rtxMemAllocTypeZ (pctxt, AMFSetID);

         if (pvalue->value.u._InitialUEMessage_IEs_id_AMFSetID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_AMFSetID (pctxt, pvalue->value.
            u._InitialUEMessage_IEs_id_AMFSetID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_UEContextRequest */
      case ASN1V_id_UEContextRequest:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_UEContextRequest;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_UEContextRequest");

         stat = asn1PD_UEContextRequest (pctxt, &pvalue->value.
            u._InitialUEMessage_IEs_id_UEContextRequest);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_AllowedNSSAI */
      case ASN1V_id_AllowedNSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_AllowedNSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_AllowedNSSAI");

         pvalue->value.u._InitialUEMessage_IEs_id_AllowedNSSAI
             = rtxMemAllocType (pctxt, AllowedNSSAI);

         if (pvalue->value.u._InitialUEMessage_IEs_id_AllowedNSSAI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AllowedNSSAI (pvalue->value.
            u._InitialUEMessage_IEs_id_AllowedNSSAI);

         stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
            u._InitialUEMessage_IEs_id_AllowedNSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute */
      case ASN1V_id_SourceToTarget_AMFInformationReroute:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute");

         pvalue->value.
            u._InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute
             = rtxMemAllocType (pctxt, SourceToTarget_AMFInformationReroute);

         if (pvalue->value.
            u._InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SourceToTarget_AMFInformationReroute (
            (SourceToTarget_AMFInformationReroute*)pvalue->value.
            u._InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute);

         stat = asn1PD_SourceToTarget_AMFInformationReroute (pctxt, 
            (SourceToTarget_AMFInformationReroute*)pvalue->value.
            u._InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_SelectedPLMNIdentity */
      case ASN1V_id_SelectedPLMNIdentity:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_SelectedPLMNIdentity;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_SelectedPLMNIdentity");

         pvalue->value.u._InitialUEMessage_IEs_id_SelectedPLMNIdentity
             = rtxMemAllocTypeZ (pctxt, PLMNIdentity);

         if (pvalue->value.u._InitialUEMessage_IEs_id_SelectedPLMNIdentity
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_PLMNIdentity (pctxt, (PLMNIdentity*)pvalue->value.
            u._InitialUEMessage_IEs_id_SelectedPLMNIdentity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_IABNodeIndication */
      case ASN1V_id_IABNodeIndication:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_IABNodeIndication;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_IABNodeIndication");

         stat = asn1PD_IABNodeIndication (pctxt, &pvalue->value.
            u._InitialUEMessage_IEs_id_IABNodeIndication);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_CEmodeBSupport_Indicator */
      case ASN1V_id_CEmodeBSupport_Indicator:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_CEmodeBSupport_Indicator;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_CEmodeBSupport_Indicator");

         stat = asn1PD_CEmodeBSupport_Indicator (pctxt, &pvalue->value.
            u._InitialUEMessage_IEs_id_CEmodeBSupport_Indicator);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_LTEM_Indication */
      case ASN1V_id_LTEM_Indication:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_LTEM_Indication;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_LTEM_Indication");

         stat = asn1PD_LTEM_Indication (pctxt, &pvalue->value.
            u._InitialUEMessage_IEs_id_LTEM_Indication);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_EDT_Session */
      case ASN1V_id_EDT_Session:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_EDT_Session;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_EDT_Session");

         stat = asn1PD_EDT_Session (pctxt, &pvalue->value.
            u._InitialUEMessage_IEs_id_EDT_Session);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_AuthenticatedIndication */
      case ASN1V_id_AuthenticatedIndication:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_AuthenticatedIndication;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_AuthenticatedIndication");

         stat = asn1PD_AuthenticatedIndication (pctxt, &pvalue->value.
            u._InitialUEMessage_IEs_id_AuthenticatedIndication);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _InitialUEMessage_IEs_id_NPN_AccessInformation */
      case ASN1V_id_NPN_AccessInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_NPN_AccessInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_NPN_AccessInformation");

         pvalue->value.u._InitialUEMessage_IEs_id_NPN_AccessInformation
             = rtxMemAllocType (pctxt, NPN_AccessInformation);

         if (pvalue->value.u._InitialUEMessage_IEs_id_NPN_AccessInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NPN_AccessInformation ((NPN_AccessInformation*)pvalue->value.
            u._InitialUEMessage_IEs_id_NPN_AccessInformation);

         stat = asn1PD_NPN_AccessInformation (pctxt, (NPN_AccessInformation*)
            pvalue->value.u._InitialUEMessage_IEs_id_NPN_AccessInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialUEMessage_protocolIEs (OSCTXT* pctxt, InitialUEMessage_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InitialUEMessage_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, InitialUEMessage_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InitialUEMessage_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_InitialUEMessage_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialUEMessage (OSCTXT* pctxt, InitialUEMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialUEMessage");

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_InitialUEMessage_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkNASTransport_protocolIEs_element (OSCTXT* pctxt, DownlinkNASTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_OldAMF */
      case ASN1V_id_OldAMF:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_OldAMF;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_OldAMF");

         stat = asn1PD_AMFName (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_OldAMF);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_RANPagingPriority */
      case ASN1V_id_RANPagingPriority:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_RANPagingPriority;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_RANPagingPriority");

         stat = asn1PD_RANPagingPriority (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_RANPagingPriority);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_NAS_PDU */
      case ASN1V_id_NAS_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_NAS_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_NAS_PDU");

         pvalue->value.u._DownlinkNASTransport_IEs_id_NAS_PDU
             = rtxMemAllocType (pctxt, NAS_PDU);

         if (pvalue->value.u._DownlinkNASTransport_IEs_id_NAS_PDU == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NAS_PDU (pvalue->value.u._DownlinkNASTransport_IEs_id_NAS_PDU
            );

         stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
            u._DownlinkNASTransport_IEs_id_NAS_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_MobilityRestrictionList */
      case ASN1V_id_MobilityRestrictionList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_MobilityRestrictionList;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_MobilityRestrictionList");

         pvalue->value.u._DownlinkNASTransport_IEs_id_MobilityRestrictionList
             = rtxMemAllocType (pctxt, MobilityRestrictionList);

         if (pvalue->value.
            u._DownlinkNASTransport_IEs_id_MobilityRestrictionList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MobilityRestrictionList ((MobilityRestrictionList*)pvalue->
            value.u._DownlinkNASTransport_IEs_id_MobilityRestrictionList);

         stat = asn1PD_MobilityRestrictionList (pctxt, 
            (MobilityRestrictionList*)pvalue->value.
            u._DownlinkNASTransport_IEs_id_MobilityRestrictionList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_IndexToRFSP */
      case ASN1V_id_IndexToRFSP:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_IndexToRFSP;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_IndexToRFSP");

         stat = asn1PD_IndexToRFSP (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_IndexToRFSP);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate */
      case ASN1V_id_UEAggregateMaximumBitRate:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate");

         pvalue->value.u._DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate
             = rtxMemAllocType (pctxt, UEAggregateMaximumBitRate);

         if (pvalue->value.
            u._DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEAggregateMaximumBitRate ((UEAggregateMaximumBitRate*)pvalue
            ->value.u._DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate);

         stat = asn1PD_UEAggregateMaximumBitRate (pctxt, 
            (UEAggregateMaximumBitRate*)pvalue->value.
            u._DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_AllowedNSSAI */
      case ASN1V_id_AllowedNSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_AllowedNSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_AllowedNSSAI");

         pvalue->value.u._DownlinkNASTransport_IEs_id_AllowedNSSAI
             = rtxMemAllocType (pctxt, AllowedNSSAI);

         if (pvalue->value.u._DownlinkNASTransport_IEs_id_AllowedNSSAI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AllowedNSSAI (pvalue->value.
            u._DownlinkNASTransport_IEs_id_AllowedNSSAI);

         stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
            u._DownlinkNASTransport_IEs_id_AllowedNSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_SRVCCOperationPossible */
      case ASN1V_id_SRVCCOperationPossible:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_SRVCCOperationPossible;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_SRVCCOperationPossible");

         stat = asn1PD_SRVCCOperationPossible (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_SRVCCOperationPossible);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_Enhanced_CoverageRestriction */
      case ASN1V_id_Enhanced_CoverageRestriction:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_Enhanced_CoverageRestriction;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_Enhanced_CoverageRestriction");

         stat = asn1PD_Enhanced_CoverageRestriction (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_Enhanced_CoverageRestriction);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_Extended_ConnectedTime */
      case ASN1V_id_Extended_ConnectedTime:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_Extended_ConnectedTime;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_Extended_ConnectedTime");

         stat = asn1PD_Extended_ConnectedTime (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_Extended_ConnectedTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_UE_DifferentiationInfo */
      case ASN1V_id_UE_DifferentiationInfo:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_UE_DifferentiationInfo;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_UE_DifferentiationInfo");

         pvalue->value.u._DownlinkNASTransport_IEs_id_UE_DifferentiationInfo
             = rtxMemAllocType (pctxt, UE_DifferentiationInfo);

         if (pvalue->value.
            u._DownlinkNASTransport_IEs_id_UE_DifferentiationInfo == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_DifferentiationInfo ((UE_DifferentiationInfo*)pvalue->
            value.u._DownlinkNASTransport_IEs_id_UE_DifferentiationInfo);

         stat = asn1PD_UE_DifferentiationInfo (pctxt, (UE_DifferentiationInfo*)
            pvalue->value.u._DownlinkNASTransport_IEs_id_UE_DifferentiationInfo
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_CEmodeBrestricted */
      case ASN1V_id_CEmodeBrestricted:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_CEmodeBrestricted;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_CEmodeBrestricted");

         stat = asn1PD_CEmodeBrestricted (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_CEmodeBrestricted);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_UERadioCapability */
      case ASN1V_id_UERadioCapability:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_UERadioCapability;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_UERadioCapability");

         pvalue->value.u._DownlinkNASTransport_IEs_id_UERadioCapability
             = rtxMemAllocType (pctxt, UERadioCapability);

         if (pvalue->value.u._DownlinkNASTransport_IEs_id_UERadioCapability
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapability (pvalue->value.
            u._DownlinkNASTransport_IEs_id_UERadioCapability);

         stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
            u._DownlinkNASTransport_IEs_id_UERadioCapability);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_UECapabilityInfoRequest */
      case ASN1V_id_UECapabilityInfoRequest:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_UECapabilityInfoRequest;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_UECapabilityInfoRequest");

         stat = asn1PD_UECapabilityInfoRequest (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_UECapabilityInfoRequest);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_EndIndication */
      case ASN1V_id_EndIndication:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_EndIndication;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_EndIndication");

         stat = asn1PD_EndIndication (pctxt, &pvalue->value.
            u._DownlinkNASTransport_IEs_id_EndIndication);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNASTransport_IEs_id_UERadioCapabilityID */
      case ASN1V_id_UERadioCapabilityID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_UERadioCapabilityID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_UERadioCapabilityID");

         pvalue->value.u._DownlinkNASTransport_IEs_id_UERadioCapabilityID
             = rtxMemAllocType (pctxt, UERadioCapabilityID);

         if (pvalue->value.u._DownlinkNASTransport_IEs_id_UERadioCapabilityID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityID (pvalue->value.
            u._DownlinkNASTransport_IEs_id_UERadioCapabilityID);

         stat = asn1PD_UERadioCapabilityID (pctxt, pvalue->value.
            u._DownlinkNASTransport_IEs_id_UERadioCapabilityID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkNASTransport_protocolIEs (OSCTXT* pctxt, DownlinkNASTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkNASTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkNASTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkNASTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkNASTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkNASTransport (OSCTXT* pctxt, DownlinkNASTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkNASTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkNASTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkNASTransport_protocolIEs_element (OSCTXT* pctxt, UplinkNASTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkNASTransport_IEs_id_NAS_PDU */
      case ASN1V_id_NAS_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_NAS_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_NAS_PDU");

         pvalue->value.u._UplinkNASTransport_IEs_id_NAS_PDU
             = rtxMemAllocType (pctxt, NAS_PDU);

         if (pvalue->value.u._UplinkNASTransport_IEs_id_NAS_PDU == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NAS_PDU (pvalue->value.u._UplinkNASTransport_IEs_id_NAS_PDU
            );

         stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
            u._UplinkNASTransport_IEs_id_NAS_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkNASTransport_IEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_UserLocationInformation");

         pvalue->value.u._UplinkNASTransport_IEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.u._UplinkNASTransport_IEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.u._UplinkNASTransport_IEs_id_UserLocationInformation);

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._UplinkNASTransport_IEs_id_UserLocationInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkNASTransport_IEs_id_W_AGFIdentityInformation */
      case ASN1V_id_W_AGFIdentityInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_W_AGFIdentityInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_W_AGFIdentityInformation");

         pvalue->value.u._UplinkNASTransport_IEs_id_W_AGFIdentityInformation
             = rtxMemAllocType (pctxt, _UplinkNASTransport_IEs_Value);

         if (pvalue->value.
            u._UplinkNASTransport_IEs_id_W_AGFIdentityInformation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init__UplinkNASTransport_IEs_Value (pvalue->value.
            u._UplinkNASTransport_IEs_id_W_AGFIdentityInformation);

         stat = asn1PD__UplinkNASTransport_IEs_Value (pctxt, pvalue->value.
            u._UplinkNASTransport_IEs_id_W_AGFIdentityInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkNASTransport_IEs_id_TNGFIdentityInformation */
      case ASN1V_id_TNGFIdentityInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_TNGFIdentityInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_TNGFIdentityInformation");

         pvalue->value.u._UplinkNASTransport_IEs_id_TNGFIdentityInformation
             = rtxMemAllocType (pctxt, _UplinkNASTransport_IEs_Value_1);

         if (pvalue->value.u._UplinkNASTransport_IEs_id_TNGFIdentityInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init__UplinkNASTransport_IEs_Value_1 (pvalue->value.
            u._UplinkNASTransport_IEs_id_TNGFIdentityInformation);

         stat = asn1PD__UplinkNASTransport_IEs_Value_1 (pctxt, pvalue->value.
            u._UplinkNASTransport_IEs_id_TNGFIdentityInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkNASTransport_IEs_id_TWIFIdentityInformation */
      case ASN1V_id_TWIFIdentityInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_TWIFIdentityInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_TWIFIdentityInformation");

         pvalue->value.u._UplinkNASTransport_IEs_id_TWIFIdentityInformation
             = rtxMemAllocType (pctxt, _UplinkNASTransport_IEs_Value_2);

         if (pvalue->value.u._UplinkNASTransport_IEs_id_TWIFIdentityInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init__UplinkNASTransport_IEs_Value_2 (pvalue->value.
            u._UplinkNASTransport_IEs_id_TWIFIdentityInformation);

         stat = asn1PD__UplinkNASTransport_IEs_Value_2 (pctxt, pvalue->value.
            u._UplinkNASTransport_IEs_id_TWIFIdentityInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkNASTransport_protocolIEs (OSCTXT* pctxt, UplinkNASTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkNASTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkNASTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkNASTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkNASTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkNASTransport (OSCTXT* pctxt, UplinkNASTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkNASTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkNASTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NASNonDeliveryIndication_protocolIEs_element (OSCTXT* pctxt, NASNonDeliveryIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NASNonDeliveryIndication_IEs_id_NAS_PDU */
      case ASN1V_id_NAS_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_NAS_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_NAS_PDU");

         pvalue->value.u._NASNonDeliveryIndication_IEs_id_NAS_PDU
             = rtxMemAllocType (pctxt, NAS_PDU);

         if (pvalue->value.u._NASNonDeliveryIndication_IEs_id_NAS_PDU == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NAS_PDU (pvalue->value.
            u._NASNonDeliveryIndication_IEs_id_NAS_PDU);

         stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
            u._NASNonDeliveryIndication_IEs_id_NAS_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NASNonDeliveryIndication_IEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_Cause");

         pvalue->value.u._NASNonDeliveryIndication_IEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._NASNonDeliveryIndication_IEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._NASNonDeliveryIndication_IEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._NASNonDeliveryIndication_IEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NASNonDeliveryIndication_protocolIEs (OSCTXT* pctxt, NASNonDeliveryIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NASNonDeliveryIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NASNonDeliveryIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NASNonDeliveryIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NASNonDeliveryIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NASNonDeliveryIndication (OSCTXT* pctxt, NASNonDeliveryIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NASNonDeliveryIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NASNonDeliveryIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RerouteNASRequest_protocolIEs_element (OSCTXT* pctxt, RerouteNASRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RerouteNASRequest_IEs_id_NGAP_Message */
      case ASN1V_id_NGAP_Message:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_NGAP_Message;

         RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_NGAP_Message");

         pvalue->value.u._RerouteNASRequest_IEs_id_NGAP_Message
             = rtxMemAllocType (pctxt, _RerouteNASRequest_IEs_Value);

         if (pvalue->value.u._RerouteNASRequest_IEs_id_NGAP_Message == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init__RerouteNASRequest_IEs_Value (pvalue->value.
            u._RerouteNASRequest_IEs_id_NGAP_Message);

         stat = asn1PD__RerouteNASRequest_IEs_Value (pctxt, pvalue->value.
            u._RerouteNASRequest_IEs_id_NGAP_Message);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RerouteNASRequest_IEs_id_AMFSetID */
      case ASN1V_id_AMFSetID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_AMFSetID;

         RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_AMFSetID");

         pvalue->value.u._RerouteNASRequest_IEs_id_AMFSetID
             = rtxMemAllocTypeZ (pctxt, AMFSetID);

         if (pvalue->value.u._RerouteNASRequest_IEs_id_AMFSetID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_AMFSetID (pctxt, pvalue->value.
            u._RerouteNASRequest_IEs_id_AMFSetID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RerouteNASRequest_IEs_id_AllowedNSSAI */
      case ASN1V_id_AllowedNSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_AllowedNSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_AllowedNSSAI");

         pvalue->value.u._RerouteNASRequest_IEs_id_AllowedNSSAI
             = rtxMemAllocType (pctxt, AllowedNSSAI);

         if (pvalue->value.u._RerouteNASRequest_IEs_id_AllowedNSSAI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AllowedNSSAI (pvalue->value.
            u._RerouteNASRequest_IEs_id_AllowedNSSAI);

         stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
            u._RerouteNASRequest_IEs_id_AllowedNSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute */
      case ASN1V_id_SourceToTarget_AMFInformationReroute:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute;

         RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute");

         pvalue->value.
            u._RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute
             = rtxMemAllocType (pctxt, SourceToTarget_AMFInformationReroute);

         if (pvalue->value.
            u._RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SourceToTarget_AMFInformationReroute (
            (SourceToTarget_AMFInformationReroute*)pvalue->value.
            u._RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute);

         stat = asn1PD_SourceToTarget_AMFInformationReroute (pctxt, 
            (SourceToTarget_AMFInformationReroute*)pvalue->value.
            u._RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RerouteNASRequest_protocolIEs (OSCTXT* pctxt, RerouteNASRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RerouteNASRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RerouteNASRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RerouteNASRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RerouteNASRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RerouteNASRequest (OSCTXT* pctxt, RerouteNASRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RerouteNASRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RerouteNASRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGSetupRequest_protocolIEs_element (OSCTXT* pctxt, NGSetupRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _NGSetupRequestIEs_id_GlobalRANNodeID */
      case ASN1V_id_GlobalRANNodeID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_GlobalRANNodeID;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_GlobalRANNodeID");

         pvalue->value.u._NGSetupRequestIEs_id_GlobalRANNodeID
             = rtxMemAllocType (pctxt, GlobalRANNodeID);

         if (pvalue->value.u._NGSetupRequestIEs_id_GlobalRANNodeID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GlobalRANNodeID ((GlobalRANNodeID*)pvalue->value.
            u._NGSetupRequestIEs_id_GlobalRANNodeID);

         stat = asn1PD_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.
            u._NGSetupRequestIEs_id_GlobalRANNodeID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupRequestIEs_id_RANNodeName */
      case ASN1V_id_RANNodeName:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_RANNodeName;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_RANNodeName");

         stat = asn1PD_RANNodeName (pctxt, &pvalue->value.
            u._NGSetupRequestIEs_id_RANNodeName);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupRequestIEs_id_SupportedTAList */
      case ASN1V_id_SupportedTAList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_SupportedTAList;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_SupportedTAList");

         pvalue->value.u._NGSetupRequestIEs_id_SupportedTAList
             = rtxMemAllocType (pctxt, SupportedTAList);

         if (pvalue->value.u._NGSetupRequestIEs_id_SupportedTAList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SupportedTAList (pvalue->value.
            u._NGSetupRequestIEs_id_SupportedTAList);

         stat = asn1PD_SupportedTAList (pctxt, pvalue->value.
            u._NGSetupRequestIEs_id_SupportedTAList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupRequestIEs_id_DefaultPagingDRX */
      case ASN1V_id_DefaultPagingDRX:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_DefaultPagingDRX;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_DefaultPagingDRX");

         stat = asn1PD_PagingDRX (pctxt, &pvalue->value.
            u._NGSetupRequestIEs_id_DefaultPagingDRX);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupRequestIEs_id_UERetentionInformation */
      case ASN1V_id_UERetentionInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_UERetentionInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_UERetentionInformation");

         stat = asn1PD_UERetentionInformation (pctxt, &pvalue->value.
            u._NGSetupRequestIEs_id_UERetentionInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupRequestIEs_id_NB_IoT_DefaultPagingDRX */
      case ASN1V_id_NB_IoT_DefaultPagingDRX:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_NB_IoT_DefaultPagingDRX;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_NB_IoT_DefaultPagingDRX");

         stat = asn1PD_NB_IoT_DefaultPagingDRX (pctxt, &pvalue->value.
            u._NGSetupRequestIEs_id_NB_IoT_DefaultPagingDRX);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupRequestIEs_id_Extended_RANNodeName */
      case ASN1V_id_Extended_RANNodeName:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_Extended_RANNodeName;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_Extended_RANNodeName");

         pvalue->value.u._NGSetupRequestIEs_id_Extended_RANNodeName
             = rtxMemAllocType (pctxt, Extended_RANNodeName);

         if (pvalue->value.u._NGSetupRequestIEs_id_Extended_RANNodeName
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Extended_RANNodeName ((Extended_RANNodeName*)pvalue->value.
            u._NGSetupRequestIEs_id_Extended_RANNodeName);

         stat = asn1PD_Extended_RANNodeName (pctxt, (Extended_RANNodeName*)
            pvalue->value.u._NGSetupRequestIEs_id_Extended_RANNodeName);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_NGSetupRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupRequest_protocolIEs (OSCTXT* pctxt, NGSetupRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGSetupRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGSetupRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGSetupRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGSetupRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupRequest (OSCTXT* pctxt, NGSetupRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGSetupRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NGSetupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGSetupResponse_protocolIEs_element (OSCTXT* pctxt, NGSetupResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _NGSetupResponseIEs_id_AMFName */
      case ASN1V_id_AMFName:
         pvalue->value.t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_AMFName;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_AMFName");

         stat = asn1PD_AMFName (pctxt, &pvalue->value.
            u._NGSetupResponseIEs_id_AMFName);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupResponseIEs_id_ServedGUAMIList */
      case ASN1V_id_ServedGUAMIList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_ServedGUAMIList;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_ServedGUAMIList");

         pvalue->value.u._NGSetupResponseIEs_id_ServedGUAMIList
             = rtxMemAllocType (pctxt, ServedGUAMIList);

         if (pvalue->value.u._NGSetupResponseIEs_id_ServedGUAMIList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ServedGUAMIList (pvalue->value.
            u._NGSetupResponseIEs_id_ServedGUAMIList);

         stat = asn1PD_ServedGUAMIList (pctxt, pvalue->value.
            u._NGSetupResponseIEs_id_ServedGUAMIList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupResponseIEs_id_RelativeAMFCapacity */
      case ASN1V_id_RelativeAMFCapacity:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_RelativeAMFCapacity;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_RelativeAMFCapacity");

         stat = asn1PD_RelativeAMFCapacity (pctxt, &pvalue->value.
            u._NGSetupResponseIEs_id_RelativeAMFCapacity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupResponseIEs_id_PLMNSupportList */
      case ASN1V_id_PLMNSupportList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_PLMNSupportList;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_PLMNSupportList");

         pvalue->value.u._NGSetupResponseIEs_id_PLMNSupportList
             = rtxMemAllocType (pctxt, PLMNSupportList);

         if (pvalue->value.u._NGSetupResponseIEs_id_PLMNSupportList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PLMNSupportList (pvalue->value.
            u._NGSetupResponseIEs_id_PLMNSupportList);

         stat = asn1PD_PLMNSupportList (pctxt, pvalue->value.
            u._NGSetupResponseIEs_id_PLMNSupportList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.u._NGSetupResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.u._NGSetupResponseIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._NGSetupResponseIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.u._NGSetupResponseIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupResponseIEs_id_UERetentionInformation */
      case ASN1V_id_UERetentionInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_UERetentionInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_UERetentionInformation");

         stat = asn1PD_UERetentionInformation (pctxt, &pvalue->value.
            u._NGSetupResponseIEs_id_UERetentionInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupResponseIEs_id_IAB_Supported */
      case ASN1V_id_IAB_Supported:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_IAB_Supported;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_IAB_Supported");

         stat = asn1PD_IAB_Supported (pctxt, &pvalue->value.
            u._NGSetupResponseIEs_id_IAB_Supported);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupResponseIEs_id_Extended_AMFName */
      case ASN1V_id_Extended_AMFName:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_Extended_AMFName;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_Extended_AMFName");

         pvalue->value.u._NGSetupResponseIEs_id_Extended_AMFName
             = rtxMemAllocType (pctxt, Extended_AMFName);

         if (pvalue->value.u._NGSetupResponseIEs_id_Extended_AMFName == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Extended_AMFName ((Extended_AMFName*)pvalue->value.
            u._NGSetupResponseIEs_id_Extended_AMFName);

         stat = asn1PD_Extended_AMFName (pctxt, (Extended_AMFName*)pvalue->
            value.u._NGSetupResponseIEs_id_Extended_AMFName);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_NGSetupResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupResponse_protocolIEs (OSCTXT* pctxt, NGSetupResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGSetupResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGSetupResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGSetupResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGSetupResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupResponse (OSCTXT* pctxt, NGSetupResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGSetupResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NGSetupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGSetupFailure_protocolIEs_element (OSCTXT* pctxt, NGSetupFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _NGSetupFailureIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.t = T_NGAP_PDU_Contents_NGSetupFailureIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupFailureIEs_id_Cause");

         pvalue->value.u._NGSetupFailureIEs_id_Cause = rtxMemAllocType (pctxt, 
            Cause);

         if (pvalue->value.u._NGSetupFailureIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.u._NGSetupFailureIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._NGSetupFailureIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupFailureIEs_id_TimeToWait */
      case ASN1V_id_TimeToWait:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupFailureIEs_id_TimeToWait;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupFailureIEs_id_TimeToWait");

         stat = asn1PD_TimeToWait (pctxt, &pvalue->value.
            u._NGSetupFailureIEs_id_TimeToWait);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGSetupFailureIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGSetupFailureIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupFailureIEs_id_CriticalityDiagnostics");

         pvalue->value.u._NGSetupFailureIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.u._NGSetupFailureIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._NGSetupFailureIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.u._NGSetupFailureIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_NGSetupFailureIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupFailure_protocolIEs (OSCTXT* pctxt, NGSetupFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGSetupFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGSetupFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGSetupFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGSetupFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupFailure (OSCTXT* pctxt, NGSetupFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGSetupFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NGSetupFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdate_protocolIEs_element (OSCTXT* pctxt, RANConfigurationUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _RANConfigurationUpdateIEs_id_RANNodeName */
      case ASN1V_id_RANNodeName:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_RANNodeName;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_RANNodeName");

         stat = asn1PD_RANNodeName (pctxt, &pvalue->value.
            u._RANConfigurationUpdateIEs_id_RANNodeName);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANConfigurationUpdateIEs_id_SupportedTAList */
      case ASN1V_id_SupportedTAList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_SupportedTAList;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_SupportedTAList");

         pvalue->value.u._RANConfigurationUpdateIEs_id_SupportedTAList
             = rtxMemAllocType (pctxt, SupportedTAList);

         if (pvalue->value.u._RANConfigurationUpdateIEs_id_SupportedTAList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SupportedTAList (pvalue->value.
            u._RANConfigurationUpdateIEs_id_SupportedTAList);

         stat = asn1PD_SupportedTAList (pctxt, pvalue->value.
            u._RANConfigurationUpdateIEs_id_SupportedTAList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANConfigurationUpdateIEs_id_DefaultPagingDRX */
      case ASN1V_id_DefaultPagingDRX:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_DefaultPagingDRX;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_DefaultPagingDRX");

         stat = asn1PD_PagingDRX (pctxt, &pvalue->value.
            u._RANConfigurationUpdateIEs_id_DefaultPagingDRX);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANConfigurationUpdateIEs_id_GlobalRANNodeID */
      case ASN1V_id_GlobalRANNodeID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_GlobalRANNodeID;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_GlobalRANNodeID");

         pvalue->value.u._RANConfigurationUpdateIEs_id_GlobalRANNodeID
             = rtxMemAllocType (pctxt, GlobalRANNodeID);

         if (pvalue->value.u._RANConfigurationUpdateIEs_id_GlobalRANNodeID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GlobalRANNodeID ((GlobalRANNodeID*)pvalue->value.
            u._RANConfigurationUpdateIEs_id_GlobalRANNodeID);

         stat = asn1PD_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.
            u._RANConfigurationUpdateIEs_id_GlobalRANNodeID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList */
      case ASN1V_id_NGRAN_TNLAssociationToRemoveList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList");

         pvalue->value.
            u._RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList
             = rtxMemAllocType (pctxt, NGRAN_TNLAssociationToRemoveList);

         if (pvalue->value.
            u._RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NGRAN_TNLAssociationToRemoveList (pvalue->value.
            u._RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList);

         stat = asn1PD_NGRAN_TNLAssociationToRemoveList (pctxt, pvalue->value.
            u._RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANConfigurationUpdateIEs_id_NB_IoT_DefaultPagingDRX */
      case ASN1V_id_NB_IoT_DefaultPagingDRX:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_NB_IoT_DefaultPagingDRX;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_NB_IoT_DefaultPagingDRX");

         stat = asn1PD_NB_IoT_DefaultPagingDRX (pctxt, &pvalue->value.
            u._RANConfigurationUpdateIEs_id_NB_IoT_DefaultPagingDRX);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANConfigurationUpdateIEs_id_Extended_RANNodeName */
      case ASN1V_id_Extended_RANNodeName:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_Extended_RANNodeName;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_Extended_RANNodeName");

         pvalue->value.u._RANConfigurationUpdateIEs_id_Extended_RANNodeName
             = rtxMemAllocType (pctxt, Extended_RANNodeName);

         if (pvalue->value.u._RANConfigurationUpdateIEs_id_Extended_RANNodeName
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Extended_RANNodeName ((Extended_RANNodeName*)pvalue->value.
            u._RANConfigurationUpdateIEs_id_Extended_RANNodeName);

         stat = asn1PD_Extended_RANNodeName (pctxt, (Extended_RANNodeName*)
            pvalue->value.u._RANConfigurationUpdateIEs_id_Extended_RANNodeName
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdate_protocolIEs (OSCTXT* pctxt, RANConfigurationUpdate_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RANConfigurationUpdate_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RANConfigurationUpdate_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RANConfigurationUpdate_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RANConfigurationUpdate_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdate (OSCTXT* pctxt, RANConfigurationUpdate* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANConfigurationUpdate");

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RANConfigurationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, RANConfigurationUpdateAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics (pvalue->value.
            u._RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue->value.
            u._RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_RANConfigurationUpdateAcknowledgeIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs (OSCTXT* pctxt, RANConfigurationUpdateAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RANConfigurationUpdateAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RANConfigurationUpdateAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RANConfigurationUpdateAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateAcknowledge (OSCTXT* pctxt, RANConfigurationUpdateAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANConfigurationUpdateAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateFailure_protocolIEs_element (OSCTXT* pctxt, RANConfigurationUpdateFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _RANConfigurationUpdateFailureIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateFailureIEs_id_Cause");

         pvalue->value.u._RANConfigurationUpdateFailureIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._RANConfigurationUpdateFailureIEs_id_Cause
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._RANConfigurationUpdateFailureIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._RANConfigurationUpdateFailureIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANConfigurationUpdateFailureIEs_id_TimeToWait */
      case ASN1V_id_TimeToWait:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_id_TimeToWait;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateFailureIEs_id_TimeToWait");

         stat = asn1PD_TimeToWait (pctxt, &pvalue->value.
            u._RANConfigurationUpdateFailureIEs_id_TimeToWait);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateFailure_protocolIEs (OSCTXT* pctxt, RANConfigurationUpdateFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RANConfigurationUpdateFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RANConfigurationUpdateFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RANConfigurationUpdateFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RANConfigurationUpdateFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateFailure (OSCTXT* pctxt, RANConfigurationUpdateFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANConfigurationUpdateFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RANConfigurationUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdate_protocolIEs_element (OSCTXT* pctxt, AMFConfigurationUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _AMFConfigurationUpdateIEs_id_AMFName */
      case ASN1V_id_AMFName:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMFName;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMFName");

         stat = asn1PD_AMFName (pctxt, &pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMFName);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateIEs_id_ServedGUAMIList */
      case ASN1V_id_ServedGUAMIList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_ServedGUAMIList;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_ServedGUAMIList");

         pvalue->value.u._AMFConfigurationUpdateIEs_id_ServedGUAMIList
             = rtxMemAllocType (pctxt, ServedGUAMIList);

         if (pvalue->value.u._AMFConfigurationUpdateIEs_id_ServedGUAMIList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ServedGUAMIList (pvalue->value.
            u._AMFConfigurationUpdateIEs_id_ServedGUAMIList);

         stat = asn1PD_ServedGUAMIList (pctxt, pvalue->value.
            u._AMFConfigurationUpdateIEs_id_ServedGUAMIList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateIEs_id_RelativeAMFCapacity */
      case ASN1V_id_RelativeAMFCapacity:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_RelativeAMFCapacity;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_RelativeAMFCapacity");

         stat = asn1PD_RelativeAMFCapacity (pctxt, &pvalue->value.
            u._AMFConfigurationUpdateIEs_id_RelativeAMFCapacity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateIEs_id_PLMNSupportList */
      case ASN1V_id_PLMNSupportList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_PLMNSupportList;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_PLMNSupportList");

         pvalue->value.u._AMFConfigurationUpdateIEs_id_PLMNSupportList
             = rtxMemAllocType (pctxt, PLMNSupportList);

         if (pvalue->value.u._AMFConfigurationUpdateIEs_id_PLMNSupportList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PLMNSupportList (pvalue->value.
            u._AMFConfigurationUpdateIEs_id_PLMNSupportList);

         stat = asn1PD_PLMNSupportList (pctxt, pvalue->value.
            u._AMFConfigurationUpdateIEs_id_PLMNSupportList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList */
      case ASN1V_id_AMF_TNLAssociationToAddList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList");

         pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList
             = rtxMemAllocType (pctxt, AMF_TNLAssociationToAddList);

         if (pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AMF_TNLAssociationToAddList (pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList);

         stat = asn1PD_AMF_TNLAssociationToAddList (pctxt, pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList */
      case ASN1V_id_AMF_TNLAssociationToRemoveList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList");

         pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList
             = rtxMemAllocType (pctxt, AMF_TNLAssociationToRemoveList);

         if (pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AMF_TNLAssociationToRemoveList (pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList);

         stat = asn1PD_AMF_TNLAssociationToRemoveList (pctxt, pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList */
      case ASN1V_id_AMF_TNLAssociationToUpdateList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList");

         pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList
             = rtxMemAllocType (pctxt, AMF_TNLAssociationToUpdateList);

         if (pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AMF_TNLAssociationToUpdateList (pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList);

         stat = asn1PD_AMF_TNLAssociationToUpdateList (pctxt, pvalue->value.
            u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateIEs_id_Extended_AMFName */
      case ASN1V_id_Extended_AMFName:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_Extended_AMFName;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_Extended_AMFName");

         pvalue->value.u._AMFConfigurationUpdateIEs_id_Extended_AMFName
             = rtxMemAllocType (pctxt, Extended_AMFName);

         if (pvalue->value.u._AMFConfigurationUpdateIEs_id_Extended_AMFName
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Extended_AMFName ((Extended_AMFName*)pvalue->value.
            u._AMFConfigurationUpdateIEs_id_Extended_AMFName);

         stat = asn1PD_Extended_AMFName (pctxt, (Extended_AMFName*)pvalue->
            value.u._AMFConfigurationUpdateIEs_id_Extended_AMFName);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdate_protocolIEs (OSCTXT* pctxt, AMFConfigurationUpdate_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMFConfigurationUpdate_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMFConfigurationUpdate_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMFConfigurationUpdate_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMFConfigurationUpdate_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdate (OSCTXT* pctxt, AMFConfigurationUpdate* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFConfigurationUpdate");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_AMFConfigurationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, AMFConfigurationUpdateAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList */
      case ASN1V_id_AMF_TNLAssociationSetupList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList");

         pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList
             = rtxMemAllocType (pctxt, AMF_TNLAssociationSetupList);

         if (pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AMF_TNLAssociationSetupList (pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList
            );

         stat = asn1PD_AMF_TNLAssociationSetupList (pctxt, pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList */
      case ASN1V_id_AMF_TNLAssociationFailedToSetupList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList");

         pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList
             = rtxMemAllocType (pctxt, TNLAssociationList);

         if (pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TNLAssociationList (pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList
            );

         stat = asn1PD_TNLAssociationList (pctxt, pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs (OSCTXT* pctxt, AMFConfigurationUpdateAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMFConfigurationUpdateAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMFConfigurationUpdateAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMFConfigurationUpdateAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateAcknowledge (OSCTXT* pctxt, AMFConfigurationUpdateAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFConfigurationUpdateAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateFailure_protocolIEs_element (OSCTXT* pctxt, AMFConfigurationUpdateFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _AMFConfigurationUpdateFailureIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateFailureIEs_id_Cause");

         pvalue->value.u._AMFConfigurationUpdateFailureIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._AMFConfigurationUpdateFailureIEs_id_Cause
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._AMFConfigurationUpdateFailureIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._AMFConfigurationUpdateFailureIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateFailureIEs_id_TimeToWait */
      case ASN1V_id_TimeToWait:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_id_TimeToWait;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateFailureIEs_id_TimeToWait");

         stat = asn1PD_TimeToWait (pctxt, &pvalue->value.
            u._AMFConfigurationUpdateFailureIEs_id_TimeToWait);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateFailure_protocolIEs (OSCTXT* pctxt, AMFConfigurationUpdateFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMFConfigurationUpdateFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMFConfigurationUpdateFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMFConfigurationUpdateFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMFConfigurationUpdateFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateFailure (OSCTXT* pctxt, AMFConfigurationUpdateFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFConfigurationUpdateFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_AMFConfigurationUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFStatusIndication_protocolIEs_element (OSCTXT* pctxt, AMFStatusIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _AMFStatusIndicationIEs_id_UnavailableGUAMIList */
      case ASN1V_id_UnavailableGUAMIList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFStatusIndicationIEs_id_UnavailableGUAMIList;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFStatusIndicationIEs_id_UnavailableGUAMIList");

         pvalue->value.u._AMFStatusIndicationIEs_id_UnavailableGUAMIList
             = rtxMemAllocType (pctxt, UnavailableGUAMIList);

         if (pvalue->value.u._AMFStatusIndicationIEs_id_UnavailableGUAMIList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UnavailableGUAMIList (pvalue->value.
            u._AMFStatusIndicationIEs_id_UnavailableGUAMIList);

         stat = asn1PD_UnavailableGUAMIList (pctxt, pvalue->value.
            u._AMFStatusIndicationIEs_id_UnavailableGUAMIList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_AMFStatusIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFStatusIndication_protocolIEs (OSCTXT* pctxt, AMFStatusIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMFStatusIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMFStatusIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMFStatusIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMFStatusIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFStatusIndication (OSCTXT* pctxt, AMFStatusIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFStatusIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_AMFStatusIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGReset_protocolIEs_element (OSCTXT* pctxt, NGReset_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _NGResetIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.t = T_NGAP_PDU_Contents_NGResetIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGResetIEs_id_Cause");

         pvalue->value.u._NGResetIEs_id_Cause = rtxMemAllocType (pctxt, 
            Cause);

         if (pvalue->value.u._NGResetIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.u._NGResetIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._NGResetIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGResetIEs_id_ResetType */
      case ASN1V_id_ResetType:
         pvalue->value.t = T_NGAP_PDU_Contents_NGResetIEs_id_ResetType;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGResetIEs_id_ResetType");

         pvalue->value.u._NGResetIEs_id_ResetType = rtxMemAllocType (pctxt, 
            ResetType);

         if (pvalue->value.u._NGResetIEs_id_ResetType == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ResetType ((ResetType*)pvalue->value.
            u._NGResetIEs_id_ResetType);

         stat = asn1PD_ResetType (pctxt, (ResetType*)pvalue->value.
            u._NGResetIEs_id_ResetType);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_NGResetIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGReset_protocolIEs (OSCTXT* pctxt, NGReset_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGReset_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGReset_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGReset_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGReset_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NGReset (OSCTXT* pctxt, NGReset* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGReset");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NGReset_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGResetAcknowledge_protocolIEs_element (OSCTXT* pctxt, NGResetAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList */
      case ASN1V_id_UE_associatedLogicalNG_connectionList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList");

         pvalue->value.
            u._NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList
             = rtxMemAllocType (pctxt, UE_associatedLogicalNG_connectionList);

         if (pvalue->value.
            u._NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_associatedLogicalNG_connectionList (pvalue->value.
            u._NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList
            );

         stat = asn1PD_UE_associatedLogicalNG_connectionList (pctxt, pvalue->
            value.
            u._NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _NGResetAcknowledgeIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_NGResetAcknowledgeIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_NGResetAcknowledgeIEs_id_CriticalityDiagnostics");

         pvalue->value.u._NGResetAcknowledgeIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.u._NGResetAcknowledgeIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._NGResetAcknowledgeIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.u._NGResetAcknowledgeIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_NGResetAcknowledgeIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGResetAcknowledge_protocolIEs (OSCTXT* pctxt, NGResetAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGResetAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGResetAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGResetAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGResetAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NGResetAcknowledge (OSCTXT* pctxt, NGResetAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGResetAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NGResetAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ErrorIndication_protocolIEs_element (OSCTXT* pctxt, ErrorIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _ErrorIndicationIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ErrorIndicationIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._ErrorIndicationIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ErrorIndicationIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ErrorIndicationIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._ErrorIndicationIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ErrorIndicationIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.t = T_NGAP_PDU_Contents_ErrorIndicationIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_Cause");

         pvalue->value.u._ErrorIndicationIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._ErrorIndicationIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.u._ErrorIndicationIEs_id_Cause
            );

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._ErrorIndicationIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ErrorIndicationIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ErrorIndicationIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_CriticalityDiagnostics");

         pvalue->value.u._ErrorIndicationIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.u._ErrorIndicationIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._ErrorIndicationIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.u._ErrorIndicationIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ErrorIndicationIEs_id_FiveG_S_TMSI */
      case ASN1V_id_FiveG_S_TMSI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ErrorIndicationIEs_id_FiveG_S_TMSI;

         RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_FiveG_S_TMSI");

         pvalue->value.u._ErrorIndicationIEs_id_FiveG_S_TMSI
             = rtxMemAllocType (pctxt, FiveG_S_TMSI);

         if (pvalue->value.u._ErrorIndicationIEs_id_FiveG_S_TMSI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FiveG_S_TMSI ((FiveG_S_TMSI*)pvalue->value.
            u._ErrorIndicationIEs_id_FiveG_S_TMSI);

         stat = asn1PD_FiveG_S_TMSI (pctxt, (FiveG_S_TMSI*)pvalue->value.
            u._ErrorIndicationIEs_id_FiveG_S_TMSI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_ErrorIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_ErrorIndication_protocolIEs (OSCTXT* pctxt, ErrorIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ErrorIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ErrorIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ErrorIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ErrorIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_ErrorIndication (OSCTXT* pctxt, ErrorIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ErrorIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_OverloadStart_protocolIEs_element (OSCTXT* pctxt, OverloadStart_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _OverloadStartIEs_id_AMFOverloadResponse */
      case ASN1V_id_AMFOverloadResponse:
         pvalue->value.
            t = T_NGAP_PDU_Contents_OverloadStartIEs_id_AMFOverloadResponse;

         RTXCTXTPUSHELEMNAME (pctxt, "_OverloadStartIEs_id_AMFOverloadResponse");

         pvalue->value.u._OverloadStartIEs_id_AMFOverloadResponse
             = rtxMemAllocType (pctxt, OverloadResponse);

         if (pvalue->value.u._OverloadStartIEs_id_AMFOverloadResponse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_OverloadResponse ((OverloadResponse*)pvalue->value.
            u._OverloadStartIEs_id_AMFOverloadResponse);

         stat = asn1PD_OverloadResponse (pctxt, (OverloadResponse*)pvalue->
            value.u._OverloadStartIEs_id_AMFOverloadResponse);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _OverloadStartIEs_id_AMFTrafficLoadReductionIndication */
      case ASN1V_id_AMFTrafficLoadReductionIndication:
         pvalue->value.
            t = T_NGAP_PDU_Contents_OverloadStartIEs_id_AMFTrafficLoadReductionIndication;

         RTXCTXTPUSHELEMNAME (pctxt, "_OverloadStartIEs_id_AMFTrafficLoadReductionIndication");

         stat = asn1PD_TrafficLoadReductionIndication (pctxt, &pvalue->value.
            u._OverloadStartIEs_id_AMFTrafficLoadReductionIndication);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _OverloadStartIEs_id_OverloadStartNSSAIList */
      case ASN1V_id_OverloadStartNSSAIList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_OverloadStartIEs_id_OverloadStartNSSAIList;

         RTXCTXTPUSHELEMNAME (pctxt, "_OverloadStartIEs_id_OverloadStartNSSAIList");

         pvalue->value.u._OverloadStartIEs_id_OverloadStartNSSAIList
             = rtxMemAllocType (pctxt, OverloadStartNSSAIList);

         if (pvalue->value.u._OverloadStartIEs_id_OverloadStartNSSAIList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_OverloadStartNSSAIList (pvalue->value.
            u._OverloadStartIEs_id_OverloadStartNSSAIList);

         stat = asn1PD_OverloadStartNSSAIList (pctxt, pvalue->value.
            u._OverloadStartIEs_id_OverloadStartNSSAIList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_OverloadStartIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadStart_protocolIEs (OSCTXT* pctxt, OverloadStart_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      OverloadStart_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, OverloadStart_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_OverloadStart_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_OverloadStart_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadStart (OSCTXT* pctxt, OverloadStart* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OverloadStart");

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_OverloadStart_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_OverloadStop_protocolIEs_element (OSCTXT* pctxt, OverloadStop_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadStop_protocolIEs (OSCTXT* pctxt, OverloadStop_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      OverloadStop_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, OverloadStop_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_OverloadStop_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_OverloadStop_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadStop (OSCTXT* pctxt, OverloadStop* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OverloadStop");

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_OverloadStop_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkRANConfigurationTransfer_protocolIEs_element (OSCTXT* pctxt, UplinkRANConfigurationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL */
      case ASN1V_id_SONConfigurationTransferUL:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL");

         pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL
             = rtxMemAllocType (pctxt, SONConfigurationTransfer);

         if (pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SONConfigurationTransfer ((SONConfigurationTransfer*)pvalue->
            value.
            u._UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL
            );

         stat = asn1PD_SONConfigurationTransfer (pctxt, 
            (SONConfigurationTransfer*)pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL */
      case ASN1V_id_ENDC_SONConfigurationTransferUL:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL");

         pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL
             = rtxMemAllocType (pctxt, EN_DCSONConfigurationTransfer);

         if (pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EN_DCSONConfigurationTransfer (pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL
            );

         stat = asn1PD_EN_DCSONConfigurationTransfer (pctxt, pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferUL */
      case ASN1V_id_IntersystemSONConfigurationTransferUL:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferUL;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferUL");

         pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferUL
             = rtxMemAllocType (pctxt, IntersystemSONConfigurationTransfer);

         if (pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferUL
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IntersystemSONConfigurationTransfer (
            (IntersystemSONConfigurationTransfer*)pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferUL
            );

         stat = asn1PD_IntersystemSONConfigurationTransfer (pctxt, 
            (IntersystemSONConfigurationTransfer*)pvalue->value.
            u._UplinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferUL
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UplinkRANConfigurationTransferIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRANConfigurationTransfer_protocolIEs (OSCTXT* pctxt, UplinkRANConfigurationTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkRANConfigurationTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkRANConfigurationTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkRANConfigurationTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkRANConfigurationTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRANConfigurationTransfer (OSCTXT* pctxt, UplinkRANConfigurationTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkRANConfigurationTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkRANConfigurationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkRANConfigurationTransfer_protocolIEs_element (OSCTXT* pctxt, DownlinkRANConfigurationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL */
      case ASN1V_id_SONConfigurationTransferDL:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL");

         pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL
             = rtxMemAllocType (pctxt, SONConfigurationTransfer);

         if (pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SONConfigurationTransfer ((SONConfigurationTransfer*)pvalue->
            value.
            u._DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL
            );

         stat = asn1PD_SONConfigurationTransfer (pctxt, 
            (SONConfigurationTransfer*)pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL */
      case ASN1V_id_ENDC_SONConfigurationTransferDL:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL");

         pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL
             = rtxMemAllocType (pctxt, EN_DCSONConfigurationTransfer);

         if (pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EN_DCSONConfigurationTransfer (pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL
            );

         stat = asn1PD_EN_DCSONConfigurationTransfer (pctxt, pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferDL */
      case ASN1V_id_IntersystemSONConfigurationTransferDL:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferDL;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferDL");

         pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferDL
             = rtxMemAllocType (pctxt, IntersystemSONConfigurationTransfer);

         if (pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferDL
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IntersystemSONConfigurationTransfer (
            (IntersystemSONConfigurationTransfer*)pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferDL
            );

         stat = asn1PD_IntersystemSONConfigurationTransfer (pctxt, 
            (IntersystemSONConfigurationTransfer*)pvalue->value.
            u._DownlinkRANConfigurationTransferIEs_id_IntersystemSONConfigurationTransferDL
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_DownlinkRANConfigurationTransferIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRANConfigurationTransfer_protocolIEs (OSCTXT* pctxt, DownlinkRANConfigurationTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkRANConfigurationTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkRANConfigurationTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkRANConfigurationTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkRANConfigurationTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRANConfigurationTransfer (OSCTXT* pctxt, DownlinkRANConfigurationTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkRANConfigurationTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkRANConfigurationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningRequest_protocolIEs_element (OSCTXT* pctxt, WriteReplaceWarningRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _WriteReplaceWarningRequestIEs_id_MessageIdentifier */
      case ASN1V_id_MessageIdentifier:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_MessageIdentifier;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_MessageIdentifier");

         pvalue->value.u._WriteReplaceWarningRequestIEs_id_MessageIdentifier
             = rtxMemAllocTypeZ (pctxt, MessageIdentifier);

         if (pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_MessageIdentifier == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MessageIdentifier (pctxt, pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_MessageIdentifier);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningRequestIEs_id_SerialNumber */
      case ASN1V_id_SerialNumber:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_SerialNumber;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_SerialNumber");

         pvalue->value.u._WriteReplaceWarningRequestIEs_id_SerialNumber
             = rtxMemAllocTypeZ (pctxt, SerialNumber);

         if (pvalue->value.u._WriteReplaceWarningRequestIEs_id_SerialNumber
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SerialNumber (pctxt, pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_SerialNumber);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningRequestIEs_id_WarningAreaList */
      case ASN1V_id_WarningAreaList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningAreaList;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningAreaList");

         pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningAreaList
             = rtxMemAllocType (pctxt, WarningAreaList);

         if (pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningAreaList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_WarningAreaList ((WarningAreaList*)pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_WarningAreaList);

         stat = asn1PD_WarningAreaList (pctxt, (WarningAreaList*)pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_WarningAreaList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningRequestIEs_id_RepetitionPeriod */
      case ASN1V_id_RepetitionPeriod:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_RepetitionPeriod;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_RepetitionPeriod");

         stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_RepetitionPeriod);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested */
      case ASN1V_id_NumberOfBroadcastsRequested:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested");

         stat = asn1PD_NumberOfBroadcastsRequested (pctxt, &pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningRequestIEs_id_WarningType */
      case ASN1V_id_WarningType:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningType;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningType");

         pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningType
             = rtxMemAllocTypeZ (pctxt, WarningType);

         if (pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningType
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_WarningType (pctxt, (WarningType*)pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_WarningType);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningRequestIEs_id_WarningSecurityInfo */
      case ASN1V_id_WarningSecurityInfo:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningSecurityInfo;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningSecurityInfo");

         pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningSecurityInfo
             = rtxMemAllocTypeZ (pctxt, WarningSecurityInfo);

         if (pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_WarningSecurityInfo == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_WarningSecurityInfo (pctxt, (WarningSecurityInfo*)pvalue
            ->value.u._WriteReplaceWarningRequestIEs_id_WarningSecurityInfo);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningRequestIEs_id_DataCodingScheme */
      case ASN1V_id_DataCodingScheme:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_DataCodingScheme;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_DataCodingScheme");

         pvalue->value.u._WriteReplaceWarningRequestIEs_id_DataCodingScheme
             = rtxMemAllocTypeZ (pctxt, DataCodingScheme);

         if (pvalue->value.u._WriteReplaceWarningRequestIEs_id_DataCodingScheme
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_DataCodingScheme (pctxt, pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_DataCodingScheme);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningRequestIEs_id_WarningMessageContents */
      case ASN1V_id_WarningMessageContents:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningMessageContents;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningMessageContents");

         pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_WarningMessageContents
             = rtxMemAllocType (pctxt, WarningMessageContents);

         if (pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_WarningMessageContents
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_WarningMessageContents ((WarningMessageContents*)pvalue->
            value.u._WriteReplaceWarningRequestIEs_id_WarningMessageContents);

         stat = asn1PD_WarningMessageContents (pctxt, (WarningMessageContents*)
            pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_WarningMessageContents);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd */
      case ASN1V_id_ConcurrentWarningMessageInd:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd");

         stat = asn1PD_ConcurrentWarningMessageInd (pctxt, &pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates */
      case ASN1V_id_WarningAreaCoordinates:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates");

         pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates
             = rtxMemAllocType (pctxt, WarningAreaCoordinates);

         if (pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_WarningAreaCoordinates ((WarningAreaCoordinates*)pvalue->
            value.u._WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates);

         stat = asn1PD_WarningAreaCoordinates (pctxt, (WarningAreaCoordinates*)
            pvalue->value.
            u._WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningRequest_protocolIEs (OSCTXT* pctxt, WriteReplaceWarningRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      WriteReplaceWarningRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, WriteReplaceWarningRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_WriteReplaceWarningRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_WriteReplaceWarningRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningRequest (OSCTXT* pctxt, WriteReplaceWarningRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "WriteReplaceWarningRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_WriteReplaceWarningRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningResponse_protocolIEs_element (OSCTXT* pctxt, WriteReplaceWarningResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _WriteReplaceWarningResponseIEs_id_MessageIdentifier */
      case ASN1V_id_MessageIdentifier:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_MessageIdentifier;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_MessageIdentifier");

         pvalue->value.u._WriteReplaceWarningResponseIEs_id_MessageIdentifier
             = rtxMemAllocTypeZ (pctxt, MessageIdentifier);

         if (pvalue->value.
            u._WriteReplaceWarningResponseIEs_id_MessageIdentifier == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MessageIdentifier (pctxt, pvalue->value.
            u._WriteReplaceWarningResponseIEs_id_MessageIdentifier);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningResponseIEs_id_SerialNumber */
      case ASN1V_id_SerialNumber:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_SerialNumber;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_SerialNumber");

         pvalue->value.u._WriteReplaceWarningResponseIEs_id_SerialNumber
             = rtxMemAllocTypeZ (pctxt, SerialNumber);

         if (pvalue->value.u._WriteReplaceWarningResponseIEs_id_SerialNumber
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SerialNumber (pctxt, pvalue->value.
            u._WriteReplaceWarningResponseIEs_id_SerialNumber);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList */
      case ASN1V_id_BroadcastCompletedAreaList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList");

         pvalue->value.
            u._WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList
             = rtxMemAllocType (pctxt, BroadcastCompletedAreaList);

         if (pvalue->value.
            u._WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BroadcastCompletedAreaList ((BroadcastCompletedAreaList*)
            pvalue->value.
            u._WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList);

         stat = asn1PD_BroadcastCompletedAreaList (pctxt, 
            (BroadcastCompletedAreaList*)pvalue->value.
            u._WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningResponse_protocolIEs (OSCTXT* pctxt, WriteReplaceWarningResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      WriteReplaceWarningResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, WriteReplaceWarningResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_WriteReplaceWarningResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_WriteReplaceWarningResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningResponse (OSCTXT* pctxt, WriteReplaceWarningResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "WriteReplaceWarningResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_WriteReplaceWarningResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PWSCancelRequest_protocolIEs_element (OSCTXT* pctxt, PWSCancelRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PWSCancelRequestIEs_id_MessageIdentifier */
      case ASN1V_id_MessageIdentifier:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_MessageIdentifier;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_MessageIdentifier");

         pvalue->value.u._PWSCancelRequestIEs_id_MessageIdentifier
             = rtxMemAllocTypeZ (pctxt, MessageIdentifier);

         if (pvalue->value.u._PWSCancelRequestIEs_id_MessageIdentifier
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MessageIdentifier (pctxt, pvalue->value.
            u._PWSCancelRequestIEs_id_MessageIdentifier);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PWSCancelRequestIEs_id_SerialNumber */
      case ASN1V_id_SerialNumber:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_SerialNumber;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_SerialNumber");

         pvalue->value.u._PWSCancelRequestIEs_id_SerialNumber
             = rtxMemAllocTypeZ (pctxt, SerialNumber);

         if (pvalue->value.u._PWSCancelRequestIEs_id_SerialNumber == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SerialNumber (pctxt, pvalue->value.
            u._PWSCancelRequestIEs_id_SerialNumber);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PWSCancelRequestIEs_id_WarningAreaList */
      case ASN1V_id_WarningAreaList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_WarningAreaList;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_WarningAreaList");

         pvalue->value.u._PWSCancelRequestIEs_id_WarningAreaList
             = rtxMemAllocType (pctxt, WarningAreaList);

         if (pvalue->value.u._PWSCancelRequestIEs_id_WarningAreaList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_WarningAreaList ((WarningAreaList*)pvalue->value.
            u._PWSCancelRequestIEs_id_WarningAreaList);

         stat = asn1PD_WarningAreaList (pctxt, (WarningAreaList*)pvalue->value.
            u._PWSCancelRequestIEs_id_WarningAreaList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PWSCancelRequestIEs_id_CancelAllWarningMessages */
      case ASN1V_id_CancelAllWarningMessages:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_CancelAllWarningMessages;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_CancelAllWarningMessages");

         stat = asn1PD_CancelAllWarningMessages (pctxt, &pvalue->value.
            u._PWSCancelRequestIEs_id_CancelAllWarningMessages);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PWSCancelRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSCancelRequest_protocolIEs (OSCTXT* pctxt, PWSCancelRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PWSCancelRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PWSCancelRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PWSCancelRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PWSCancelRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSCancelRequest (OSCTXT* pctxt, PWSCancelRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSCancelRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PWSCancelRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PWSCancelResponse_protocolIEs_element (OSCTXT* pctxt, PWSCancelResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PWSCancelResponseIEs_id_MessageIdentifier */
      case ASN1V_id_MessageIdentifier:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_MessageIdentifier;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_MessageIdentifier");

         pvalue->value.u._PWSCancelResponseIEs_id_MessageIdentifier
             = rtxMemAllocTypeZ (pctxt, MessageIdentifier);

         if (pvalue->value.u._PWSCancelResponseIEs_id_MessageIdentifier
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_MessageIdentifier (pctxt, pvalue->value.
            u._PWSCancelResponseIEs_id_MessageIdentifier);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PWSCancelResponseIEs_id_SerialNumber */
      case ASN1V_id_SerialNumber:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_SerialNumber;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_SerialNumber");

         pvalue->value.u._PWSCancelResponseIEs_id_SerialNumber
             = rtxMemAllocTypeZ (pctxt, SerialNumber);

         if (pvalue->value.u._PWSCancelResponseIEs_id_SerialNumber == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_SerialNumber (pctxt, pvalue->value.
            u._PWSCancelResponseIEs_id_SerialNumber);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PWSCancelResponseIEs_id_BroadcastCancelledAreaList */
      case ASN1V_id_BroadcastCancelledAreaList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_BroadcastCancelledAreaList;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_BroadcastCancelledAreaList");

         pvalue->value.u._PWSCancelResponseIEs_id_BroadcastCancelledAreaList
             = rtxMemAllocType (pctxt, BroadcastCancelledAreaList);

         if (pvalue->value.
            u._PWSCancelResponseIEs_id_BroadcastCancelledAreaList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BroadcastCancelledAreaList ((BroadcastCancelledAreaList*)
            pvalue->value.u._PWSCancelResponseIEs_id_BroadcastCancelledAreaList
            );

         stat = asn1PD_BroadcastCancelledAreaList (pctxt, 
            (BroadcastCancelledAreaList*)pvalue->value.
            u._PWSCancelResponseIEs_id_BroadcastCancelledAreaList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PWSCancelResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.u._PWSCancelResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.u._PWSCancelResponseIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.u._PWSCancelResponseIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.u._PWSCancelResponseIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PWSCancelResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSCancelResponse_protocolIEs (OSCTXT* pctxt, PWSCancelResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PWSCancelResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PWSCancelResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PWSCancelResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PWSCancelResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSCancelResponse (OSCTXT* pctxt, PWSCancelResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSCancelResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PWSCancelResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PWSRestartIndication_protocolIEs_element (OSCTXT* pctxt, PWSRestartIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PWSRestartIndicationIEs_id_CellIDListForRestart */
      case ASN1V_id_CellIDListForRestart:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_CellIDListForRestart;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_CellIDListForRestart");

         pvalue->value.u._PWSRestartIndicationIEs_id_CellIDListForRestart
             = rtxMemAllocType (pctxt, CellIDListForRestart);

         if (pvalue->value.u._PWSRestartIndicationIEs_id_CellIDListForRestart
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CellIDListForRestart ((CellIDListForRestart*)pvalue->value.
            u._PWSRestartIndicationIEs_id_CellIDListForRestart);

         stat = asn1PD_CellIDListForRestart (pctxt, (CellIDListForRestart*)
            pvalue->value.u._PWSRestartIndicationIEs_id_CellIDListForRestart);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PWSRestartIndicationIEs_id_GlobalRANNodeID */
      case ASN1V_id_GlobalRANNodeID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_GlobalRANNodeID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_GlobalRANNodeID");

         pvalue->value.u._PWSRestartIndicationIEs_id_GlobalRANNodeID
             = rtxMemAllocType (pctxt, GlobalRANNodeID);

         if (pvalue->value.u._PWSRestartIndicationIEs_id_GlobalRANNodeID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GlobalRANNodeID ((GlobalRANNodeID*)pvalue->value.
            u._PWSRestartIndicationIEs_id_GlobalRANNodeID);

         stat = asn1PD_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.
            u._PWSRestartIndicationIEs_id_GlobalRANNodeID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PWSRestartIndicationIEs_id_TAIListForRestart */
      case ASN1V_id_TAIListForRestart:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_TAIListForRestart;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_TAIListForRestart");

         pvalue->value.u._PWSRestartIndicationIEs_id_TAIListForRestart
             = rtxMemAllocType (pctxt, TAIListForRestart);

         if (pvalue->value.u._PWSRestartIndicationIEs_id_TAIListForRestart
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TAIListForRestart (pvalue->value.
            u._PWSRestartIndicationIEs_id_TAIListForRestart);

         stat = asn1PD_TAIListForRestart (pctxt, pvalue->value.
            u._PWSRestartIndicationIEs_id_TAIListForRestart);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart */
      case ASN1V_id_EmergencyAreaIDListForRestart:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart");

         pvalue->value.
            u._PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart
             = rtxMemAllocType (pctxt, EmergencyAreaIDListForRestart);

         if (pvalue->value.
            u._PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EmergencyAreaIDListForRestart (
            (EmergencyAreaIDListForRestart*)pvalue->value.
            u._PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart);

         stat = asn1PD_EmergencyAreaIDListForRestart (pctxt, 
            (EmergencyAreaIDListForRestart*)pvalue->value.
            u._PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PWSRestartIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSRestartIndication_protocolIEs (OSCTXT* pctxt, PWSRestartIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PWSRestartIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PWSRestartIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PWSRestartIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PWSRestartIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSRestartIndication (OSCTXT* pctxt, PWSRestartIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSRestartIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PWSRestartIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PWSFailureIndication_protocolIEs_element (OSCTXT* pctxt, PWSFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _PWSFailureIndicationIEs_id_PWSFailedCellIDList */
      case ASN1V_id_PWSFailedCellIDList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSFailureIndicationIEs_id_PWSFailedCellIDList;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSFailureIndicationIEs_id_PWSFailedCellIDList");

         pvalue->value.u._PWSFailureIndicationIEs_id_PWSFailedCellIDList
             = rtxMemAllocType (pctxt, PWSFailedCellIDList);

         if (pvalue->value.u._PWSFailureIndicationIEs_id_PWSFailedCellIDList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PWSFailedCellIDList ((PWSFailedCellIDList*)pvalue->value.
            u._PWSFailureIndicationIEs_id_PWSFailedCellIDList);

         stat = asn1PD_PWSFailedCellIDList (pctxt, (PWSFailedCellIDList*)pvalue
            ->value.u._PWSFailureIndicationIEs_id_PWSFailedCellIDList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _PWSFailureIndicationIEs_id_GlobalRANNodeID */
      case ASN1V_id_GlobalRANNodeID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_PWSFailureIndicationIEs_id_GlobalRANNodeID;

         RTXCTXTPUSHELEMNAME (pctxt, "_PWSFailureIndicationIEs_id_GlobalRANNodeID");

         pvalue->value.u._PWSFailureIndicationIEs_id_GlobalRANNodeID
             = rtxMemAllocType (pctxt, GlobalRANNodeID);

         if (pvalue->value.u._PWSFailureIndicationIEs_id_GlobalRANNodeID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GlobalRANNodeID ((GlobalRANNodeID*)pvalue->value.
            u._PWSFailureIndicationIEs_id_GlobalRANNodeID);

         stat = asn1PD_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.
            u._PWSFailureIndicationIEs_id_GlobalRANNodeID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_PWSFailureIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSFailureIndication_protocolIEs (OSCTXT* pctxt, PWSFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PWSFailureIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PWSFailureIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PWSFailureIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PWSFailureIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSFailureIndication (OSCTXT* pctxt, PWSFailureIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSFailureIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PWSFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, DownlinkUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID */
      case ASN1V_id_RoutingID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID");

         pvalue->value.u._DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID
             = rtxMemAllocType (pctxt, RoutingID);

         if (pvalue->value.
            u._DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RoutingID (pvalue->value.
            u._DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID);

         stat = asn1PD_RoutingID (pctxt, pvalue->value.
            u._DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
      case ASN1V_id_NRPPa_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

         pvalue->value.u._DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
             = rtxMemAllocType (pctxt, NRPPa_PDU);

         if (pvalue->value.
            u._DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRPPa_PDU (pvalue->value.
            u._DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);

         stat = asn1PD_NRPPa_PDU (pctxt, pvalue->value.
            u._DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, DownlinkUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkUEAssociatedNRPPaTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkUEAssociatedNRPPaTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkUEAssociatedNRPPaTransport (OSCTXT* pctxt, DownlinkUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, UplinkUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID */
      case ASN1V_id_RoutingID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID");

         pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID
             = rtxMemAllocType (pctxt, RoutingID);

         if (pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RoutingID (pvalue->value.
            u._UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID);

         stat = asn1PD_RoutingID (pctxt, pvalue->value.
            u._UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
      case ASN1V_id_NRPPa_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

         pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
             = rtxMemAllocType (pctxt, NRPPa_PDU);

         if (pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRPPa_PDU (pvalue->value.
            u._UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);

         stat = asn1PD_NRPPa_PDU (pctxt, pvalue->value.
            u._UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, UplinkUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkUEAssociatedNRPPaTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkUEAssociatedNRPPaTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkUEAssociatedNRPPaTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkUEAssociatedNRPPaTransport (OSCTXT* pctxt, UplinkUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID */
      case ASN1V_id_RoutingID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID");

         pvalue->value.u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID
             = rtxMemAllocType (pctxt, RoutingID);

         if (pvalue->value.
            u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RoutingID (pvalue->value.
            u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID);

         stat = asn1PD_RoutingID (pctxt, pvalue->value.
            u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
      case ASN1V_id_NRPPa_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

         pvalue->value.u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
             = rtxMemAllocType (pctxt, NRPPa_PDU);

         if (pvalue->value.
            u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRPPa_PDU (pvalue->value.
            u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);

         stat = asn1PD_NRPPa_PDU (pctxt, pvalue->value.
            u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_DownlinkNonUEAssociatedNRPPaTransportIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, DownlinkNonUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkNonUEAssociatedNRPPaTransport (OSCTXT* pctxt, DownlinkNonUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkNonUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID */
      case ASN1V_id_RoutingID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID");

         pvalue->value.u._UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID
             = rtxMemAllocType (pctxt, RoutingID);

         if (pvalue->value.
            u._UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RoutingID (pvalue->value.
            u._UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID);

         stat = asn1PD_RoutingID (pctxt, pvalue->value.
            u._UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
      case ASN1V_id_NRPPa_PDU:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

         pvalue->value.u._UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
             = rtxMemAllocType (pctxt, NRPPa_PDU);

         if (pvalue->value.
            u._UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NRPPa_PDU (pvalue->value.
            u._UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);

         stat = asn1PD_NRPPa_PDU (pctxt, pvalue->value.
            u._UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UplinkNonUEAssociatedNRPPaTransportIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, UplinkNonUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkNonUEAssociatedNRPPaTransport (OSCTXT* pctxt, UplinkNonUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkNonUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TraceStart_protocolIEs_element (OSCTXT* pctxt, TraceStart_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _TraceStartIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_TraceStartIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_TraceStartIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._TraceStartIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _TraceStartIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_TraceStartIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_TraceStartIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._TraceStartIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _TraceStartIEs_id_TraceActivation */
      case ASN1V_id_TraceActivation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_TraceStartIEs_id_TraceActivation;

         RTXCTXTPUSHELEMNAME (pctxt, "_TraceStartIEs_id_TraceActivation");

         pvalue->value.u._TraceStartIEs_id_TraceActivation
             = rtxMemAllocType (pctxt, TraceActivation);

         if (pvalue->value.u._TraceStartIEs_id_TraceActivation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TraceActivation ((TraceActivation*)pvalue->value.
            u._TraceStartIEs_id_TraceActivation);

         stat = asn1PD_TraceActivation (pctxt, (TraceActivation*)pvalue->value.
            u._TraceStartIEs_id_TraceActivation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_TraceStartIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TraceStart_protocolIEs (OSCTXT* pctxt, TraceStart_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TraceStart_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TraceStart_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TraceStart_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TraceStart_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_TraceStart (OSCTXT* pctxt, TraceStart* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceStart");

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_TraceStart_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TraceFailureIndication_protocolIEs_element (OSCTXT* pctxt, TraceFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _TraceFailureIndicationIEs_id_NGRANTraceID */
      case ASN1V_id_NGRANTraceID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_NGRANTraceID;

         RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_NGRANTraceID");

         pvalue->value.u._TraceFailureIndicationIEs_id_NGRANTraceID
             = rtxMemAllocTypeZ (pctxt, NGRANTraceID);

         if (pvalue->value.u._TraceFailureIndicationIEs_id_NGRANTraceID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_NGRANTraceID (pctxt, (NGRANTraceID*)pvalue->value.
            u._TraceFailureIndicationIEs_id_NGRANTraceID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _TraceFailureIndicationIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_Cause");

         pvalue->value.u._TraceFailureIndicationIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._TraceFailureIndicationIEs_id_Cause == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._TraceFailureIndicationIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._TraceFailureIndicationIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_TraceFailureIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TraceFailureIndication_protocolIEs (OSCTXT* pctxt, TraceFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TraceFailureIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TraceFailureIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TraceFailureIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TraceFailureIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_TraceFailureIndication (OSCTXT* pctxt, TraceFailureIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceFailureIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_TraceFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DeactivateTrace_protocolIEs_element (OSCTXT* pctxt, DeactivateTrace_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _DeactivateTraceIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DeactivateTraceIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DeactivateTraceIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._DeactivateTraceIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DeactivateTraceIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DeactivateTraceIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DeactivateTraceIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._DeactivateTraceIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _DeactivateTraceIEs_id_NGRANTraceID */
      case ASN1V_id_NGRANTraceID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DeactivateTraceIEs_id_NGRANTraceID;

         RTXCTXTPUSHELEMNAME (pctxt, "_DeactivateTraceIEs_id_NGRANTraceID");

         pvalue->value.u._DeactivateTraceIEs_id_NGRANTraceID
             = rtxMemAllocTypeZ (pctxt, NGRANTraceID);

         if (pvalue->value.u._DeactivateTraceIEs_id_NGRANTraceID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_NGRANTraceID (pctxt, (NGRANTraceID*)pvalue->value.
            u._DeactivateTraceIEs_id_NGRANTraceID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_DeactivateTraceIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DeactivateTrace_protocolIEs (OSCTXT* pctxt, DeactivateTrace_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DeactivateTrace_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DeactivateTrace_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DeactivateTrace_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DeactivateTrace_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DeactivateTrace (OSCTXT* pctxt, DeactivateTrace* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DeactivateTrace");

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DeactivateTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellTrafficTrace_protocolIEs_element (OSCTXT* pctxt, CellTrafficTrace_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _CellTrafficTraceIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._CellTrafficTraceIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _CellTrafficTraceIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._CellTrafficTraceIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _CellTrafficTraceIEs_id_NGRANTraceID */
      case ASN1V_id_NGRANTraceID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_NGRANTraceID;

         RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_NGRANTraceID");

         pvalue->value.u._CellTrafficTraceIEs_id_NGRANTraceID
             = rtxMemAllocTypeZ (pctxt, NGRANTraceID);

         if (pvalue->value.u._CellTrafficTraceIEs_id_NGRANTraceID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = asn1PD_NGRANTraceID (pctxt, (NGRANTraceID*)pvalue->value.
            u._CellTrafficTraceIEs_id_NGRANTraceID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _CellTrafficTraceIEs_id_NGRAN_CGI */
      case ASN1V_id_NGRAN_CGI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_NGRAN_CGI;

         RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_NGRAN_CGI");

         pvalue->value.u._CellTrafficTraceIEs_id_NGRAN_CGI
             = rtxMemAllocType (pctxt, NGRAN_CGI);

         if (pvalue->value.u._CellTrafficTraceIEs_id_NGRAN_CGI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NGRAN_CGI ((NGRAN_CGI*)pvalue->value.
            u._CellTrafficTraceIEs_id_NGRAN_CGI);

         stat = asn1PD_NGRAN_CGI (pctxt, (NGRAN_CGI*)pvalue->value.
            u._CellTrafficTraceIEs_id_NGRAN_CGI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress */
      case ASN1V_id_TraceCollectionEntityIPAddress:
         pvalue->value.
            t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress;

         RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress");

         pvalue->value.u._CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress
             = rtxMemAllocType (pctxt, TransportLayerAddress);

         if (pvalue->value.
            u._CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TransportLayerAddress (pvalue->value.
            u._CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress);

         stat = asn1PD_TransportLayerAddress (pctxt, pvalue->value.
            u._CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _CellTrafficTraceIEs_id_PrivacyIndicator */
      case ASN1V_id_PrivacyIndicator:
         pvalue->value.
            t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_PrivacyIndicator;

         RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_PrivacyIndicator");

         stat = asn1PD_PrivacyIndicator (pctxt, &pvalue->value.
            u._CellTrafficTraceIEs_id_PrivacyIndicator);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _CellTrafficTraceIEs_id_TraceCollectionEntityURI */
      case ASN1V_id_TraceCollectionEntityURI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_TraceCollectionEntityURI;

         RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_TraceCollectionEntityURI");

         stat = asn1PD_URI_address (pctxt, &pvalue->value.
            u._CellTrafficTraceIEs_id_TraceCollectionEntityURI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CellTrafficTrace_protocolIEs (OSCTXT* pctxt, CellTrafficTrace_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellTrafficTrace_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CellTrafficTrace_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellTrafficTrace_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellTrafficTrace_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_CellTrafficTrace (OSCTXT* pctxt, CellTrafficTrace* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CellTrafficTrace");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_CellTrafficTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LocationReportingControl_protocolIEs_element (OSCTXT* pctxt, LocationReportingControl_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _LocationReportingControlIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportingControlIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingControlIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._LocationReportingControlIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _LocationReportingControlIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportingControlIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingControlIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._LocationReportingControlIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _LocationReportingControlIEs_id_LocationReportingRequestType */
      case ASN1V_id_LocationReportingRequestType:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportingControlIEs_id_LocationReportingRequestType;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingControlIEs_id_LocationReportingRequestType");

         pvalue->value.
            u._LocationReportingControlIEs_id_LocationReportingRequestType
             = rtxMemAllocType (pctxt, LocationReportingRequestType);

         if (pvalue->value.
            u._LocationReportingControlIEs_id_LocationReportingRequestType
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LocationReportingRequestType ((LocationReportingRequestType*)
            pvalue->value.
            u._LocationReportingControlIEs_id_LocationReportingRequestType);

         stat = asn1PD_LocationReportingRequestType (pctxt, 
            (LocationReportingRequestType*)pvalue->value.
            u._LocationReportingControlIEs_id_LocationReportingRequestType);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_LocationReportingControlIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReportingControl_protocolIEs (OSCTXT* pctxt, LocationReportingControl_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LocationReportingControl_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, LocationReportingControl_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReportingControl_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LocationReportingControl_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReportingControl (OSCTXT* pctxt, LocationReportingControl* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingControl");

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_LocationReportingControl_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LocationReportingFailureIndication_protocolIEs_element (OSCTXT* pctxt, LocationReportingFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _LocationReportingFailureIndicationIEs_id_Cause */
      case ASN1V_id_Cause:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_id_Cause;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingFailureIndicationIEs_id_Cause");

         pvalue->value.u._LocationReportingFailureIndicationIEs_id_Cause
             = rtxMemAllocType (pctxt, Cause);

         if (pvalue->value.u._LocationReportingFailureIndicationIEs_id_Cause
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Cause ((Cause*)pvalue->value.
            u._LocationReportingFailureIndicationIEs_id_Cause);

         stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
            u._LocationReportingFailureIndicationIEs_id_Cause);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReportingFailureIndication_protocolIEs (OSCTXT* pctxt, LocationReportingFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LocationReportingFailureIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, LocationReportingFailureIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReportingFailureIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LocationReportingFailureIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReportingFailureIndication (OSCTXT* pctxt, LocationReportingFailureIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingFailureIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_LocationReportingFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LocationReport_protocolIEs_element (OSCTXT* pctxt, LocationReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _LocationReportIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._LocationReportIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _LocationReportIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._LocationReportIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _LocationReportIEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportIEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_UserLocationInformation");

         pvalue->value.u._LocationReportIEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.u._LocationReportIEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.u._LocationReportIEs_id_UserLocationInformation);

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._LocationReportIEs_id_UserLocationInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _LocationReportIEs_id_UEPresenceInAreaOfInterestList */
      case ASN1V_id_UEPresenceInAreaOfInterestList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportIEs_id_UEPresenceInAreaOfInterestList;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_UEPresenceInAreaOfInterestList");

         pvalue->value.u._LocationReportIEs_id_UEPresenceInAreaOfInterestList
             = rtxMemAllocType (pctxt, UEPresenceInAreaOfInterestList);

         if (pvalue->value.
            u._LocationReportIEs_id_UEPresenceInAreaOfInterestList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UEPresenceInAreaOfInterestList (pvalue->value.
            u._LocationReportIEs_id_UEPresenceInAreaOfInterestList);

         stat = asn1PD_UEPresenceInAreaOfInterestList (pctxt, pvalue->value.
            u._LocationReportIEs_id_UEPresenceInAreaOfInterestList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _LocationReportIEs_id_LocationReportingRequestType */
      case ASN1V_id_LocationReportingRequestType:
         pvalue->value.
            t = T_NGAP_PDU_Contents_LocationReportIEs_id_LocationReportingRequestType;

         RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_LocationReportingRequestType");

         pvalue->value.u._LocationReportIEs_id_LocationReportingRequestType
             = rtxMemAllocType (pctxt, LocationReportingRequestType);

         if (pvalue->value.u._LocationReportIEs_id_LocationReportingRequestType
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LocationReportingRequestType ((LocationReportingRequestType*)
            pvalue->value.u._LocationReportIEs_id_LocationReportingRequestType
            );

         stat = asn1PD_LocationReportingRequestType (pctxt, 
            (LocationReportingRequestType*)pvalue->value.
            u._LocationReportIEs_id_LocationReportingRequestType);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_LocationReportIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReport_protocolIEs (OSCTXT* pctxt, LocationReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LocationReport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, LocationReport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LocationReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReport (OSCTXT* pctxt, LocationReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReport");

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_LocationReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UETNLABindingReleaseRequest_protocolIEs_element (OSCTXT* pctxt, UETNLABindingReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UETNLABindingReleaseRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UETNLABindingReleaseRequest_protocolIEs (OSCTXT* pctxt, UETNLABindingReleaseRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UETNLABindingReleaseRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UETNLABindingReleaseRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UETNLABindingReleaseRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UETNLABindingReleaseRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UETNLABindingReleaseRequest (OSCTXT* pctxt, UETNLABindingReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UETNLABindingReleaseRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UETNLABindingReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityInfoIndication_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityInfoIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityInfoIndicationIEs_id_UERadioCapability */
      case ASN1V_id_UERadioCapability:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_UERadioCapability;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_UERadioCapability");

         pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability
             = rtxMemAllocType (pctxt, UERadioCapability);

         if (pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapability (pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability);

         stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging */
      case ASN1V_id_UERadioCapabilityForPaging:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging");

         pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging
             = rtxMemAllocType (pctxt, UERadioCapabilityForPaging);

         if (pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityForPaging ((UERadioCapabilityForPaging*)
            pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging
            );

         stat = asn1PD_UERadioCapabilityForPaging (pctxt, 
            (UERadioCapabilityForPaging*)pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityInfoIndicationIEs_id_UERadioCapability_EUTRA_Format */
      case ASN1V_id_UERadioCapability_EUTRA_Format:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_UERadioCapability_EUTRA_Format;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_UERadioCapability_EUTRA_Format");

         pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability_EUTRA_Format
             = rtxMemAllocType (pctxt, UERadioCapability);

         if (pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability_EUTRA_Format
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapability (pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability_EUTRA_Format
            );

         stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
            u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability_EUTRA_Format
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityInfoIndication_protocolIEs (OSCTXT* pctxt, UERadioCapabilityInfoIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UERadioCapabilityInfoIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UERadioCapabilityInfoIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityInfoIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UERadioCapabilityInfoIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityInfoIndication (OSCTXT* pctxt, UERadioCapabilityInfoIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityInfoIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UERadioCapabilityInfoIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckRequest_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityCheckRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityCheckRequestIEs_id_UERadioCapability */
      case ASN1V_id_UERadioCapability:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_id_UERadioCapability;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckRequestIEs_id_UERadioCapability");

         pvalue->value.u._UERadioCapabilityCheckRequestIEs_id_UERadioCapability
             = rtxMemAllocType (pctxt, UERadioCapability);

         if (pvalue->value.
            u._UERadioCapabilityCheckRequestIEs_id_UERadioCapability == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapability (pvalue->value.
            u._UERadioCapabilityCheckRequestIEs_id_UERadioCapability);

         stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
            u._UERadioCapabilityCheckRequestIEs_id_UERadioCapability);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityCheckRequestIEs_id_UERadioCapabilityID */
      case ASN1V_id_UERadioCapabilityID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_id_UERadioCapabilityID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckRequestIEs_id_UERadioCapabilityID");

         pvalue->value.
            u._UERadioCapabilityCheckRequestIEs_id_UERadioCapabilityID
             = rtxMemAllocType (pctxt, UERadioCapabilityID);

         if (pvalue->value.
            u._UERadioCapabilityCheckRequestIEs_id_UERadioCapabilityID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityID (pvalue->value.
            u._UERadioCapabilityCheckRequestIEs_id_UERadioCapabilityID);

         stat = asn1PD_UERadioCapabilityID (pctxt, pvalue->value.
            u._UERadioCapabilityCheckRequestIEs_id_UERadioCapabilityID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckRequest_protocolIEs (OSCTXT* pctxt, UERadioCapabilityCheckRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UERadioCapabilityCheckRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UERadioCapabilityCheckRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityCheckRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UERadioCapabilityCheckRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckRequest (OSCTXT* pctxt, UERadioCapabilityCheckRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityCheckRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UERadioCapabilityCheckRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckResponse_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityCheckResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator */
      case ASN1V_id_IMSVoiceSupportIndicator:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator");

         stat = asn1PD_IMSVoiceSupportIndicator (pctxt, &pvalue->value.
            u._UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.
            u._UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics);

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckResponse_protocolIEs (OSCTXT* pctxt, UERadioCapabilityCheckResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UERadioCapabilityCheckResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UERadioCapabilityCheckResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityCheckResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UERadioCapabilityCheckResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckResponse (OSCTXT* pctxt, UERadioCapabilityCheckResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityCheckResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UERadioCapabilityCheckResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PrivateMessage_privateIEs_element (OSCTXT* pctxt, PrivateMessage_privateIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage_privateIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_PrivateIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage_privateIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PrivateMessage_privateIEs (OSCTXT* pctxt, PrivateMessage_privateIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage_privateIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PrivateMessage_privateIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PrivateMessage_privateIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PrivateMessage_privateIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PrivateMessage_privateIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage_privateIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PrivateMessage (OSCTXT* pctxt, PrivateMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateMessage");

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode privateIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "privateIEs");

   stat = asn1PD_PrivateMessage_privateIEs (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecondaryRATDataUsageReport_protocolIEs_element (OSCTXT* pctxt, SecondaryRATDataUsageReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList */
      case ASN1V_id_PDUSessionResourceSecondaryRATUsageList:
         pvalue->value.
            t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList;

         RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList");

         pvalue->value.
            u._SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList
             = rtxMemAllocType (pctxt, 
            PDUSessionResourceSecondaryRATUsageList);

         if (pvalue->value.
            u._SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PDUSessionResourceSecondaryRATUsageList (pvalue->value.
            u._SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList
            );

         stat = asn1PD_PDUSessionResourceSecondaryRATUsageList (pctxt, pvalue->
            value.
            u._SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _SecondaryRATDataUsageReportIEs_id_HandoverFlag */
      case ASN1V_id_HandoverFlag:
         pvalue->value.
            t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_HandoverFlag;

         RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_HandoverFlag");

         stat = asn1PD_HandoverFlag (pctxt, &pvalue->value.
            u._SecondaryRATDataUsageReportIEs_id_HandoverFlag);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _SecondaryRATDataUsageReportIEs_id_UserLocationInformation */
      case ASN1V_id_UserLocationInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_UserLocationInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_UserLocationInformation");

         pvalue->value.
            u._SecondaryRATDataUsageReportIEs_id_UserLocationInformation
             = rtxMemAllocType (pctxt, UserLocationInformation);

         if (pvalue->value.
            u._SecondaryRATDataUsageReportIEs_id_UserLocationInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->
            value.u._SecondaryRATDataUsageReportIEs_id_UserLocationInformation
            );

         stat = asn1PD_UserLocationInformation (pctxt, 
            (UserLocationInformation*)pvalue->value.
            u._SecondaryRATDataUsageReportIEs_id_UserLocationInformation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SecondaryRATDataUsageReport_protocolIEs (OSCTXT* pctxt, SecondaryRATDataUsageReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SecondaryRATDataUsageReport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SecondaryRATDataUsageReport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecondaryRATDataUsageReport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SecondaryRATDataUsageReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_SecondaryRATDataUsageReport (OSCTXT* pctxt, SecondaryRATDataUsageReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SecondaryRATDataUsageReport");

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_SecondaryRATDataUsageReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkRIMInformationTransfer_protocolIEs_element (OSCTXT* pctxt, UplinkRIMInformationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRIMInformationTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UplinkRIMInformationTransferIEs_id_RIMInformationTransfer */
      case ASN1V_id_RIMInformationTransfer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UplinkRIMInformationTransferIEs_id_RIMInformationTransfer;

         RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRIMInformationTransferIEs_id_RIMInformationTransfer");

         pvalue->value.
            u._UplinkRIMInformationTransferIEs_id_RIMInformationTransfer
             = rtxMemAllocType (pctxt, RIMInformationTransfer);

         if (pvalue->value.
            u._UplinkRIMInformationTransferIEs_id_RIMInformationTransfer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RIMInformationTransfer (pvalue->value.
            u._UplinkRIMInformationTransferIEs_id_RIMInformationTransfer);

         stat = asn1PD_RIMInformationTransfer (pctxt, pvalue->value.
            u._UplinkRIMInformationTransferIEs_id_RIMInformationTransfer);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UplinkRIMInformationTransferIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRIMInformationTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRIMInformationTransfer_protocolIEs (OSCTXT* pctxt, UplinkRIMInformationTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRIMInformationTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkRIMInformationTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkRIMInformationTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkRIMInformationTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkRIMInformationTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRIMInformationTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRIMInformationTransfer (OSCTXT* pctxt, UplinkRIMInformationTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkRIMInformationTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRIMInformationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkRIMInformationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRIMInformationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkRIMInformationTransfer_protocolIEs_element (OSCTXT* pctxt, DownlinkRIMInformationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRIMInformationTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _DownlinkRIMInformationTransferIEs_id_RIMInformationTransfer */
      case ASN1V_id_RIMInformationTransfer:
         pvalue->value.
            t = T_NGAP_PDU_Contents_DownlinkRIMInformationTransferIEs_id_RIMInformationTransfer;

         RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRIMInformationTransferIEs_id_RIMInformationTransfer");

         pvalue->value.
            u._DownlinkRIMInformationTransferIEs_id_RIMInformationTransfer
             = rtxMemAllocType (pctxt, RIMInformationTransfer);

         if (pvalue->value.
            u._DownlinkRIMInformationTransferIEs_id_RIMInformationTransfer
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RIMInformationTransfer (pvalue->value.
            u._DownlinkRIMInformationTransferIEs_id_RIMInformationTransfer);

         stat = asn1PD_RIMInformationTransfer (pctxt, pvalue->value.
            u._DownlinkRIMInformationTransferIEs_id_RIMInformationTransfer);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_DownlinkRIMInformationTransferIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRIMInformationTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRIMInformationTransfer_protocolIEs (OSCTXT* pctxt, DownlinkRIMInformationTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRIMInformationTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkRIMInformationTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkRIMInformationTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkRIMInformationTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkRIMInformationTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRIMInformationTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRIMInformationTransfer (OSCTXT* pctxt, DownlinkRIMInformationTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkRIMInformationTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRIMInformationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkRIMInformationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRIMInformationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ConnectionEstablishmentIndication_protocolIEs_element (OSCTXT* pctxt, ConnectionEstablishmentIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectionEstablishmentIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _ConnectionEstablishmentIndicationIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_UERadioCapability */
      case ASN1V_id_UERadioCapability:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_UERadioCapability;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_UERadioCapability");

         pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UERadioCapability
             = rtxMemAllocType (pctxt, UERadioCapability);

         if (pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UERadioCapability
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapability (pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UERadioCapability);

         stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UERadioCapability);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_EndIndication */
      case ASN1V_id_EndIndication:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_EndIndication;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_EndIndication");

         stat = asn1PD_EndIndication (pctxt, &pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_EndIndication);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_S_NSSAI */
      case ASN1V_id_S_NSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_S_NSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_S_NSSAI");

         pvalue->value.u._ConnectionEstablishmentIndicationIEs_id_S_NSSAI
             = rtxMemAllocType (pctxt, S_NSSAI);

         if (pvalue->value.u._ConnectionEstablishmentIndicationIEs_id_S_NSSAI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_S_NSSAI ((S_NSSAI*)pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_S_NSSAI);

         stat = asn1PD_S_NSSAI (pctxt, (S_NSSAI*)pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_S_NSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_AllowedNSSAI */
      case ASN1V_id_AllowedNSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_AllowedNSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_AllowedNSSAI");

         pvalue->value.u._ConnectionEstablishmentIndicationIEs_id_AllowedNSSAI
             = rtxMemAllocType (pctxt, AllowedNSSAI);

         if (pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_AllowedNSSAI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AllowedNSSAI (pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_AllowedNSSAI);

         stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_AllowedNSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_UE_DifferentiationInfo */
      case ASN1V_id_UE_DifferentiationInfo:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_UE_DifferentiationInfo;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_UE_DifferentiationInfo");

         pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UE_DifferentiationInfo
             = rtxMemAllocType (pctxt, UE_DifferentiationInfo);

         if (pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UE_DifferentiationInfo
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UE_DifferentiationInfo ((UE_DifferentiationInfo*)pvalue->
            value.
            u._ConnectionEstablishmentIndicationIEs_id_UE_DifferentiationInfo
            );

         stat = asn1PD_UE_DifferentiationInfo (pctxt, (UE_DifferentiationInfo*)
            pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UE_DifferentiationInfo
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_DL_CP_SecurityInformation */
      case ASN1V_id_DL_CP_SecurityInformation:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_DL_CP_SecurityInformation;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_DL_CP_SecurityInformation");

         pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_DL_CP_SecurityInformation
             = rtxMemAllocType (pctxt, DL_CP_SecurityInformation);

         if (pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_DL_CP_SecurityInformation
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DL_CP_SecurityInformation ((DL_CP_SecurityInformation*)pvalue
            ->value.
            u._ConnectionEstablishmentIndicationIEs_id_DL_CP_SecurityInformation
            );

         stat = asn1PD_DL_CP_SecurityInformation (pctxt, 
            (DL_CP_SecurityInformation*)pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_DL_CP_SecurityInformation
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_NB_IoT_UEPriority */
      case ASN1V_id_NB_IoT_UEPriority:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_NB_IoT_UEPriority;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_NB_IoT_UEPriority");

         stat = asn1PD_NB_IoT_UEPriority (pctxt, &pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_NB_IoT_UEPriority);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_Enhanced_CoverageRestriction */
      case ASN1V_id_Enhanced_CoverageRestriction:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_Enhanced_CoverageRestriction;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_Enhanced_CoverageRestriction");

         stat = asn1PD_Enhanced_CoverageRestriction (pctxt, &pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_Enhanced_CoverageRestriction
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_CEmodeBrestricted */
      case ASN1V_id_CEmodeBrestricted:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_CEmodeBrestricted;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_CEmodeBrestricted");

         stat = asn1PD_CEmodeBrestricted (pctxt, &pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_CEmodeBrestricted);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _ConnectionEstablishmentIndicationIEs_id_UERadioCapabilityID */
      case ASN1V_id_UERadioCapabilityID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_id_UERadioCapabilityID;

         RTXCTXTPUSHELEMNAME (pctxt, "_ConnectionEstablishmentIndicationIEs_id_UERadioCapabilityID");

         pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UERadioCapabilityID
             = rtxMemAllocType (pctxt, UERadioCapabilityID);

         if (pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UERadioCapabilityID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityID (pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UERadioCapabilityID);

         stat = asn1PD_UERadioCapabilityID (pctxt, pvalue->value.
            u._ConnectionEstablishmentIndicationIEs_id_UERadioCapabilityID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_ConnectionEstablishmentIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectionEstablishmentIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_ConnectionEstablishmentIndication_protocolIEs (OSCTXT* pctxt, ConnectionEstablishmentIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectionEstablishmentIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ConnectionEstablishmentIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ConnectionEstablishmentIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ConnectionEstablishmentIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ConnectionEstablishmentIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectionEstablishmentIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_ConnectionEstablishmentIndication (OSCTXT* pctxt, ConnectionEstablishmentIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ConnectionEstablishmentIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectionEstablishmentIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ConnectionEstablishmentIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ConnectionEstablishmentIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityIDMappingRequest_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityIDMappingRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UERadioCapabilityIDMappingRequestIEs_id_UERadioCapabilityID */
      case ASN1V_id_UERadioCapabilityID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityIDMappingRequestIEs_id_UERadioCapabilityID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityIDMappingRequestIEs_id_UERadioCapabilityID");

         pvalue->value.
            u._UERadioCapabilityIDMappingRequestIEs_id_UERadioCapabilityID
             = rtxMemAllocType (pctxt, UERadioCapabilityID);

         if (pvalue->value.
            u._UERadioCapabilityIDMappingRequestIEs_id_UERadioCapabilityID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityID (pvalue->value.
            u._UERadioCapabilityIDMappingRequestIEs_id_UERadioCapabilityID);

         stat = asn1PD_UERadioCapabilityID (pctxt, pvalue->value.
            u._UERadioCapabilityIDMappingRequestIEs_id_UERadioCapabilityID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UERadioCapabilityIDMappingRequestIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityIDMappingRequest_protocolIEs (OSCTXT* pctxt, UERadioCapabilityIDMappingRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UERadioCapabilityIDMappingRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UERadioCapabilityIDMappingRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityIDMappingRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UERadioCapabilityIDMappingRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityIDMappingRequest (OSCTXT* pctxt, UERadioCapabilityIDMappingRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityIDMappingRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingRequest: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UERadioCapabilityIDMappingRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityIDMappingResponse_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityIDMappingResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _UERadioCapabilityIDMappingResponseIEs_id_UERadioCapabilityID */
      case ASN1V_id_UERadioCapabilityID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityIDMappingResponseIEs_id_UERadioCapabilityID;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityIDMappingResponseIEs_id_UERadioCapabilityID");

         pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_UERadioCapabilityID
             = rtxMemAllocType (pctxt, UERadioCapabilityID);

         if (pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_UERadioCapabilityID
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapabilityID (pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_UERadioCapabilityID);

         stat = asn1PD_UERadioCapabilityID (pctxt, pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_UERadioCapabilityID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityIDMappingResponseIEs_id_UERadioCapability */
      case ASN1V_id_UERadioCapability:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityIDMappingResponseIEs_id_UERadioCapability;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityIDMappingResponseIEs_id_UERadioCapability");

         pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_UERadioCapability
             = rtxMemAllocType (pctxt, UERadioCapability);

         if (pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_UERadioCapability
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UERadioCapability (pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_UERadioCapability);

         stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_UERadioCapability);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _UERadioCapabilityIDMappingResponseIEs_id_CriticalityDiagnostics */
      case ASN1V_id_CriticalityDiagnostics:
         pvalue->value.
            t = T_NGAP_PDU_Contents_UERadioCapabilityIDMappingResponseIEs_id_CriticalityDiagnostics;

         RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityIDMappingResponseIEs_id_CriticalityDiagnostics");

         pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_CriticalityDiagnostics
             = rtxMemAllocType (pctxt, CriticalityDiagnostics);

         if (pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_CriticalityDiagnostics
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->
            value.
            u._UERadioCapabilityIDMappingResponseIEs_id_CriticalityDiagnostics
            );

         stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
            pvalue->value.
            u._UERadioCapabilityIDMappingResponseIEs_id_CriticalityDiagnostics
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_UERadioCapabilityIDMappingResponseIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityIDMappingResponse_protocolIEs (OSCTXT* pctxt, UERadioCapabilityIDMappingResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UERadioCapabilityIDMappingResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UERadioCapabilityIDMappingResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityIDMappingResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UERadioCapabilityIDMappingResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityIDMappingResponse (OSCTXT* pctxt, UERadioCapabilityIDMappingResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityIDMappingResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingResponse: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UERadioCapabilityIDMappingResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityIDMappingResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFCPRelocationIndication_protocolIEs_element (OSCTXT* pctxt, AMFCPRelocationIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFCPRelocationIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
      /* _AMFCPRelocationIndicationIEs_id_AMF_UE_NGAP_ID */
      case ASN1V_id_AMF_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFCPRelocationIndicationIEs_id_AMF_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFCPRelocationIndicationIEs_id_AMF_UE_NGAP_ID");

         stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
            u._AMFCPRelocationIndicationIEs_id_AMF_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFCPRelocationIndicationIEs_id_RAN_UE_NGAP_ID */
      case ASN1V_id_RAN_UE_NGAP_ID:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFCPRelocationIndicationIEs_id_RAN_UE_NGAP_ID;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFCPRelocationIndicationIEs_id_RAN_UE_NGAP_ID");

         stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
            u._AMFCPRelocationIndicationIEs_id_RAN_UE_NGAP_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFCPRelocationIndicationIEs_id_S_NSSAI */
      case ASN1V_id_S_NSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFCPRelocationIndicationIEs_id_S_NSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFCPRelocationIndicationIEs_id_S_NSSAI");

         pvalue->value.u._AMFCPRelocationIndicationIEs_id_S_NSSAI
             = rtxMemAllocType (pctxt, S_NSSAI);

         if (pvalue->value.u._AMFCPRelocationIndicationIEs_id_S_NSSAI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_S_NSSAI ((S_NSSAI*)pvalue->value.
            u._AMFCPRelocationIndicationIEs_id_S_NSSAI);

         stat = asn1PD_S_NSSAI (pctxt, (S_NSSAI*)pvalue->value.
            u._AMFCPRelocationIndicationIEs_id_S_NSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* _AMFCPRelocationIndicationIEs_id_AllowedNSSAI */
      case ASN1V_id_AllowedNSSAI:
         pvalue->value.
            t = T_NGAP_PDU_Contents_AMFCPRelocationIndicationIEs_id_AllowedNSSAI;

         RTXCTXTPUSHELEMNAME (pctxt, "_AMFCPRelocationIndicationIEs_id_AllowedNSSAI");

         pvalue->value.u._AMFCPRelocationIndicationIEs_id_AllowedNSSAI
             = rtxMemAllocType (pctxt, AllowedNSSAI);

         if (pvalue->value.u._AMFCPRelocationIndicationIEs_id_AllowedNSSAI
             == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AllowedNSSAI (pvalue->value.
            u._AMFCPRelocationIndicationIEs_id_AllowedNSSAI);

         stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
            u._AMFCPRelocationIndicationIEs_id_AllowedNSSAI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         pvalue->value.t = T_NGAP_PDU_Contents_AMFCPRelocationIndicationIEs_UNDEF_;
         pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
         if (0 == pvalue->value.u.extElem1)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
         if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

         stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
         if (stat != 0) {
            rtxMemFreePtr (pctxt, pdata);
            rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
            return LOG_RTERR (pctxt, stat);
         }
         pvalue->value.u.extElem1->numocts = openTypeLen;
         pvalue->value.u.extElem1->data = pdata;
         }
         break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFCPRelocationIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFCPRelocationIndication_protocolIEs (OSCTXT* pctxt, AMFCPRelocationIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFCPRelocationIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMFCPRelocationIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMFCPRelocationIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMFCPRelocationIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMFCPRelocationIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFCPRelocationIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFCPRelocationIndication (OSCTXT* pctxt, AMFCPRelocationIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFCPRelocationIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFCPRelocationIndication: start\n");

   /* extension bit */

   PU_NEWFIELD(pctxt, "extension bit");

   stat = rtxDecBit(pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT(pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_AMFCPRelocationIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFCPRelocationIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

