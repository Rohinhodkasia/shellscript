/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.2.A, Date: 27-Jun-2017.
 */
#include "IEEE1609dot2.h"
#include "rtxsrc/rtxCommon.h"
#include "rtxsrc/rtxDiagBitTrace.h"

#include <stdio.h>
#include <stdlib.h>
#include "rtxsrc/rtxFile.h"
#include "rtxsrc/rtxPrint.h"

int main (int argc, char** argv)
{
   int        i, stat;
   OSSIZE     len;
   OSBOOL     trace = TRUE;
   OSBOOL     verbose = FALSE;
   const char* filename = "message.dat";
   const OSOCTET* msgptr;

   /* Process command line arguments */
   if (argc > 1) {
      for (i = 1; i < argc; i++) {
         if (!strcmp (argv[i], "-v")) verbose = TRUE;
         else if (!strcmp (argv[i], "-o")) filename = argv[++i];
         else if (!strcmp (argv[i], "-notrace")) trace = FALSE;
         else {
            printf ("usage: writer [-v] [-o <filename>]  [-notrace]\n");
            printf ("   -v  verbose mode: print trace info\n");
            printf ("   -o <filename>  write encoded msg to <filename>\n");
            printf ("   -notrace  do not display trace info\n");
            return 1;
         }
      }
   }

   /* Create an instance of the compiler generated class.
      This example uses a dynamic message buffer..*/
   ASN1OEREncodeBuffer encodeBuffer;
   ASN1T_Certificate data;
   ASN1C_Certificate CertificatePDU (encodeBuffer, data);

   data.version = 3;
   data.type = CertificateType::implicit;

   data.issuer.t = T_IssuerIdentifier_sha256AndDigest;
   data.issuer.u.sha256AndDigest = new_ASN1T_HashedId8(CertificatePDU);
   data.issuer.u.sha256AndDigest->numocts = 8;
   memset (data.issuer.u.sha256AndDigest->data, 0x01, sizeof(ASN1T_HashedId8));

   data.toBeSigned.id.t = T_CertificateId_linkageData;
   data.toBeSigned.id.u.linkageData = new_ASN1T_LinkageData(CertificatePDU);
   data.toBeSigned.id.u.linkageData->iCert = 2;
   data.toBeSigned.id.u.linkageData->linkage_value.numocts = 9;
   memset (data.toBeSigned.id.u.linkageData->linkage_value.data, 
           0x03, sizeof(ASN1T_LinkageValue));

   data.toBeSigned.cracaId.numocts = 3;
   memset (data.toBeSigned.cracaId.data, 0x04, sizeof(ASN1T_HashedId3));
   data.toBeSigned.crlSeries = 5;
   data.toBeSigned.validityPeriod.start = 101058054;
   data.toBeSigned.validityPeriod.duration.t = T_Duration_hours;
   data.toBeSigned.validityPeriod.duration.u.hours = 169;

   ASN1T_SequenceOfIdentifiedRegion seqOfIdReg;
   ASN1C_SequenceOfIdentifiedRegion ccSeqOfIdReg (CertificatePDU, seqOfIdReg);

   data.toBeSigned.m.regionPresent = 1;
   data.toBeSigned.region.t = T_GeographicRegion_identifiedRegion;
   data.toBeSigned.region.u.identifiedRegion = &seqOfIdReg;

   ASN1T_IdentifiedRegion* pRegion = ccSeqOfIdReg.AppendNewElement();
   pRegion->t = T_IdentifiedRegion_countryOnly;
   pRegion->u.countryOnly = 124;

   pRegion = ccSeqOfIdReg.AppendNewElement();
   pRegion->t = T_IdentifiedRegion_countryOnly;
   pRegion->u.countryOnly = 484;

   pRegion = ccSeqOfIdReg.AppendNewElement();
   pRegion->t = T_IdentifiedRegion_countryOnly;
   pRegion->u.countryOnly = 840;

   data.toBeSigned.m.appPermissionsPresent = 1;
   ASN1C_SequenceOfPsidSsp ccSeqOfPsidSsp 
      (CertificatePDU, data.toBeSigned.appPermissions);
   ASN1T_PsidSsp* pPsidSsp = ccSeqOfPsidSsp.AppendNewElement();
   ASN1T_BitmapSsp bitmapSsp;
   bitmapSsp.numocts = 30;
   memset(bitmapSsp.data, 0xed, 30);

   for (int i = 0; i < 30; i++) {
      pPsidSsp = ccSeqOfPsidSsp.AppendNewElement();
      pPsidSsp->psid = 32+i;
      pPsidSsp->m.sspPresent = 1;
      pPsidSsp->ssp.t = 2;
      pPsidSsp->ssp.u.bitmapSsp = &bitmapSsp;
   }

   data.toBeSigned.verifyKeyIndicator.t = 
      T_VerificationKeyIndicator_reconstructionValue;
   data.toBeSigned.verifyKeyIndicator.u.reconstructionValue = 
      new_ASN1T_EccP256CurvePoint (CertificatePDU);
   data.toBeSigned.verifyKeyIndicator.u.reconstructionValue->t = 
      T_EccP256CurvePoint_compressed_y_1;
   data.toBeSigned.verifyKeyIndicator.u.
      reconstructionValue->u.compressed_y_1 = 
      new_ASN1T_EccP256CurvePoint_compressed_y_1(CertificatePDU);
    
   data.toBeSigned.verifyKeyIndicator.u.reconstructionValue->
      u.compressed_y_1->numocts = 32;
   memset 
      (data.toBeSigned.verifyKeyIndicator.u.reconstructionValue->
       u.compressed_y_1->data, 0x08, 32);

   /* Encode */

   if ((stat = CertificatePDU.Encode ()) == 0)
   {
      if (trace) {
         printf ("Encoding was successful\n");
         printf ("Hex dump of encoded record:\n");
         encodeBuffer.hexDump ();
      }
      msgptr = encodeBuffer.getMsgPtr ();
      len = encodeBuffer.getMsgLen ();
   }
   else
   {
      printf ("Encoding failed\n");
      encodeBuffer.printErrorInfo ();
      return (-1);
   }
   /* Write the encoded message out to the output file */
   stat = rtxFileWriteBinary (filename, msgptr, len);
   if (stat < 0) {
      printf ("Write to file failed\n");
      encodeBuffer.printErrorInfo();
      return stat;
   }

   return 0;
}
