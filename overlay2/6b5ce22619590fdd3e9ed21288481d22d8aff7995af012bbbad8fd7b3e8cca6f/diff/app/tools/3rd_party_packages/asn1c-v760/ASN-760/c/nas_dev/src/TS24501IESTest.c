/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.6.0, Date: 15-Feb-2022.
 */
#include "TS24501IES.h"
#include "TS24008IES.h"
#include "TS24301IES.h"
#include "rtxsrc/rtxCommon.h"
#include "rtxsrc/rtxDiagBitTrace.h"

/*
 * Randomly generated test file: seed = 1644926504
 */
TS24501IE_AdditionalInfo* asn1Test_TS24501IE_AdditionalInfo (OSCTXT* pctxt)
{
   TS24501IE_AdditionalInfo* pvalue = rtxMemAllocType (pctxt, TS24501IE_AdditionalInfo);
   asn1Init_TS24501IE_AdditionalInfo (pvalue);

   pvalue->numocts = 11;
   pvalue->data = (OSOCTET*) rtxMemAlloc (pctxt, 11);
   {
      static const OSOCTET testdata[] = {
      0x88, 0x5b, 0xa3, 0x99, 0x5e, 0x42, 0x45, 0xe3, 
      0xc2, 0x6c, 0xc2 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->data, 11, testdata, 11);
   }
   return (pvalue);
}

TS24501IE_EAPFormatCode* asn1Test_TS24501IE_EAPFormatCode (OSCTXT* pctxt)
{
   TS24501IE_EAPFormatCode* pvalue = rtxMemAllocType (pctxt, TS24501IE_EAPFormatCode);

   *pvalue = TS24501IE_EAPFormatCode_success;
   return (pvalue);
}

TS24501IE_N1ToS1NASContainer*
    asn1Test_TS24501IE_N1ToS1NASContainer (OSCTXT* pctxt)
{
   TS24501IE_N1ToS1NASContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_N1ToS1NASContainer);

   *pvalue = 190;
   return (pvalue);
}

TS24501IE_SST* asn1Test_TS24501IE_SST (OSCTXT* pctxt)
{
   TS24501IE_SST* pvalue = rtxMemAllocType (pctxt, TS24501IE_SST);

   *pvalue = 164;
   return (pvalue);
}

TS24501IE_SD* asn1Test_TS24501IE_SD (OSCTXT* pctxt)
{
   TS24501IE_SD* pvalue = rtxMemAllocType (pctxt, TS24501IE_SD);

   *pvalue = 10826356;
   return (pvalue);
}

TS24501IE_SLAAParamTypes* asn1Test_TS24501IE_SLAAParamTypes (OSCTXT* pctxt)
{
   TS24501IE_SLAAParamTypes* pvalue = rtxMemAllocType (pctxt, TS24501IE_SLAAParamTypes);

   *pvalue = TS24501IE_SLAAParamTypes_ptServerAddr;
   return (pvalue);
}

TS24501IE_MMCause* asn1Test_TS24501IE_MMCause (OSCTXT* pctxt)
{
   TS24501IE_MMCause* pvalue = rtxMemAllocType (pctxt, TS24501IE_MMCause);

   *pvalue = 71;
   return (pvalue);
}

TS24501IE_TypeOfIdentity* asn1Test_TS24501IE_TypeOfIdentity (OSCTXT* pctxt)
{
   TS24501IE_TypeOfIdentity* pvalue = rtxMemAllocType (pctxt, TS24501IE_TypeOfIdentity);

   *pvalue = TS24501IE_TypeOfIdentity_imei;
   return (pvalue);
}

TS24501IE_RegistrationResultValue*
    asn1Test_TS24501IE_RegistrationResultValue (OSCTXT* pctxt)
{
   TS24501IE_RegistrationResultValue* pvalue = rtxMemAllocType (pctxt, TS24501IE_RegistrationResultValue);

   *pvalue = TS24501IE_RegistrationResultValue_access;
   return (pvalue);
}

TS24501IE_RegistrationTypeValue*
    asn1Test_TS24501IE_RegistrationTypeValue (OSCTXT* pctxt)
{
   TS24501IE_RegistrationTypeValue* pvalue = rtxMemAllocType (pctxt, TS24501IE_RegistrationTypeValue);

   *pvalue = TS24501IE_RegistrationTypeValue_snpnOnboard;
   return (pvalue);
}

TS24501IE_TrackingAreaCode* asn1Test_TS24501IE_TrackingAreaCode (OSCTXT* pctxt)
{
   TS24501IE_TrackingAreaCode* pvalue = rtxMemAllocType (pctxt, TS24501IE_TrackingAreaCode);

   {
      static const OSOCTET testdata[] = {
      0xb3, 0xab, 0xc7 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->data, 3, testdata, 3);
   }
   return (pvalue);
}

TS24501IE_ABBA* asn1Test_TS24501IE_ABBA (OSCTXT* pctxt)
{
   TS24501IE_ABBA* pvalue = rtxMemAllocType (pctxt, TS24501IE_ABBA);
   asn1Init_TS24501IE_ABBA (pvalue);

   pvalue->numocts = 2;
   pvalue->data = (OSOCTET*) rtxMemAlloc (pctxt, 2);
   {
      static const OSOCTET testdata[] = {
      0x4f, 0x9f };
      OSCRTLSAFEMEMCPY ((void*)pvalue->data, 2, testdata, 2);
   }
   return (pvalue);
}

TS24501IE_CIoTDataTypes* asn1Test_TS24501IE_CIoTDataTypes (OSCTXT* pctxt)
{
   TS24501IE_CIoTDataTypes* pvalue = rtxMemAllocType (pctxt, TS24501IE_CIoTDataTypes);

   *pvalue = TS24501IE_CIoTDataTypes_ciotMAX;
   return (pvalue);
}

TS24501IE_MAPDUSessionInfo* asn1Test_TS24501IE_MAPDUSessionInfo (OSCTXT* pctxt)
{
   TS24501IE_MAPDUSessionInfo* pvalue = rtxMemAllocType (pctxt, TS24501IE_MAPDUSessionInfo);

   *pvalue = TS24501IE_MAPDUSessionInfo_mapduMAX;
   return (pvalue);
}

TS24501IE_CipherTypes* asn1Test_TS24501IE_CipherTypes (OSCTXT* pctxt)
{
   TS24501IE_CipherTypes* pvalue = rtxMemAllocType (pctxt, TS24501IE_CipherTypes);

   *pvalue = TS24501IE_CipherTypes_ia6;
   return (pvalue);
}

TS24501IE_ProtectionTypes* asn1Test_TS24501IE_ProtectionTypes (OSCTXT* pctxt)
{
   TS24501IE_ProtectionTypes* pvalue = rtxMemAllocType (pctxt, TS24501IE_ProtectionTypes);

   *pvalue = TS24501IE_ProtectionTypes_protectionTypeMAX;
   return (pvalue);
}

TS24501IE_AccessCategories* asn1Test_TS24501IE_AccessCategories (OSCTXT* pctxt)
{
   TS24501IE_AccessCategories* pvalue = rtxMemAllocType (pctxt, TS24501IE_AccessCategories);

   *pvalue = TS24501IE_AccessCategories_category2;
   return (pvalue);
}

TS24501IE_PayloadContainerType*
    asn1Test_TS24501IE_PayloadContainerType (OSCTXT* pctxt)
{
   TS24501IE_PayloadContainerType* pvalue = rtxMemAllocType (pctxt, TS24501IE_PayloadContainerType);

   *pvalue = TS24501IE_PayloadContainerType_multPayloads;
   return (pvalue);
}

TS24501IE_PDUSessionId2* asn1Test_TS24501IE_PDUSessionId2 (OSCTXT* pctxt)
{
   TS24501IE_PDUSessionId2* pvalue = rtxMemAllocType (pctxt, TS24501IE_PDUSessionId2);

   *pvalue = 31;
   return (pvalue);
}

TS24501IE_SessionReactivateRslt*
    asn1Test_TS24501IE_SessionReactivateRslt (OSCTXT* pctxt)
{
   TS24501IE_SessionReactivateRslt* pvalue = rtxMemAllocType (pctxt, TS24501IE_SessionReactivateRslt);
   asn1Init_TS24501IE_SessionReactivateRslt (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->psi.elem[0] = 0;

   pvalue->psi.elem[1] = 1;

   pvalue->psi.elem[2] = 1;

   pvalue->psi.elem[3] = 0;

   pvalue->psi.elem[4] = 1;

   pvalue->psi.elem[5] = 1;

   pvalue->psi.elem[6] = 0;

   pvalue->psi.elem[7] = 0;

   pvalue->psi.elem[8] = 1;

   pvalue->psi.elem[9] = 0;

   pvalue->psi.elem[10] = 1;

   pvalue->psi.elem[11] = 0;

   pvalue->psi.elem[12] = 1;

   pvalue->psi.elem[13] = 0;

   pvalue->psi.elem[14] = 1;

   pvalue->psi.elem[15] = 0;

   pvalue->m.sparePresent = 1;
   pvalue->spare.numocts = 17;
   pvalue->spare.data = (OSOCTET*) rtxMemAlloc (pctxt, 17);
   {
      static const OSOCTET testdata[] = {
      0xd7, 0xeb, 0x32, 0x1f, 0x1f, 0x01, 0xbe, 0x15, 
      0x8f, 0xaa, 0xd8, 0x4d, 0x20, 0xf8, 0xae, 0x30, 
      0xf5 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->spare.data, 17, testdata, 17);
   }
   return (pvalue);
}

TS24501IE_PDUSessionStatus* asn1Test_TS24501IE_PDUSessionStatus (OSCTXT* pctxt)
{
   TS24501IE_PDUSessionStatus* pvalue = rtxMemAllocType (pctxt, TS24501IE_PDUSessionStatus);
   asn1Init_TS24501IE_PDUSessionStatus (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->psi.elem[0] = 1;

   pvalue->psi.elem[1] = 0;

   pvalue->psi.elem[2] = 0;

   pvalue->psi.elem[3] = 0;

   pvalue->psi.elem[4] = 0;

   pvalue->psi.elem[5] = 1;

   pvalue->psi.elem[6] = 0;

   pvalue->psi.elem[7] = 0;

   pvalue->psi.elem[8] = 1;

   pvalue->psi.elem[9] = 0;

   pvalue->psi.elem[10] = 0;

   pvalue->psi.elem[11] = 0;

   pvalue->psi.elem[12] = 0;

   pvalue->psi.elem[13] = 1;

   pvalue->psi.elem[14] = 1;

   pvalue->psi.elem[15] = 0;

   pvalue->m.sparePresent = 1;
   pvalue->spare.numocts = 11;
   pvalue->spare.data = (OSOCTET*) rtxMemAlloc (pctxt, 11);
   {
      static const OSOCTET testdata[] = {
      0x18, 0x77, 0xdf, 0xd6, 0x8c, 0x6f, 0x82, 0x65, 
      0xbc, 0x22, 0xdd };
      OSCRTLSAFEMEMCPY ((void*)pvalue->spare.data, 11, testdata, 11);
   }
   return (pvalue);
}

TS24501IE_RequestTypes* asn1Test_TS24501IE_RequestTypes (OSCTXT* pctxt)
{
   TS24501IE_RequestTypes* pvalue = rtxMemAllocType (pctxt, TS24501IE_RequestTypes);

   *pvalue = TS24501IE_RequestTypes_initialReq;
   return (pvalue);
}

TS24501IE_ServiceType* asn1Test_TS24501IE_ServiceType (OSCTXT* pctxt)
{
   TS24501IE_ServiceType* pvalue = rtxMemAllocType (pctxt, TS24501IE_ServiceType);

   *pvalue = TS24501IE_ServiceType_elevSignal;
   return (pvalue);
}

TS24501IE_PERNTypes* asn1Test_TS24501IE_PERNTypes (OSCTXT* pctxt)
{
   TS24501IE_PERNTypes* pvalue = rtxMemAllocType (pctxt, TS24501IE_PERNTypes);

   *pvalue = TS24501IE_PERNTypes_pernTypeMAX;
   return (pvalue);
}

TS24501IE_ATSSSModes* asn1Test_TS24501IE_ATSSSModes (OSCTXT* pctxt)
{
   TS24501IE_ATSSSModes* pvalue = rtxMemAllocType (pctxt, TS24501IE_ATSSSModes);

   *pvalue = TS24501IE_ATSSSModes_anyMode;
   return (pvalue);
}

TS24501IE_SMCause* asn1Test_TS24501IE_SMCause (OSCTXT* pctxt)
{
   TS24501IE_SMCause* pvalue = rtxMemAllocType (pctxt, TS24501IE_SMCause);

   *pvalue = 86;
   return (pvalue);
}

TS24501IE_EPSParamId* asn1Test_TS24501IE_EPSParamId (OSCTXT* pctxt)
{
   TS24501IE_EPSParamId* pvalue = rtxMemAllocType (pctxt, TS24501IE_EPSParamId);

   *pvalue = TS24501IE_EPSParamId_extApnAmbr;
   return (pvalue);
}

TS24501IE_PDUAddressValues* asn1Test_TS24501IE_PDUAddressValues (OSCTXT* pctxt)
{
   TS24501IE_PDUAddressValues* pvalue = rtxMemAllocType (pctxt, TS24501IE_PDUAddressValues);

   *pvalue = TS24501IE_PDUAddressValues_ipv4;
   return (pvalue);
}

TS24501IE_SessionType* asn1Test_TS24501IE_SessionType (OSCTXT* pctxt)
{
   TS24501IE_SessionType* pvalue = rtxMemAllocType (pctxt, TS24501IE_SessionType);

   *pvalue = TS24501IE_SessionType_st_unstructured;
   return (pvalue);
}

TS24501IE_ParameterId* asn1Test_TS24501IE_ParameterId (OSCTXT* pctxt)
{
   TS24501IE_ParameterId* pvalue = rtxMemAllocType (pctxt, TS24501IE_ParameterId);

   *pvalue = TS24501IE_ParameterId_avgWindow;
   return (pvalue);
}

TS24501IE_FlowRateUnit* asn1Test_TS24501IE_FlowRateUnit (OSCTXT* pctxt)
{
   TS24501IE_FlowRateUnit* pvalue = rtxMemAllocType (pctxt, TS24501IE_FlowRateUnit);

   *pvalue = 12;
   return (pvalue);
}

TS24501IE_FlowOpCodes* asn1Test_TS24501IE_FlowOpCodes (OSCTXT* pctxt)
{
   TS24501IE_FlowOpCodes* pvalue = rtxMemAllocType (pctxt, TS24501IE_FlowOpCodes);

   *pvalue = TS24501IE_FlowOpCodes_flowDelete;
   return (pvalue);
}

TS24501IE_RuleOpCodes* asn1Test_TS24501IE_RuleOpCodes (OSCTXT* pctxt)
{
   TS24501IE_RuleOpCodes* pvalue = rtxMemAllocType (pctxt, TS24501IE_RuleOpCodes);

   *pvalue = TS24501IE_RuleOpCodes_createNew;
   return (pvalue);
}

TS24501IE_PacketFilterTypeId*
    asn1Test_TS24501IE_PacketFilterTypeId (OSCTXT* pctxt)
{
   TS24501IE_PacketFilterTypeId* pvalue = rtxMemAllocType (pctxt, TS24501IE_PacketFilterTypeId);

   *pvalue = TS24501IE_PacketFilterTypeId_matchAll;
   return (pvalue);
}

TS24501IE_SSCModeValue* asn1Test_TS24501IE_SSCModeValue (OSCTXT* pctxt)
{
   TS24501IE_SSCModeValue* pvalue = rtxMemAllocType (pctxt, TS24501IE_SSCModeValue);

   *pvalue = TS24501IE_SSCModeValue_ssc_mode2;
   return (pvalue);
}

TS24501IE_OpaqueData* asn1Test_TS24501IE_OpaqueData (OSCTXT* pctxt)
{
   TS24501IE_OpaqueData* pvalue = rtxMemAllocType (pctxt, TS24501IE_OpaqueData);
   asn1Init_TS24501IE_OpaqueData (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->contents.numocts = 4;
   pvalue->contents.data = (OSOCTET*) rtxMemAlloc (pctxt, 4);
   {
      static const OSOCTET testdata[] = {
      0xac, 0xea, 0x6f, 0x05 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.data, 4, testdata, 4);
   }
   return (pvalue);
}

TS24501IE_AccessType* asn1Test_TS24501IE_AccessType (OSCTXT* pctxt)
{
   TS24501IE_AccessType* pvalue = rtxMemAllocType (pctxt, TS24501IE_AccessType);
   asn1Init_TS24501IE_AccessType (pvalue);

   pvalue->spare = 0;

   pvalue->typeOfAccess = TS24501IE_AccessType_typeOfAccess_accessNon3gpp;
   return (pvalue);
}

TS24501IE_DNNList* asn1Test_TS24501IE_DNNList (OSCTXT* pctxt)
{
   TS24501IE_DNNList* pvalue = rtxMemAllocType (pctxt, TS24501IE_DNNList);
   asn1Init_TS24501IE_DNNList (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->apn.n = 4;
   pvalue->apn.elem = rtxMemAllocArrayZ (pctxt, 4, const char*);
   pvalue->apn.elem[0] = "2Wf";

   pvalue->apn.elem[1] = "pWMtGWsq";

   pvalue->apn.elem[2] = "8bm";

   pvalue->apn.elem[3] = "T::OuA0k3i";

   return (pvalue);
}

TS24501IE_EAPMessage* asn1Test_TS24501IE_EAPMessage (OSCTXT* pctxt)
{
   TS24501IE_EAPMessage* pvalue = rtxMemAllocType (pctxt, TS24501IE_EAPMessage);
   asn1Init_TS24501IE_EAPMessage (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->packetFormat.code = TS24501IE_EAPFormatCode_success;

   pvalue->packetFormat.id = 254;

   pvalue->packetFormat.length = 57880;

   pvalue->packetFormat.data.numocts = 3;
   pvalue->packetFormat.data.data = (OSOCTET*) rtxMemAlloc (pctxt, 3);
   {
      static const OSOCTET testdata[] = {
      0xed, 0xed, 0x7b };
      OSCRTLSAFEMEMCPY ((void*)pvalue->packetFormat.data.data, 3, testdata, 3);
   }
   return (pvalue);
}

TS24501IE_IntraN1NASContainer*
    asn1Test_TS24501IE_IntraN1NASContainer (OSCTXT* pctxt)
{
   TS24501IE_IntraN1NASContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_IntraN1NASContainer);
   asn1Init_TS24501IE_IntraN1NASContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   {
      static const OSOCTET testdata[] = {
      0x3a, 0x30, 0x51, 0x5b };
      OSCRTLSAFEMEMCPY ((void*)pvalue->authCode, 4, testdata, 4);
   }

   pvalue->cipherType = 12;

   pvalue->integrityType = 5;

   pvalue->spare1 = 1;

   pvalue->kacf = 0;

   pvalue->tsc = 1;

   pvalue->keysetId = 2;

   pvalue->seqNumber = 200;
   return (pvalue);
}

TS24501IE_SNSSAI* asn1Test_TS24501IE_SNSSAI (OSCTXT* pctxt)
{
   TS24501IE_SNSSAI* pvalue = rtxMemAllocType (pctxt, TS24501IE_SNSSAI);
   asn1Init_TS24501IE_SNSSAI (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->sst = 11;

   pvalue->m.sdPresent = 1;
   pvalue->sd = 4103530;

   pvalue->m.mappedSSTPresent = 1;
   {
      static const OSOCTET testdata[] = {
      0xfe };
      OSCRTLSAFEMEMCPY ((void*)pvalue->mappedSST, 1, testdata, 1);
   }

   pvalue->m.mappedSDPresent = 1;
   {
      static const OSOCTET testdata[] = {
      0x46, 0x28, 0xf4 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->mappedSD, 3, testdata, 3);
   }
   return (pvalue);
}

TS24501IE_S1ToN1NASContainer*
    asn1Test_TS24501IE_S1ToN1NASContainer (OSCTXT* pctxt)
{
   TS24501IE_S1ToN1NASContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_S1ToN1NASContainer);
   asn1Init_TS24501IE_S1ToN1NASContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   {
      static const OSOCTET testdata[] = {
      0xcf, 0x57, 0x6e, 0xa2 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->authCode, 4, testdata, 4);
   }

   pvalue->cipherType = 0;

   pvalue->integrityType = 11;

   pvalue->spare1 = 1;

   pvalue->ncc = 5;

   pvalue->tsc = 0;

   pvalue->keysetId = 5;

   pvalue->spare2 = 63218;
   return (pvalue);
}

TS24501IE_SLDeviceId* asn1Test_TS24501IE_SLDeviceId (OSCTXT* pctxt)
{
   TS24501IE_SLDeviceId* pvalue = rtxMemAllocType (pctxt, TS24501IE_SLDeviceId);
   asn1Init_TS24501IE_SLDeviceId (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->id.numocts = 1;
   {
      static const OSOCTET testdata[] = {
      0xd1 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->id.data, 1, testdata, 1);
   }
   return (pvalue);
}

TS24501IE_SLAAServerAddr* asn1Test_TS24501IE_SLAAServerAddr (OSCTXT* pctxt)
{
   TS24501IE_SLAAServerAddr* pvalue = rtxMemAllocType (pctxt, TS24501IE_SLAAServerAddr);
   asn1Init_TS24501IE_SLAAServerAddr (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->addrType = 58;

   pvalue->addr.numocts = 1;
   {
      static const OSOCTET testdata[] = {
      0x97 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->addr.data, 1, testdata, 1);
   }
   return (pvalue);
}

TS24501IE_SLAAPayload* asn1Test_TS24501IE_SLAAPayload (OSCTXT* pctxt)
{
   TS24501IE_SLAAPayload* pvalue = rtxMemAllocType (pctxt, TS24501IE_SLAAPayload);
   asn1Init_TS24501IE_SLAAPayload (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->payload.numocts = 1;
   pvalue->payload.data = (OSOCTET*) rtxMemAlloc (pctxt, 1);
   {
      static const OSOCTET testdata[] = {
      0x8b };
      OSCRTLSAFEMEMCPY ((void*)pvalue->payload.data, 1, testdata, 1);
   }
   return (pvalue);
}

TS24501IE_SLAAResponse* asn1Test_TS24501IE_SLAAResponse (OSCTXT* pctxt)
{
   TS24501IE_SLAAResponse* pvalue = rtxMemAllocType (pctxt, TS24501IE_SLAAResponse);
   asn1Init_TS24501IE_SLAAResponse (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 50;

   pvalue->slar = 0;
   return (pvalue);
}

TS24501IE_SLAAParameter* asn1Test_TS24501IE_SLAAParameter (OSCTXT* pctxt)
{
   TS24501IE_SLAAParameter* pvalue = rtxMemAllocType (pctxt, TS24501IE_SLAAParameter);
   asn1Init_TS24501IE_SLAAParameter (pvalue);

   pvalue->type = TS24501IE_SLAAParamTypes_ptDeviceId;

   switch (pvalue->type) {
      /* deviceId */
      case 16:
         pvalue->param.u.deviceId.length = 0; /* length will be calculated */

         pvalue->param.u.deviceId.id.numocts = 1;
         {
            static const OSOCTET testdata[] = {
            0x86 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->param.u.deviceId.id.data, 1, testdata, 1);
         }
         break;

      /* serverAddr */
      case 32:
         pvalue->param.u.serverAddr.length = 0; /* length will be calculated */

         pvalue->param.u.serverAddr.addrType = 156;

         pvalue->param.u.serverAddr.addr.numocts = 1;
         {
            static const OSOCTET testdata[] = {
            0x0f };
            OSCRTLSAFEMEMCPY ((void*)pvalue->param.u.serverAddr.addr.data, 1, testdata, 1);
         }
         break;

      /* payload */
      case 48:
         pvalue->param.u.payload.length = 0; /* length will be calculated */

         pvalue->param.u.payload.payload.numocts = 1;
         pvalue->param.u.payload.payload.data = (OSOCTET*) rtxMemAlloc (pctxt, 1);
         {
            static const OSOCTET testdata[] = {
            0x35 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->param.u.payload.payload.data, 1, testdata, 1);
         }
         break;

      /* response */
      case 112:
         pvalue->param.u.response.length = 0; /* length will be calculated */

         pvalue->param.u.response.spare = 36;

         pvalue->param.u.response.slar = 1;
         break;

      default: break;
   }
   return (pvalue);
}

TS24501IE_SLAAContainer* asn1Test_TS24501IE_SLAAContainer (OSCTXT* pctxt)
{
   TS24501IE_SLAAContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_SLAAContainer);
   asn1Init_TS24501IE_SLAAContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->contents.n = 1;

   pvalue->contents.elem[0].type = TS24501IE_SLAAParamTypes_ptPayload;

   switch (pvalue->contents.elem[0].type) {
      /* deviceId */
      case 16:
         pvalue->contents.elem[0].param.u.deviceId.length = 0; /* length will be calculated */

         pvalue->contents.elem[0].param.u.deviceId.id.numocts = 1;
         {
            static const OSOCTET testdata[] = {
            0xd5 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[0].param.u.deviceId.id.data, 1, testdata, 1);
         }
         break;

      /* serverAddr */
      case 32:
         pvalue->contents.elem[0].param.u.serverAddr.length = 0; /* length will be calculated */

         pvalue->contents.elem[0].param.u.serverAddr.addrType = 186;

         pvalue->contents.elem[0].param.u.serverAddr.addr.numocts = 1;
         {
            static const OSOCTET testdata[] = {
            0xea };
            OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[0].param.u.serverAddr.addr.data, 1, testdata, 1);
         }
         break;

      /* payload */
      case 48:
         pvalue->contents.elem[0].param.u.payload.length = 0; /* length will be calculated */

         pvalue->contents.elem[0].param.u.payload.payload.numocts = 1;
         pvalue->contents.elem[0].param.u.payload.payload.data = (OSOCTET*) rtxMemAlloc (pctxt, 1);
         {
            static const OSOCTET testdata[] = {
            0x9b };
            OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[0].param.u.payload.payload.data, 1, testdata, 1);
         }
         break;

      /* response */
      case 112:
         pvalue->contents.elem[0].param.u.response.length = 0; /* length will be calculated */

         pvalue->contents.elem[0].param.u.response.spare = 17;

         pvalue->contents.elem[0].param.u.response.slar = 1;
         break;

      default: break;
   }

   return (pvalue);
}

TS24501IE_MMCapability* asn1Test_TS24501IE_MMCapability (OSCTXT* pctxt)
{
   TS24501IE_MMCapability* pvalue = rtxMemAllocType (pctxt, TS24501IE_MMCapability);
   asn1Init_TS24501IE_MMCapability (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->sgc = 0;

   pvalue->hcCpCIoT = 1;

   pvalue->n3Data = 1;

   pvalue->cpCIoT = 0;

   pvalue->restrictedEC = 1;

   pvalue->lppSupported = 1;

   pvalue->handoverSupported = 1;

   pvalue->s1Supported = 0;

   pvalue->m.octet4Present = 1;

   pvalue->octet4.racs = 0;

   pvalue->octet4.nssaa = 0;

   pvalue->octet4.lcs = 0;

   pvalue->octet4.v2xcnpc5 = 0;

   pvalue->octet4.v2xcepc5 = 1;

   pvalue->octet4.v2x = 1;

   pvalue->octet4.upCIoT = 0;

   pvalue->octet4.srvcc = 1;

   pvalue->m.octet5Present = 1;

   pvalue->octet5.proSel2relay = 1;

   pvalue->octet5.proSedc = 1;

   pvalue->octet5.proSedd = 1;

   pvalue->octet5.erNssai = 1;

   pvalue->octet5.ehcCpCIoT = 0;

   pvalue->octet5.multipleUp = 0;

   pvalue->octet5.wusa = 0;

   pvalue->octet5.cag = 1;

   pvalue->m.octet6Present = 1;

   pvalue->octet6.spare = 4;

   pvalue->octet6.proSel3rmt = 1;

   pvalue->octet6.proSel2rmt = 0;

   pvalue->octet6.proSel3relay = 1;

   pvalue->m.sparePresent = 1;
   pvalue->spare.numocts = 1;
   pvalue->spare.data = (OSOCTET*) rtxMemAlloc (pctxt, 1);
   {
      static const OSOCTET testdata[] = {
      0xeb };
      OSCRTLSAFEMEMCPY ((void*)pvalue->spare.data, 1, testdata, 1);
   }
   return (pvalue);
}

TS24501IE_DRXParams* asn1Test_TS24501IE_DRXParams (OSCTXT* pctxt)
{
   TS24501IE_DRXParams* pvalue = rtxMemAllocType (pctxt, TS24501IE_DRXParams);
   asn1Init_TS24501IE_DRXParams (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 12;

   pvalue->drxValue = 14;
   return (pvalue);
}

TS24501IE_IdentityType* asn1Test_TS24501IE_IdentityType (OSCTXT* pctxt)
{
   TS24501IE_IdentityType* pvalue = rtxMemAllocType (pctxt, TS24501IE_IdentityType);
   asn1Init_TS24501IE_IdentityType (pvalue);

   pvalue->spare = 0;

   pvalue->typeOfIdent = TS24501IE_TypeOfIdentity_suci;
   return (pvalue);
}

TS24501IE_MobileIdentity_SUCI_IMSI*
    asn1Test_TS24501IE_MobileIdentity_SUCI_IMSI (OSCTXT* pctxt)
{
   TS24501IE_MobileIdentity_SUCI_IMSI* pvalue = rtxMemAllocType (pctxt, TS24501IE_MobileIdentity_SUCI_IMSI);
   asn1Init_TS24501IE_MobileIdentity_SUCI_IMSI (pvalue);

   rtxStrncpy (pvalue->mcc_mnc.mcc, 4, "340", 3);
   rtxStrncpy (pvalue->mcc_mnc.mnc, 4, "08", 3);

   pvalue->routingInd2 = 5;

   pvalue->routingInd1 = 13;

   pvalue->routingInd4 = 6;

   pvalue->routingInd3 = 6;

   pvalue->spare = 11;

   pvalue->protSchemeId = 7;

   pvalue->homeNetId = 249;

   pvalue->schemeOutput.numocts = 20;
   pvalue->schemeOutput.data = (OSOCTET*) rtxMemAlloc (pctxt, 20);
   {
      static const OSOCTET testdata[] = {
      0xd2, 0x83, 0x4e, 0xc8, 0x62, 0xb5, 0x26, 0xc7, 
      0x83, 0x12, 0x61, 0x7f, 0x2b, 0xe6, 0x51, 0x5a, 
      0x57, 0x3f, 0x46, 0xa6 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->schemeOutput.data, 20, testdata, 20);
   }
   return (pvalue);
}

TS24501IE_MobileIdentity_SUCI_NetId*
    asn1Test_TS24501IE_MobileIdentity_SUCI_NetId (OSCTXT* pctxt)
{
   TS24501IE_MobileIdentity_SUCI_NetId* pvalue = rtxMemAllocType (pctxt, TS24501IE_MobileIdentity_SUCI_NetId);
   asn1Init_TS24501IE_MobileIdentity_SUCI_NetId (pvalue);

   pvalue->nai.numocts = 4;
   pvalue->nai.data = (OSOCTET*) rtxMemAlloc (pctxt, 4);
   {
      static const OSOCTET testdata[] = {
      0xc7, 0xc4, 0x00, 0x6b };
      OSCRTLSAFEMEMCPY ((void*)pvalue->nai.data, 4, testdata, 4);
   }
   return (pvalue);
}

TS24501IE_MobileIdentity_GUTI*
    asn1Test_TS24501IE_MobileIdentity_GUTI (OSCTXT* pctxt)
{
   TS24501IE_MobileIdentity_GUTI* pvalue = rtxMemAllocType (pctxt, TS24501IE_MobileIdentity_GUTI);
   asn1Init_TS24501IE_MobileIdentity_GUTI (pvalue);

   rtxStrncpy (pvalue->mcc_mnc.mcc, 4, "234", 3);
   rtxStrncpy (pvalue->mcc_mnc.mnc, 4, "50", 3);

   pvalue->amfRegionID = 22;

   pvalue->amfSetID = 716;

   pvalue->amfPointer = 48;

   {
      static const OSOCTET testdata[] = {
      0x8f, 0xa9, 0xd0, 0x14 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->tmsi, 4, testdata, 4);
   }
   return (pvalue);
}

TS24501IE_MobileIdentity_STMSI*
    asn1Test_TS24501IE_MobileIdentity_STMSI (OSCTXT* pctxt)
{
   TS24501IE_MobileIdentity_STMSI* pvalue = rtxMemAllocType (pctxt, TS24501IE_MobileIdentity_STMSI);

   pvalue->amfSetID = 861;

   pvalue->amfPointer = 35;

   {
      static const OSOCTET testdata[] = {
      0xf5, 0xad, 0xbf, 0xbd };
      OSCRTLSAFEMEMCPY ((void*)pvalue->tmsi, 4, testdata, 4);
   }
   return (pvalue);
}

TS24501IE_MobileIdentity_MAC*
    asn1Test_TS24501IE_MobileIdentity_MAC (OSCTXT* pctxt)
{
   TS24501IE_MobileIdentity_MAC* pvalue = rtxMemAllocType (pctxt, TS24501IE_MobileIdentity_MAC);

   pvalue->mauri = 1;

   {
      static const OSOCTET testdata[] = {
      0xd1, 0x9f, 0x30, 0x7c, 0x06, 0x81 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->macaddr, 6, testdata, 6);
   }
   return (pvalue);
}

TS24501IE_MobileIdentity* asn1Test_TS24501IE_MobileIdentity (OSCTXT* pctxt)
{
   TS24501IE_MobileIdentity* pvalue = rtxMemAllocType (pctxt, TS24501IE_MobileIdentity);
   asn1Init_TS24501IE_MobileIdentity (pvalue);

   pvalue->t =  8;
   {
      static const OSOCTET testdata[] = {
      0xdd, 0xc1, 0x1e, 0x84, 0xda, 0x65, 0xc8, 0xda };
      OSCRTLSAFEMEMCPY ((void*)pvalue->u.eui_64, 8, testdata, 8);
   }
   return (pvalue);
}

TS24501IE_NetworkFeatureSupport*
    asn1Test_TS24501IE_NetworkFeatureSupport (OSCTXT* pctxt)
{
   TS24501IE_NetworkFeatureSupport* pvalue = rtxMemAllocType (pctxt, TS24501IE_NetworkFeatureSupport);
   asn1Init_TS24501IE_NetworkFeatureSupport (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->mpsInd = 1;

   pvalue->interNetworkWithoutN26Ind = 1;

   pvalue->emfInd = 1;

   pvalue->emcInd = 2;

   pvalue->imsVoPSN3GPPInd = 0;

   pvalue->imsVoPS3GPPInd = 1;

   pvalue->m.octet4Present = 1;

   pvalue->octet4.upCIoT = 1;

   pvalue->octet4.hcCpCIoT = 1;

   pvalue->octet4.n3Data = 0;

   pvalue->octet4.cpCIoT = 1;

   pvalue->octet4.restrictedEC = 0;

   pvalue->octet4.mcsi = 0;

   pvalue->octet4.emcn3 = 1;

   pvalue->m.octet5Present = 1;

   pvalue->octet5.spare = 0;

   pvalue->octet5.pr = 0;

   pvalue->octet5.rpr = 0;

   pvalue->octet5.piv = 0;

   pvalue->octet5.ncr = 0;

   pvalue->octet5.ehcCpCIoT = 1;

   pvalue->octet5.atsInd = 0;

   pvalue->octet5.lcs = 0;
   return (pvalue);
}

TS24501IE_RegistrationResult*
    asn1Test_TS24501IE_RegistrationResult (OSCTXT* pctxt)
{
   TS24501IE_RegistrationResult* pvalue = rtxMemAllocType (pctxt, TS24501IE_RegistrationResult);
   asn1Init_TS24501IE_RegistrationResult (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 2;

   pvalue->emergencyRegistered = 1;

   pvalue->nssaa = 0;

   pvalue->smsAllowed = 1;

   pvalue->regResult = TS24501IE_RegistrationResultValue_accessAndNonAccess;
   return (pvalue);
}

TS24501IE_RegistrationType* asn1Test_TS24501IE_RegistrationType (OSCTXT* pctxt)
{
   TS24501IE_RegistrationType* pvalue = rtxMemAllocType (pctxt, TS24501IE_RegistrationType);

   pvalue->forBit = 1;

   pvalue->regisType = TS24501IE_RegistrationTypeValue_initial;
   return (pvalue);
}

TS24501IE_TrackingAreaIdent*
    asn1Test_TS24501IE_TrackingAreaIdent (OSCTXT* pctxt)
{
   TS24501IE_TrackingAreaIdent* pvalue = rtxMemAllocType (pctxt, TS24501IE_TrackingAreaIdent);
   asn1Init_TS24501IE_TrackingAreaIdent (pvalue);

   rtxStrncpy (pvalue->mcc_mnc.mcc, 4, "631", 3);
   rtxStrncpy (pvalue->mcc_mnc.mnc, 4, "02", 3);

   {
      static const OSOCTET testdata[] = {
      0x30, 0x99, 0xd1 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->tac.data, 3, testdata, 3);
   }
   return (pvalue);
}

TS24501IE_TrackingAreaIdentListItem*
    asn1Test_TS24501IE_TrackingAreaIdentListItem (OSCTXT* pctxt)
{
   TS24501IE_TrackingAreaIdentListItem* pvalue = rtxMemAllocType (pctxt, TS24501IE_TrackingAreaIdentListItem);
   asn1Init_TS24501IE_TrackingAreaIdentListItem (pvalue);

   pvalue->spare = 0;

   pvalue->typeOfList = 1;

   pvalue->numElements = 26;

   switch (pvalue->typeOfList) {
      /* partTrkIdentList0 */
      case 0:

         rtxStrncpy (pvalue->elements.u.partTrkIdentList0.mcc_mnc.mcc, 4, "214", 3);
         rtxStrncpy (pvalue->elements.u.partTrkIdentList0.mcc_mnc.mnc, 4, "04", 3);

         pvalue->elements.u.partTrkIdentList0.tacs.n = 5;
         {
            static const OSOCTET testdata[] = {
            0x55, 0xc3, 0xfc };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[0].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x03, 0x58, 0xc7 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[1].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x4b, 0xe2, 0xc0 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[2].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0xd2, 0xab, 0xe9 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[3].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x2c, 0x93, 0xc3 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[4].data, 3, testdata, 3);
         }

         break;

      /* partTrkIdentList1 */
      case 1:

         rtxStrncpy (pvalue->elements.u.partTrkIdentList1.mcc_mnc.mcc, 4, "608", 3);
         rtxStrncpy (pvalue->elements.u.partTrkIdentList1.mcc_mnc.mnc, 4, "02", 3);

         {
            static const OSOCTET testdata[] = {
            0x82, 0x1f, 0x30 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList1.tac.data, 3, testdata, 3);
         }
         break;

      /* partTrkIdentList2 */
      case 2:
         pvalue->elements.u.partTrkIdentList2.n = 1;

         rtxStrncpy (pvalue->elements.u.partTrkIdentList2.elem[0].mcc_mnc.mcc, 4, "706", 3);
         rtxStrncpy (pvalue->elements.u.partTrkIdentList2.elem[0].mcc_mnc.mnc, 4, "02", 3);

         {
            static const OSOCTET testdata[] = {
            0xbb, 0xfa, 0x9f };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList2.elem[0].tac.data, 3, testdata, 3);
         }

         break;

      /* partTrkIdentList3 */
      case 3:
         rtxStrncpy (pvalue->elements.u.partTrkIdentList3.mcc, 4, "219", 3);
         rtxStrncpy (pvalue->elements.u.partTrkIdentList3.mnc, 4, "10", 3);
         break;

      default: break;
   }
   return (pvalue);
}

TS24501IE_TrackingAreaIdentList*
    asn1Test_TS24501IE_TrackingAreaIdentList (OSCTXT* pctxt)
{
   TS24501IE_TrackingAreaIdentList* pvalue = rtxMemAllocType (pctxt, TS24501IE_TrackingAreaIdentList);
   asn1Init_TS24501IE_TrackingAreaIdentList (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->idents.n = 1;

   pvalue->idents.elem[0].spare = 0;

   pvalue->idents.elem[0].typeOfList = 1;

   pvalue->idents.elem[0].numElements = 15;

   switch (pvalue->idents.elem[0].typeOfList) {
      /* partTrkIdentList0 */
      case 0:

         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mcc, 4, "240", 3);
         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mnc, 4, "02", 3);

         pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.n = 7;
         {
            static const OSOCTET testdata[] = {
            0xb2, 0x47, 0x56 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[0].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x87, 0x8a, 0x53 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[1].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x8b, 0x62, 0x9a };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[2].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x56, 0xc5, 0x5b };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[3].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x2a, 0xf0, 0xc5 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[4].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x56, 0x85, 0x89 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[5].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0xd8, 0x08, 0x28 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[6].data, 3, testdata, 3);
         }

         break;

      /* partTrkIdentList1 */
      case 1:

         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mcc, 4, "255", 3);
         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mnc, 4, "05", 3);

         {
            static const OSOCTET testdata[] = {
            0x56, 0xe3, 0x04 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList1.tac.data, 3, testdata, 3);
         }
         break;

      /* partTrkIdentList2 */
      case 2:
         pvalue->idents.elem[0].elements.u.partTrkIdentList2.n = 1;

         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mcc, 4, "404", 3);
         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mnc, 4, "42", 3);

         {
            static const OSOCTET testdata[] = {
            0x16, 0xae, 0x30 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList2.elem[0].tac.data, 3, testdata, 3);
         }

         break;

      /* partTrkIdentList3 */
      case 3:
         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList3.mcc, 4, "457", 3);
         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList3.mnc, 4, "01", 3);
         break;

      default: break;
   }

   return (pvalue);
}

TS24501IE_UpdateType* asn1Test_TS24501IE_UpdateType (OSCTXT* pctxt)
{
   TS24501IE_UpdateType* pvalue = rtxMemAllocType (pctxt, TS24501IE_UpdateType);
   asn1Init_TS24501IE_UpdateType (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 1;

   pvalue->epsPnbCIoT = 1;

   pvalue->pnbCIoT = 2;

   pvalue->ngranUpd = 0;

   pvalue->smsReq = 1;
   return (pvalue);
}

TS24501IE_AddlSecurityInfo* asn1Test_TS24501IE_AddlSecurityInfo (OSCTXT* pctxt)
{
   TS24501IE_AddlSecurityInfo* pvalue = rtxMemAllocType (pctxt, TS24501IE_AddlSecurityInfo);
   asn1Init_TS24501IE_AddlSecurityInfo (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 53;

   pvalue->rinmr = 1;

   pvalue->hdp = 0;
   return (pvalue);
}

TS24501IE_AdditionalInfoRequested*
    asn1Test_TS24501IE_AdditionalInfoRequested (OSCTXT* pctxt)
{
   TS24501IE_AdditionalInfoRequested* pvalue = rtxMemAllocType (pctxt, TS24501IE_AdditionalInfoRequested);
   asn1Init_TS24501IE_AdditionalInfoRequested (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 48;

   pvalue->cipherKey = 1;
   return (pvalue);
}

TS24501IE_AllowedPDUSessionStatus*
    asn1Test_TS24501IE_AllowedPDUSessionStatus (OSCTXT* pctxt)
{
   TS24501IE_AllowedPDUSessionStatus* pvalue = rtxMemAllocType (pctxt, TS24501IE_AllowedPDUSessionStatus);
   asn1Init_TS24501IE_AllowedPDUSessionStatus (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->psi.elem[0] = 1;

   pvalue->psi.elem[1] = 1;

   pvalue->psi.elem[2] = 1;

   pvalue->psi.elem[3] = 1;

   pvalue->psi.elem[4] = 0;

   pvalue->psi.elem[5] = 0;

   pvalue->psi.elem[6] = 0;

   pvalue->psi.elem[7] = 0;

   pvalue->psi.elem[8] = 1;

   pvalue->psi.elem[9] = 0;

   pvalue->psi.elem[10] = 1;

   pvalue->psi.elem[11] = 1;

   pvalue->psi.elem[12] = 1;

   pvalue->psi.elem[13] = 1;

   pvalue->psi.elem[14] = 0;

   pvalue->psi.elem[15] = 0;

   pvalue->m.sparePresent = 1;
   pvalue->spare.numocts = 10;
   pvalue->spare.data = (OSOCTET*) rtxMemAlloc (pctxt, 10);
   {
      static const OSOCTET testdata[] = {
      0x6b, 0x62, 0x90, 0x06, 0xbd, 0xf2, 0xe7, 0xee, 
      0xdc, 0x55 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->spare.data, 10, testdata, 10);
   }
   return (pvalue);
}

TS24501IE_ConfigUpdateIndication*
    asn1Test_TS24501IE_ConfigUpdateIndication (OSCTXT* pctxt)
{
   TS24501IE_ConfigUpdateIndication* pvalue = rtxMemAllocType (pctxt, TS24501IE_ConfigUpdateIndication);
   asn1Init_TS24501IE_ConfigUpdateIndication (pvalue);

   pvalue->spare = 1;

   pvalue->regRequested = 0;

   pvalue->ack = 1;
   return (pvalue);
}

TS24501IE_CAGEntry* asn1Test_TS24501IE_CAGEntry (OSCTXT* pctxt)
{
   TS24501IE_CAGEntry* pvalue = rtxMemAllocType (pctxt, TS24501IE_CAGEntry);
   asn1Init_TS24501IE_CAGEntry (pvalue);

   pvalue->length = 73;

   rtxStrncpy (pvalue->mcc_mnc.mcc, 4, "334", 3);
   rtxStrncpy (pvalue->mcc_mnc.mnc, 4, "02", 3);

   pvalue->spare = 112;

   pvalue->cagOnly = 1;

   pvalue->m.cagIDPresent = 1;
   pvalue->cagID.numocts = 5;
   pvalue->cagID.data = (OSOCTET*) rtxMemAlloc (pctxt, 5);
   {
      static const OSOCTET testdata[] = {
      0xc0, 0xce, 0xe1, 0x4d, 0x18 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->cagID.data, 5, testdata, 5);
   }
   return (pvalue);
}

TS24501IE_CAGInfoList* asn1Test_TS24501IE_CAGInfoList (OSCTXT* pctxt)
{
   TS24501IE_CAGInfoList* pvalue = rtxMemAllocType (pctxt, TS24501IE_CAGInfoList);
   asn1Init_TS24501IE_CAGInfoList (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->m.entriesPresent = 1;
   /* zero elements */
   return (pvalue);
}

TS24501IE_CIoTSmallDataContainer*
    asn1Test_TS24501IE_CIoTSmallDataContainer (OSCTXT* pctxt)
{
   TS24501IE_CIoTSmallDataContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_CIoTSmallDataContainer);
   asn1Init_TS24501IE_CIoTSmallDataContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->dataType = TS24501IE_CIoTDataTypes_ciotCtrlPlaneUserData;

   switch (pvalue->dataType) {
      /* ctrlPlaneUserData */
      case 0:

         pvalue->containerContents.u.ctrlPlaneUserData.ddx = 2;

         pvalue->containerContents.u.ctrlPlaneUserData.pduSessionId = 3;
         break;

      /* sms */
      case 1:

         pvalue->containerContents.u.sms.spare = 4;
         break;

      /* locSvcsMsgContainer */
      case 2:

         pvalue->containerContents.u.locSvcsMsgContainer.ddx = 0;

         pvalue->containerContents.u.locSvcsMsgContainer.spare = 0;

         pvalue->containerContents.u.locSvcsMsgContainer.addlInfoLen = 107;

         pvalue->containerContents.u.locSvcsMsgContainer.m.addlInfoPresent = 1;
         pvalue->containerContents.u.locSvcsMsgContainer.addlInfo.numocts = 17;
         pvalue->containerContents.u.locSvcsMsgContainer.addlInfo.data = (OSOCTET*) rtxMemAlloc (pctxt, 17);
         {
            static const OSOCTET testdata[] = {
            0xca, 0xcd, 0x3c, 0x50, 0x0c, 0x2f, 0x39, 0x7a, 
            0x8c, 0x8e, 0xee, 0x5f, 0xb3, 0x81, 0xfd, 0xed, 
            0x8f };
            OSCRTLSAFEMEMCPY ((void*)pvalue->containerContents.u.locSvcsMsgContainer.addlInfo.data, 17, testdata, 17);
         }
         break;

      default: break;
   }

   pvalue->contents.numocts = 13;
   pvalue->contents.data = (OSOCTET*) rtxMemAlloc (pctxt, 13);
   {
      static const OSOCTET testdata[] = {
      0xae, 0xdd, 0x75, 0x7b, 0xf5, 0xfd, 0x5d, 0x00, 
      0x36, 0x28, 0xde, 0xa1, 0x54 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.data, 13, testdata, 13);
   }
   return (pvalue);
}

TS24501IE_CipherDataSet* asn1Test_TS24501IE_CipherDataSet (OSCTXT* pctxt)
{
   TS24501IE_CipherDataSet* pvalue = rtxMemAllocType (pctxt, TS24501IE_CipherDataSet);
   asn1Init_TS24501IE_CipherDataSet (pvalue);

   {
      static const OSOCTET testdata[] = {
      0xa9, 0xee, 0x10, 0xf9, 0x7a, 0x40, 0x33, 0xf5, 
      0x4c, 0x41, 0x64, 0x2b, 0xf4, 0xe5, 0x29, 0x62 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->cipherKey, 16, testdata, 16);
   }

   pvalue->spare1 = 2;

   pvalue->c0Len = 12;

   pvalue->c0.numocts = 6;
   pvalue->c0.data = (OSOCTET*) rtxMemAlloc (pctxt, 6);
   {
      static const OSOCTET testdata[] = {
      0xd2, 0xb1, 0x0d, 0xc8, 0xaf, 0xe9 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->c0.data, 6, testdata, 6);
   }

   pvalue->spare2 = 12;

   pvalue->eutraPosSIBLen = 11;

   pvalue->eutraPosSIBType.elem[0] = 0;

   pvalue->eutraPosSIBType.elem[1] = 1;

   pvalue->eutraPosSIBType.elem[2] = 0;

   pvalue->eutraPosSIBType.elem[3] = 0;

   pvalue->eutraPosSIBType.elem[4] = 0;

   pvalue->eutraPosSIBType.elem[5] = 0;

   pvalue->eutraPosSIBType.elem[6] = 1;

   pvalue->eutraPosSIBType.elem[7] = 0;

   pvalue->eutraPosSIBType.elem[8] = 1;

   pvalue->eutraPosSIBType.elem[9] = 0;

   pvalue->eutraPosSIBType.elem[10] = 0;

   pvalue->eutraPosSIBType.elem[11] = 0;

   pvalue->eutraPosSIBType.elem[12] = 0;

   pvalue->eutraPosSIBType.elem[13] = 0;

   pvalue->eutraPosSIBType.elem[14] = 1;

   pvalue->eutraPosSIBType.elem[15] = 1;

   pvalue->eutraPosSIBType.elem[16] = 1;

   pvalue->eutraPosSIBType.elem[17] = 0;

   pvalue->eutraPosSIBType.elem[18] = 0;

   pvalue->eutraPosSIBType.elem[19] = 1;

   pvalue->eutraPosSIBType.elem[20] = 0;

   pvalue->eutraPosSIBType.elem[21] = 1;

   pvalue->eutraPosSIBType.elem[22] = 0;

   pvalue->eutraPosSIBType.elem[23] = 0;

   pvalue->eutraPosSIBType.elem[24] = 1;

   pvalue->eutraPosSIBType.elem[25] = 1;

   pvalue->eutraPosSIBType.elem[26] = 0;

   pvalue->eutraPosSIBType.elem[27] = 1;

   pvalue->eutraPosSIBType.elem[28] = 1;

   pvalue->eutraPosSIBType.elem[29] = 1;

   pvalue->eutraPosSIBType.elem[30] = 1;

   pvalue->eutraPosSIBType.elem[31] = 1;

   pvalue->spare3 = 10;

   pvalue->nrPosSIBLen = 0;

   pvalue->nrPosSIBType.elem[0] = 1;

   pvalue->nrPosSIBType.elem[1] = 0;

   pvalue->nrPosSIBType.elem[2] = 1;

   pvalue->nrPosSIBType.elem[3] = 1;

   pvalue->nrPosSIBType.elem[4] = 1;

   pvalue->nrPosSIBType.elem[5] = 1;

   pvalue->nrPosSIBType.elem[6] = 1;

   pvalue->nrPosSIBType.elem[7] = 1;

   pvalue->nrPosSIBType.elem[8] = 1;

   pvalue->nrPosSIBType.elem[9] = 0;

   pvalue->nrPosSIBType.elem[10] = 1;

   pvalue->nrPosSIBType.elem[11] = 1;

   pvalue->nrPosSIBType.elem[12] = 1;

   pvalue->nrPosSIBType.elem[13] = 0;

   pvalue->nrPosSIBType.elem[14] = 1;

   pvalue->nrPosSIBType.elem[15] = 0;

   pvalue->nrPosSIBType.elem[16] = 0;

   pvalue->nrPosSIBType.elem[17] = 0;

   pvalue->nrPosSIBType.elem[18] = 1;

   pvalue->nrPosSIBType.elem[19] = 0;

   pvalue->nrPosSIBType.elem[20] = 0;

   pvalue->nrPosSIBType.elem[21] = 0;

   pvalue->nrPosSIBType.elem[22] = 1;

   pvalue->nrPosSIBType.elem[23] = 1;

   pvalue->nrPosSIBType.elem[24] = 0;

   pvalue->nrPosSIBType.elem[25] = 1;

   pvalue->nrPosSIBType.elem[26] = 0;

   pvalue->nrPosSIBType.elem[27] = 1;

   pvalue->nrPosSIBType.elem[28] = 0;

   pvalue->nrPosSIBType.elem[29] = 1;

   pvalue->nrPosSIBType.elem[30] = 0;

   pvalue->nrPosSIBType.elem[31] = 0;

   pvalue->nrPosSIBType.elem[32] = 1;

   pvalue->nrPosSIBType.elem[33] = 0;

   pvalue->nrPosSIBType.elem[34] = 1;

   pvalue->nrPosSIBType.elem[35] = 0;

   pvalue->nrPosSIBType.elem[36] = 1;

   pvalue->spare4 = 1;

   pvalue->validityStartTime.year = 214;

   pvalue->validityStartTime.month = 45;

   pvalue->validityStartTime.day = 191;

   pvalue->validityStartTime.hour = 95;

   pvalue->validityStartTime.minute = 40;

   pvalue->validityStartTime.second = 57;

   pvalue->validityStartTime.timezone = 27;

   pvalue->validityDuration = 15384;

   pvalue->taiList.length = 0; /* length will be calculated */

   pvalue->taiList.idents.n = 1;

   pvalue->taiList.idents.elem[0].spare = 0;

   pvalue->taiList.idents.elem[0].typeOfList = 2;

   pvalue->taiList.idents.elem[0].numElements = 11;

   switch (pvalue->taiList.idents.elem[0].typeOfList) {
      /* partTrkIdentList0 */
      case 0:

         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mcc, 4, "250", 3);
         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mnc, 4, "92", 3);

         pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.n = 10;
         {
            static const OSOCTET testdata[] = {
            0x6a, 0x70, 0x18 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[0].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x9b, 0xfb, 0xb7 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[1].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0xec, 0x91, 0xb2 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[2].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x71, 0xd5, 0x0f };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[3].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x8e, 0x1a, 0x44 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[4].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0xbb, 0xa9, 0xc1 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[5].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x30, 0x00, 0xef };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[6].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x70, 0x5f, 0x18 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[7].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0xa9, 0xfa, 0x6c };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[8].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0xb2, 0xe8, 0x92 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[9].data, 3, testdata, 3);
         }

         break;

      /* partTrkIdentList1 */
      case 1:

         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mcc, 4, "208", 3);
         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mnc, 4, "01", 3);

         {
            static const OSOCTET testdata[] = {
            0xd2, 0x83, 0xb7 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList1.tac.data, 3, testdata, 3);
         }
         break;

      /* partTrkIdentList2 */
      case 2:
         pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList2.n = 1;

         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mcc, 4, "425", 3);
         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mnc, 4, "05", 3);

         {
            static const OSOCTET testdata[] = {
            0x7f, 0x6f, 0xdb };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].tac.data, 3, testdata, 3);
         }

         break;

      /* partTrkIdentList3 */
      case 3:
         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList3.mcc, 4, "502", 3);
         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList3.mnc, 4, "12", 3);
         break;

      default: break;
   }

   return (pvalue);
}

TS24501IE_CipheringKeyData* asn1Test_TS24501IE_CipheringKeyData (OSCTXT* pctxt)
{
   TS24501IE_CipheringKeyData* pvalue = rtxMemAllocType (pctxt, TS24501IE_CipheringKeyData);
   asn1Init_TS24501IE_CipheringKeyData (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->dataSet.n = 1;

   {
      static const OSOCTET testdata[] = {
      0x22, 0xcc, 0x66, 0xb1, 0xda, 0x01, 0x75, 0x96, 
      0x2a, 0x38, 0xc7, 0x2a, 0x28, 0x38, 0x0a, 0x40 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].cipherKey, 16, testdata, 16);
   }

   pvalue->dataSet.elem[0].spare1 = 3;

   pvalue->dataSet.elem[0].c0Len = 22;

   pvalue->dataSet.elem[0].c0.numocts = 11;
   pvalue->dataSet.elem[0].c0.data = (OSOCTET*) rtxMemAlloc (pctxt, 11);
   {
      static const OSOCTET testdata[] = {
      0x14, 0x6d, 0xbf, 0xb3, 0x41, 0x43, 0x6c, 0x30, 
      0x43, 0x5b, 0x8b };
      OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].c0.data, 11, testdata, 11);
   }

   pvalue->dataSet.elem[0].spare2 = 1;

   pvalue->dataSet.elem[0].eutraPosSIBLen = 6;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[0] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[1] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[2] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[3] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[4] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[5] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[6] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[7] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[8] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[9] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[10] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[11] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[12] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[13] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[14] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[15] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[16] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[17] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[18] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[19] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[20] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[21] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[22] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[23] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[24] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[25] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[26] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[27] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[28] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[29] = 1;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[30] = 0;

   pvalue->dataSet.elem[0].eutraPosSIBType.elem[31] = 1;

   pvalue->dataSet.elem[0].spare3 = 4;

   pvalue->dataSet.elem[0].nrPosSIBLen = 7;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[0] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[1] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[2] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[3] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[4] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[5] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[6] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[7] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[8] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[9] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[10] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[11] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[12] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[13] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[14] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[15] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[16] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[17] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[18] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[19] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[20] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[21] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[22] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[23] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[24] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[25] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[26] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[27] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[28] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[29] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[30] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[31] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[32] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[33] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[34] = 1;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[35] = 0;

   pvalue->dataSet.elem[0].nrPosSIBType.elem[36] = 1;

   pvalue->dataSet.elem[0].spare4 = 0;

   pvalue->dataSet.elem[0].validityStartTime.year = 74;

   pvalue->dataSet.elem[0].validityStartTime.month = 69;

   pvalue->dataSet.elem[0].validityStartTime.day = 26;

   pvalue->dataSet.elem[0].validityStartTime.hour = 220;

   pvalue->dataSet.elem[0].validityStartTime.minute = 252;

   pvalue->dataSet.elem[0].validityStartTime.second = 131;

   pvalue->dataSet.elem[0].validityStartTime.timezone = 142;

   pvalue->dataSet.elem[0].validityDuration = 11388;

   pvalue->dataSet.elem[0].taiList.length = 0; /* length will be calculated */

   pvalue->dataSet.elem[0].taiList.idents.n = 1;

   pvalue->dataSet.elem[0].taiList.idents.elem[0].spare = 0;

   pvalue->dataSet.elem[0].taiList.idents.elem[0].typeOfList = 1;

   pvalue->dataSet.elem[0].taiList.idents.elem[0].numElements = 17;

   switch (pvalue->dataSet.elem[0].taiList.idents.elem[0].typeOfList) {
      /* partTrkIdentList0 */
      case 0:

         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mcc, 4, "302", 3);
         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mnc, 4, "72", 3);

         pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.n = 8;
         {
            static const OSOCTET testdata[] = {
            0xd6, 0xdb, 0xc3 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[0].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0xdd, 0xe9, 0xf9 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[1].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x6e, 0x05, 0xe9 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[2].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x5f, 0x68, 0x42 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[3].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0xe6, 0xd0, 0xa9 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[4].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0xce, 0x21, 0xfb };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[5].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0xaa, 0x6b, 0x41 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[6].data, 3, testdata, 3);
         }

         {
            static const OSOCTET testdata[] = {
            0x44, 0x48, 0xbe };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[7].data, 3, testdata, 3);
         }

         break;

      /* partTrkIdentList1 */
      case 1:

         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mcc, 4, "434", 3);
         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mnc, 4, "02", 3);

         {
            static const OSOCTET testdata[] = {
            0xd7, 0xe6, 0xf3 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList1.tac.data, 3, testdata, 3);
         }
         break;

      /* partTrkIdentList2 */
      case 2:
         pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList2.n = 1;

         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mcc, 4, "334", 3);
         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mnc, 4, "03", 3);

         {
            static const OSOCTET testdata[] = {
            0xed, 0x3c, 0xfb };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].tac.data, 3, testdata, 3);
         }

         break;

      /* partTrkIdentList3 */
      case 3:
         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList3.mcc, 4, "732", 3);
         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList3.mnc, 4, "10", 3);
         break;

      default: break;
   }

   return (pvalue);
}

TS24501IE_ControlPlaneServiceType*
    asn1Test_TS24501IE_ControlPlaneServiceType (OSCTXT* pctxt)
{
   TS24501IE_ControlPlaneServiceType* pvalue = rtxMemAllocType (pctxt, TS24501IE_ControlPlaneServiceType);
   asn1Init_TS24501IE_ControlPlaneServiceType (pvalue);

   pvalue->spare = 0;

   pvalue->value = 4;
   return (pvalue);
}

TS24501IE_DeregistrationType*
    asn1Test_TS24501IE_DeregistrationType (OSCTXT* pctxt)
{
   TS24501IE_DeregistrationType* pvalue = rtxMemAllocType (pctxt, TS24501IE_DeregistrationType);

   pvalue->switchOff = 0;

   pvalue->reregReqd = 0;

   pvalue->accessType = 0;
   return (pvalue);
}

TS24501IE_EPSMessageContainer*
    asn1Test_TS24501IE_EPSMessageContainer (OSCTXT* pctxt)
{
   TS24501IE_EPSMessageContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_EPSMessageContainer);
   asn1Init_TS24501IE_EPSMessageContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->contents.n = 4;
   pvalue->contents.elem = rtxMemAllocArrayZ (pctxt, 4, TS24301IE_NASMessageContainer);
   pvalue->contents.elem[0].numocts = 2;
   {
      static const OSOCTET testdata[] = {
      0x37, 0x64 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[0].data, 2, testdata, 2);
   }

   pvalue->contents.elem[1].numocts = 2;
   {
      static const OSOCTET testdata[] = {
      0xa6, 0xa0 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[1].data, 2, testdata, 2);
   }

   pvalue->contents.elem[2].numocts = 2;
   {
      static const OSOCTET testdata[] = {
      0xa6, 0x0d };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[2].data, 2, testdata, 2);
   }

   pvalue->contents.elem[3].numocts = 2;
   {
      static const OSOCTET testdata[] = {
      0xf0, 0xcf };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[3].data, 2, testdata, 2);
   }

   return (pvalue);
}

TS24501IE_LADNIndication* asn1Test_TS24501IE_LADNIndication (OSCTXT* pctxt)
{
   TS24501IE_LADNIndication* pvalue = rtxMemAllocType (pctxt, TS24501IE_LADNIndication);
   asn1Init_TS24501IE_LADNIndication (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->m.contentsPresent = 1;
   /* zero elements */
   return (pvalue);
}

TS24501IE_LADN* asn1Test_TS24501IE_LADN (OSCTXT* pctxt)
{
   TS24501IE_LADN* pvalue = rtxMemAllocType (pctxt, TS24501IE_LADN);
   asn1Init_TS24501IE_LADN (pvalue);

   pvalue->dnn.length = 0; /* length will be calculated */

   pvalue->dnn.apn.n = 4;
   pvalue->dnn.apn.elem = rtxMemAllocArrayZ (pctxt, 4, const char*);
   pvalue->dnn.apn.elem[0] = "f@DEp9htu";

   pvalue->dnn.apn.elem[1] = "JtXRJSp";

   pvalue->dnn.apn.elem[2] = "_";

   pvalue->dnn.apn.elem[3] = "tJndY";

   rtxStrncpy (pvalue->tai.mcc_mnc.mcc, 4, "286", 3);
   rtxStrncpy (pvalue->tai.mcc_mnc.mnc, 4, "01", 3);

   {
      static const OSOCTET testdata[] = {
      0x6f, 0xf6, 0x64 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->tai.tac.data, 3, testdata, 3);
   }
   return (pvalue);
}

TS24501IE_LADNList* asn1Test_TS24501IE_LADNList (OSCTXT* pctxt)
{
   TS24501IE_LADNList* pvalue = rtxMemAllocType (pctxt, TS24501IE_LADNList);
   asn1Init_TS24501IE_LADNList (pvalue);

   pvalue->length = 0; /* length will be calculated */

   /* zero elements */
   return (pvalue);
}

TS24501IE_MICOIndication* asn1Test_TS24501IE_MICOIndication (OSCTXT* pctxt)
{
   TS24501IE_MICOIndication* pvalue = rtxMemAllocType (pctxt, TS24501IE_MICOIndication);
   asn1Init_TS24501IE_MICOIndication (pvalue);

   pvalue->spare = 1;

   pvalue->sprti = 1;

   pvalue->raai = 1;
   return (pvalue);
}

TS24501IE_MappedSNSSAIContent*
    asn1Test_TS24501IE_MappedSNSSAIContent (OSCTXT* pctxt)
{
   TS24501IE_MappedSNSSAIContent* pvalue = rtxMemAllocType (pctxt, TS24501IE_MappedSNSSAIContent);
   asn1Init_TS24501IE_MappedSNSSAIContent (pvalue);

   pvalue->length = 22;

   {
      static const OSOCTET testdata[] = {
      0x39 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->mappedSST, 1, testdata, 1);
   }

   pvalue->m.mappedSDPresent = 1;
   pvalue->mappedSD.numocts = 6;
   pvalue->mappedSD.data = (OSOCTET*) rtxMemAlloc (pctxt, 6);
   {
      static const OSOCTET testdata[] = {
      0xd2, 0xd6, 0x72, 0xd8, 0x98, 0x92 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->mappedSD.data, 6, testdata, 6);
   }
   return (pvalue);
}

TS24501IE_MappedNSSAI* asn1Test_TS24501IE_MappedNSSAI (OSCTXT* pctxt)
{
   TS24501IE_MappedNSSAI* pvalue = rtxMemAllocType (pctxt, TS24501IE_MappedNSSAI);
   asn1Init_TS24501IE_MappedNSSAI (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->contents.n = 1;

   pvalue->contents.elem[0].length = 237;

   {
      static const OSOCTET testdata[] = {
      0xd5 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[0].mappedSST, 1, testdata, 1);
   }

   pvalue->contents.elem[0].m.mappedSDPresent = 1;
   pvalue->contents.elem[0].mappedSD.numocts = 13;
   pvalue->contents.elem[0].mappedSD.data = (OSOCTET*) rtxMemAlloc (pctxt, 13);
   {
      static const OSOCTET testdata[] = {
      0xdd, 0xeb, 0x19, 0x9b, 0xca, 0xec, 0xbc, 0x51, 
      0x61, 0x84, 0xe4, 0x46, 0x9d };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[0].mappedSD.data, 13, testdata, 13);
   }

   return (pvalue);
}

TS24501IE_NASMessageContainer2*
    asn1Test_TS24501IE_NASMessageContainer2 (OSCTXT* pctxt)
{
   TS24501IE_NASMessageContainer2* pvalue = rtxMemAllocType (pctxt, TS24501IE_NASMessageContainer2);
   asn1Init_TS24501IE_NASMessageContainer2 (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->contents.numocts = 1;
   pvalue->contents.data = (OSOCTET*) rtxMemAlloc (pctxt, 1);
   {
      static const OSOCTET testdata[] = {
      0xd3 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.data, 1, testdata, 1);
   }
   return (pvalue);
}

TS24501IE_NASSecurityAlgorithm*
    asn1Test_TS24501IE_NASSecurityAlgorithm (OSCTXT* pctxt)
{
   TS24501IE_NASSecurityAlgorithm* pvalue = rtxMemAllocType (pctxt, TS24501IE_NASSecurityAlgorithm);

   pvalue->cipherType = TS24501IE_CipherTypes_ia7;

   pvalue->protectionType = TS24501IE_ProtectionTypes_ea2;
   return (pvalue);
}

TS24501IE_NetSliceIndication*
    asn1Test_TS24501IE_NetSliceIndication (OSCTXT* pctxt)
{
   TS24501IE_NetSliceIndication* pvalue = rtxMemAllocType (pctxt, TS24501IE_NetSliceIndication);
   asn1Init_TS24501IE_NetSliceIndication (pvalue);

   pvalue->spare = 0;

   pvalue->dcni = 0;

   pvalue->nssci = 1;
   return (pvalue);
}

TS24501IE_NSSAI* asn1Test_TS24501IE_NSSAI (OSCTXT* pctxt)
{
   TS24501IE_NSSAI* pvalue = rtxMemAllocType (pctxt, TS24501IE_NSSAI);
   asn1Init_TS24501IE_NSSAI (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->contents.n = 1;
   pvalue->contents.elem[0].length = 0; /* length will be calculated */

   pvalue->contents.elem[0].sst = 224;

   pvalue->contents.elem[0].m.sdPresent = 1;
   pvalue->contents.elem[0].sd = 14334550;

   pvalue->contents.elem[0].m.mappedSSTPresent = 1;
   {
      static const OSOCTET testdata[] = {
      0xb3 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[0].mappedSST, 1, testdata, 1);
   }

   pvalue->contents.elem[0].m.mappedSDPresent = 1;
   {
      static const OSOCTET testdata[] = {
      0xdd, 0xc1, 0x26 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.elem[0].mappedSD, 3, testdata, 3);
   }

   return (pvalue);
}

TS24501IE_NSSAIInclusionMode*
    asn1Test_TS24501IE_NSSAIInclusionMode (OSCTXT* pctxt)
{
   TS24501IE_NSSAIInclusionMode* pvalue = rtxMemAllocType (pctxt, TS24501IE_NSSAIInclusionMode);
   asn1Init_TS24501IE_NSSAIInclusionMode (pvalue);

   pvalue->spare = 0;

   pvalue->inclusionMode = TS24501IE_NSSAIInclusionMode_inclusionMode_modeB;
   return (pvalue);
}

TS24501IE_AccessCategoryDefinition*
    asn1Test_TS24501IE_AccessCategoryDefinition (OSCTXT* pctxt)
{
   TS24501IE_AccessCategoryDefinition* pvalue = rtxMemAllocType (pctxt, TS24501IE_AccessCategoryDefinition);
   asn1Init_TS24501IE_AccessCategoryDefinition (pvalue);

   pvalue->precedence = 76;

   pvalue->psac = 0;

   pvalue->spare = 1;

   pvalue->categoryNum = 18;
   pvalue->length = 0; /* length will be calculated */

   /* zero elements */

   pvalue->m.categoriesPresent = 1;

   pvalue->categories.spare2 = 6;

   pvalue->categories.accessCategory = TS24501IE_AccessCategories_category7;
   return (pvalue);
}

TS24501IE_AccessCategoryDefinitions*
    asn1Test_TS24501IE_AccessCategoryDefinitions (OSCTXT* pctxt)
{
   TS24501IE_AccessCategoryDefinitions* pvalue = rtxMemAllocType (pctxt, TS24501IE_AccessCategoryDefinitions);
   asn1Init_TS24501IE_AccessCategoryDefinitions (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->m.contentsPresent = 1;
   /* zero elements */
   return (pvalue);
}

TS24501IE_OptionalIE* asn1Test_TS24501IE_OptionalIE (OSCTXT* pctxt)
{
   TS24501IE_OptionalIE* pvalue = rtxMemAllocType (pctxt, TS24501IE_OptionalIE);
   asn1Init_TS24501IE_OptionalIE (pvalue);

   pvalue->type = 202;

   pvalue->value.numocts = 4;
   pvalue->value.data = (OSOCTET*) rtxMemAlloc (pctxt, 4);
   {
      static const OSOCTET testdata[] = {
      0xbb, 0x08, 0x38, 0x1e };
      OSCRTLSAFEMEMCPY ((void*)pvalue->value.data, 4, testdata, 4);
   }
   return (pvalue);
}

TS24501IE_PayloadContainerEntry*
    asn1Test_TS24501IE_PayloadContainerEntry (OSCTXT* pctxt)
{
   TS24501IE_PayloadContainerEntry* pvalue = rtxMemAllocType (pctxt, TS24501IE_PayloadContainerEntry);
   asn1Init_TS24501IE_PayloadContainerEntry (pvalue);

   pvalue->entryLength = 176;

   pvalue->numOptIEs = 10;

   pvalue->type = TS24501IE_PayloadContainerType_multPayloads;

   pvalue->optionalIEs.n = 1;

   pvalue->optionalIEs.elem[0].type = 42;

   pvalue->optionalIEs.elem[0].value.numocts = 20;
   pvalue->optionalIEs.elem[0].value.data = (OSOCTET*) rtxMemAlloc (pctxt, 20);
   {
      static const OSOCTET testdata[] = {
      0xa1, 0xac, 0xba, 0xd2, 0xa0, 0x45, 0xbd, 0x54, 
      0xa2, 0xfe, 0xf9, 0x58, 0x59, 0xb3, 0x2a, 0x88, 
      0xe8, 0xda, 0x25, 0x38 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->optionalIEs.elem[0].value.data, 20, testdata, 20);
   }

   pvalue->contents.numocts = 0;
   pvalue->contents.data = (OSOCTET*) 0;
   return (pvalue);
}

TS24501IE_PayloadContainerContents*
    asn1Test_TS24501IE_PayloadContainerContents (OSCTXT* pctxt)
{
   TS24501IE_PayloadContainerContents* pvalue = rtxMemAllocType (pctxt, TS24501IE_PayloadContainerContents);
   asn1Init_TS24501IE_PayloadContainerContents (pvalue);

   pvalue->numEntries = 165;

   /* zero elements */
   return (pvalue);
}

TS24501IE_MultiPayloadContainer*
    asn1Test_TS24501IE_MultiPayloadContainer (OSCTXT* pctxt)
{
   TS24501IE_MultiPayloadContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_MultiPayloadContainer);
   asn1Init_TS24501IE_MultiPayloadContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->contents.numEntries = 12;

   /* zero elements */
   return (pvalue);
}

TS24501IE_ReactivateCause* asn1Test_TS24501IE_ReactivateCause (OSCTXT* pctxt)
{
   TS24501IE_ReactivateCause* pvalue = rtxMemAllocType (pctxt, TS24501IE_ReactivateCause);

   pvalue->sessionId = 244;

   pvalue->cause = 173;
   return (pvalue);
}

TS24501IE_SessionReactivateCause*
    asn1Test_TS24501IE_SessionReactivateCause (OSCTXT* pctxt)
{
   TS24501IE_SessionReactivateCause* pvalue = rtxMemAllocType (pctxt, TS24501IE_SessionReactivateCause);
   asn1Init_TS24501IE_SessionReactivateCause (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->reactivateCause.n = 1;

   pvalue->reactivateCause.elem[0].sessionId = 195;

   pvalue->reactivateCause.elem[0].cause = 146;

   return (pvalue);
}

TS24501IE_RejectedNSSAI* asn1Test_TS24501IE_RejectedNSSAI (OSCTXT* pctxt)
{
   TS24501IE_RejectedNSSAI* pvalue = rtxMemAllocType (pctxt, TS24501IE_RejectedNSSAI);
   asn1Init_TS24501IE_RejectedNSSAI (pvalue);

   pvalue->length = 2;

   pvalue->cause = TS24501IE_RejectedNSSAI_cause_causeMAX;

   pvalue->sst = 86;

   pvalue->m.sdPresent = 1;
   pvalue->sd = 5726890;
   return (pvalue);
}

TS24501IE_RejectedNSSAIList*
    asn1Test_TS24501IE_RejectedNSSAIList (OSCTXT* pctxt)
{
   TS24501IE_RejectedNSSAIList* pvalue = rtxMemAllocType (pctxt, TS24501IE_RejectedNSSAIList);
   asn1Init_TS24501IE_RejectedNSSAIList (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->rejectedNSSAI.n = 1;

   pvalue->rejectedNSSAI.elem[0].length = 1;

   pvalue->rejectedNSSAI.elem[0].cause = TS24501IE_RejectedNSSAI_cause_unavailInCurrRegisArea;

   pvalue->rejectedNSSAI.elem[0].sst = 45;

   pvalue->rejectedNSSAI.elem[0].m.sdPresent = 1;
   pvalue->rejectedNSSAI.elem[0].sd = 13709224;

   return (pvalue);
}

TS24501IE_RequestType* asn1Test_TS24501IE_RequestType (OSCTXT* pctxt)
{
   TS24501IE_RequestType* pvalue = rtxMemAllocType (pctxt, TS24501IE_RequestType);
   asn1Init_TS24501IE_RequestType (pvalue);

   pvalue->spare = 0;

   pvalue->reqType = TS24501IE_RequestTypes_reqTypeMAX;
   return (pvalue);
}

TS24501IE_SMSIndication* asn1Test_TS24501IE_SMSIndication (OSCTXT* pctxt)
{
   TS24501IE_SMSIndication* pvalue = rtxMemAllocType (pctxt, TS24501IE_SMSIndication);
   asn1Init_TS24501IE_SMSIndication (pvalue);

   pvalue->spare = 5;

   pvalue->sai = 1;
   return (pvalue);
}

TS24501IE_PLMNTechList* asn1Test_TS24501IE_PLMNTechList (OSCTXT* pctxt)
{
   TS24501IE_PLMNTechList* pvalue = rtxMemAllocType (pctxt, TS24501IE_PLMNTechList);

   {
      static const OSOCTET testdata[] = {
      0x28, 0x86, 0xf1 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->id, 3, testdata, 3);
   }

   {
      static const OSOCTET testdata[] = {
      0x28, 0x81 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->techId, 2, testdata, 2);
   }
   return (pvalue);
}

TS24501IE_SORSteering* asn1Test_TS24501IE_SORSteering (OSCTXT* pctxt)
{
   TS24501IE_SORSteering* pvalue = rtxMemAllocType (pctxt, TS24501IE_SORSteering);
   asn1Init_TS24501IE_SORSteering (pvalue);

   pvalue->spare = 2;

   pvalue->ap = 1;

   pvalue->ack = 1;

   pvalue->listType = 0;

   pvalue->listInd = 0;

   pvalue->dataType = 0;

   {
      static const OSOCTET testdata[] = {
      0xcf, 0x2f, 0x56, 0xf5, 0xba, 0xca, 0x23, 0x7e, 
      0xdc, 0xdd, 0xde, 0x52, 0x43, 0xae, 0xea, 0xd3 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->sorMAC, 16, testdata, 16);
   }

   {
      static const OSOCTET testdata[] = {
      0x3a, 0x55 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->counter, 2, testdata, 2);
   }

   pvalue->m.contentPresent = 1;
   switch (pvalue->listType) {
      /* securedPacket */
      case 0:
         pvalue->content.u.securedPacket.numocts = 12;
         pvalue->content.u.securedPacket.data = (OSOCTET*) rtxMemAlloc (pctxt, 12);
         {
            static const OSOCTET testdata[] = {
            0x89, 0x7d, 0x0d, 0x7c, 0x25, 0x8e, 0x47, 0x27, 
            0xc2, 0x3c, 0xb1, 0xdf };
            OSCRTLSAFEMEMCPY ((void*)pvalue->content.u.securedPacket.data, 12, testdata, 12);
         }
         break;

      /* plmnAccess */
      case 1:
         /* zero elements */
         break;

      default: break;
   }
   return (pvalue);
}

TS24501IE_SORAck* asn1Test_TS24501IE_SORAck (OSCTXT* pctxt)
{
   TS24501IE_SORAck* pvalue = rtxMemAllocType (pctxt, TS24501IE_SORAck);
   asn1Init_TS24501IE_SORAck (pvalue);

   pvalue->spare = 7;

   pvalue->mssi = 1;

   pvalue->dataType = 0;

   {
      static const OSOCTET testdata[] = {
      0x82, 0x1b, 0x00, 0xa5, 0x99, 0xdc, 0x04, 0xf7, 
      0x30, 0x47, 0xa6, 0x9a, 0x9a, 0x60, 0xef, 0xa1 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->sorMAC, 16, testdata, 16);
   }
   return (pvalue);
}

TS24501IE_SORTransparentContainer*
    asn1Test_TS24501IE_SORTransparentContainer (OSCTXT* pctxt)
{
   TS24501IE_SORTransparentContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_SORTransparentContainer);
   asn1Init_TS24501IE_SORTransparentContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->steeringOrAck.t =  2;

   pvalue->steeringOrAck.u.ack.spare = 41;

   pvalue->steeringOrAck.u.ack.mssi = 1;

   pvalue->steeringOrAck.u.ack.dataType = 0;

   {
      static const OSOCTET testdata[] = {
      0x13, 0xbc, 0xad, 0x3a, 0xfe, 0xe9, 0x6b, 0xde, 
      0x76, 0xcb, 0x95, 0xf8, 0xe6, 0x15, 0x1f, 0x80 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->steeringOrAck.u.ack.sorMAC, 16, testdata, 16);
   }
   return (pvalue);
}

TS24501IE_UEParamUpdateDataSet*
    asn1Test_TS24501IE_UEParamUpdateDataSet (OSCTXT* pctxt)
{
   TS24501IE_UEParamUpdateDataSet* pvalue = rtxMemAllocType (pctxt, TS24501IE_UEParamUpdateDataSet);
   asn1Init_TS24501IE_UEParamUpdateDataSet (pvalue);

   pvalue->spare = 2;

   pvalue->dataSetType = 5;

   pvalue->dataSetLen = 13635;

   switch (pvalue->dataSetType) {
      /* securedPacket */
      case 1:
         pvalue->dataSet.u.securedPacket.numocts = 8;
         pvalue->dataSet.u.securedPacket.data = (OSOCTET*) rtxMemAlloc (pctxt, 8);
         {
            static const OSOCTET testdata[] = {
            0xe9, 0x9e, 0xbc, 0x84, 0x7f, 0xac, 0xa5, 0xe9 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.u.securedPacket.data, 8, testdata, 8);
         }
         break;

      /* defCfgNSSAI */
      case 2:
         pvalue->dataSet.u.defCfgNSSAI.numocts = 14;
         pvalue->dataSet.u.defCfgNSSAI.data = (OSOCTET*) rtxMemAlloc (pctxt, 14);
         {
            static const OSOCTET testdata[] = {
            0xd3, 0x50, 0xac, 0x90, 0x7d, 0x66, 0x8f, 0xe6, 
            0xd1, 0xee, 0x5e, 0x9d, 0x04, 0xd6 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.u.defCfgNSSAI.data, 14, testdata, 14);
         }
         break;

      default: break;
   }
   return (pvalue);
}

TS24501IE_UEParamUpdate* asn1Test_TS24501IE_UEParamUpdate (OSCTXT* pctxt)
{
   TS24501IE_UEParamUpdate* pvalue = rtxMemAllocType (pctxt, TS24501IE_UEParamUpdate);
   asn1Init_TS24501IE_UEParamUpdate (pvalue);

   pvalue->spare = 8;

   pvalue->reg = 0;

   pvalue->ack = 1;

   pvalue->dataType = 0;

   {
      static const OSOCTET testdata[] = {
      0x8b, 0x18, 0x7c, 0x2e, 0x02, 0x9b, 0xea, 0x07, 
      0x9a, 0x17, 0xac, 0x84, 0x31, 0x81, 0x54, 0x5d };
      OSCRTLSAFEMEMCPY ((void*)pvalue->mac, 16, testdata, 16);
   }

   {
      static const OSOCTET testdata[] = {
      0x91, 0x51 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->counter, 2, testdata, 2);
   }

   /* zero elements */
   return (pvalue);
}

TS24501IE_UEParamUpdateAck* asn1Test_TS24501IE_UEParamUpdateAck (OSCTXT* pctxt)
{
   TS24501IE_UEParamUpdateAck* pvalue = rtxMemAllocType (pctxt, TS24501IE_UEParamUpdateAck);
   asn1Init_TS24501IE_UEParamUpdateAck (pvalue);

   pvalue->spare = 78;

   pvalue->dataType = 0;

   {
      static const OSOCTET testdata[] = {
      0x38, 0x16, 0x10, 0x96, 0x34, 0x14, 0xed, 0x38, 
      0xac, 0x63, 0x3d, 0x39, 0x7c, 0xb9, 0xe6, 0xfd };
      OSCRTLSAFEMEMCPY ((void*)pvalue->mac, 16, testdata, 16);
   }
   return (pvalue);
}

TS24501IE_UEParamUpdateContainer*
    asn1Test_TS24501IE_UEParamUpdateContainer (OSCTXT* pctxt)
{
   TS24501IE_UEParamUpdateContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_UEParamUpdateContainer);
   asn1Init_TS24501IE_UEParamUpdateContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->updateOrAck.t =  1;

   pvalue->updateOrAck.u.update.spare = 18;

   pvalue->updateOrAck.u.update.reg = 0;

   pvalue->updateOrAck.u.update.ack = 0;

   pvalue->updateOrAck.u.update.dataType = 0;

   {
      static const OSOCTET testdata[] = {
      0xb1, 0x73, 0x1a, 0xb2, 0x47, 0x78, 0xc3, 0x98, 
      0x3d, 0x65, 0xd1, 0xd2, 0xf4, 0xe7, 0x07, 0x09 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->updateOrAck.u.update.mac, 16, testdata, 16);
   }

   {
      static const OSOCTET testdata[] = {
      0xd5, 0x40 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->updateOrAck.u.update.counter, 2, testdata, 2);
   }

   /* zero elements */
   return (pvalue);
}

TS24501IE_UESecurityCapability*
    asn1Test_TS24501IE_UESecurityCapability (OSCTXT* pctxt)
{
   TS24501IE_UESecurityCapability* pvalue = rtxMemAllocType (pctxt, TS24501IE_UESecurityCapability);
   asn1Init_TS24501IE_UESecurityCapability (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->ea0 = 1;

   pvalue->ea1 = 0;

   pvalue->ea2 = 0;

   pvalue->ea3 = 0;

   pvalue->ea4 = 1;

   pvalue->ea5 = 0;

   pvalue->ea6 = 0;

   pvalue->ea7 = 0;

   pvalue->ia0 = 1;

   pvalue->ia1 = 0;

   pvalue->ia2 = 1;

   pvalue->ia3 = 1;

   pvalue->ia4 = 1;

   pvalue->ia5 = 0;

   pvalue->ia6 = 1;

   pvalue->ia7 = 1;

   pvalue->m.octet5Present = 1;

   pvalue->octet5.eea0 = 0;

   pvalue->octet5.eea1 = 1;

   pvalue->octet5.eea2 = 1;

   pvalue->octet5.eea3 = 1;

   pvalue->octet5.eea4 = 1;

   pvalue->octet5.eea5 = 1;

   pvalue->octet5.eea6 = 1;

   pvalue->octet5.eea7 = 0;

   pvalue->m.octet6Present = 1;

   pvalue->octet6.eia0 = 0;

   pvalue->octet6.eia1 = 1;

   pvalue->octet6.eia2 = 0;

   pvalue->octet6.eia3 = 0;

   pvalue->octet6.eia4 = 0;

   pvalue->octet6.eia5 = 1;

   pvalue->octet6.eia6 = 1;

   pvalue->octet6.eia7 = 1;

   pvalue->m.sparePresent = 1;
   pvalue->spare.numocts = 8;
   pvalue->spare.data = (OSOCTET*) rtxMemAlloc (pctxt, 8);
   {
      static const OSOCTET testdata[] = {
      0xf8, 0x6a, 0x4e, 0x30, 0x40, 0x81, 0x3c, 0xe8 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->spare.data, 8, testdata, 8);
   }
   return (pvalue);
}

TS24501IE_UEUsageSetting* asn1Test_TS24501IE_UEUsageSetting (OSCTXT* pctxt)
{
   TS24501IE_UEUsageSetting* pvalue = rtxMemAllocType (pctxt, TS24501IE_UEUsageSetting);
   asn1Init_TS24501IE_UEUsageSetting (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 70;

   pvalue->usage = 0;
   return (pvalue);
}

TS24501IE_UplinkDataStatus* asn1Test_TS24501IE_UplinkDataStatus (OSCTXT* pctxt)
{
   TS24501IE_UplinkDataStatus* pvalue = rtxMemAllocType (pctxt, TS24501IE_UplinkDataStatus);
   asn1Init_TS24501IE_UplinkDataStatus (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare1 = 1;

   pvalue->psi.elem[0] = 1;

   pvalue->psi.elem[1] = 1;

   pvalue->psi.elem[2] = 0;

   pvalue->psi.elem[3] = 1;

   pvalue->psi.elem[4] = 1;

   pvalue->psi.elem[5] = 0;

   pvalue->psi.elem[6] = 1;

   pvalue->psi.elem[7] = 0;

   pvalue->psi.elem[8] = 1;

   pvalue->psi.elem[9] = 0;

   pvalue->psi.elem[10] = 0;

   pvalue->psi.elem[11] = 1;

   pvalue->psi.elem[12] = 1;

   pvalue->psi.elem[13] = 0;

   pvalue->psi.elem[14] = 0;

   pvalue->m.spare2Present = 1;
   pvalue->spare2.numocts = 18;
   pvalue->spare2.data = (OSOCTET*) rtxMemAlloc (pctxt, 18);
   {
      static const OSOCTET testdata[] = {
      0xb3, 0x1a, 0x61, 0xcb, 0x14, 0x4b, 0x1a, 0xc3, 
      0x0c, 0x1c, 0x00, 0xf4, 0x55, 0xb6, 0xef, 0x79, 
      0x5d, 0x96 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->spare2.data, 18, testdata, 18);
   }
   return (pvalue);
}

TS24501IE_TruncatedTMSIConfig*
    asn1Test_TS24501IE_TruncatedTMSIConfig (OSCTXT* pctxt)
{
   TS24501IE_TruncatedTMSIConfig* pvalue = rtxMemAllocType (pctxt, TS24501IE_TruncatedTMSIConfig);

   pvalue->length = 0; /* length will be calculated */

   pvalue->truncatedAMFId = 12;

   pvalue->truncatedAMFPtr = 13;
   return (pvalue);
}

TS24501IE_N5GCIndication* asn1Test_TS24501IE_N5GCIndication (OSCTXT* pctxt)
{
   TS24501IE_N5GCIndication* pvalue = rtxMemAllocType (pctxt, TS24501IE_N5GCIndication);
   asn1Init_TS24501IE_N5GCIndication (pvalue);

   pvalue->spare = 0;

   pvalue->n5gcReg = 0;
   return (pvalue);
}

TS24501IE_NBN1ModeDRXParams*
    asn1Test_TS24501IE_NBN1ModeDRXParams (OSCTXT* pctxt)
{
   TS24501IE_NBN1ModeDRXParams* pvalue = rtxMemAllocType (pctxt, TS24501IE_NBN1ModeDRXParams);
   asn1Init_TS24501IE_NBN1ModeDRXParams (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 4;

   pvalue->drxValue = 9;
   return (pvalue);
}

TS24501IE_AddlConfigIndication*
    asn1Test_TS24501IE_AddlConfigIndication (OSCTXT* pctxt)
{
   TS24501IE_AddlConfigIndication* pvalue = rtxMemAllocType (pctxt, TS24501IE_AddlConfigIndication);
   asn1Init_TS24501IE_AddlConfigIndication (pvalue);

   pvalue->spare = 1;

   pvalue->scmr = 1;
   return (pvalue);
}

TS24501IE_ExtRejectedNSSAI* asn1Test_TS24501IE_ExtRejectedNSSAI (OSCTXT* pctxt)
{
   TS24501IE_ExtRejectedNSSAI* pvalue = rtxMemAllocType (pctxt, TS24501IE_ExtRejectedNSSAI);
   asn1Init_TS24501IE_ExtRejectedNSSAI (pvalue);

   pvalue->length = 12;

   pvalue->cause = TS24501IE_ExtRejectedNSSAI_cause_authPending;

   pvalue->sst = 186;

   pvalue->m.sdPresent = 1;
   pvalue->sd = 8387960;

   pvalue->m.mappedSSTPresent = 1;
   {
      static const OSOCTET testdata[] = {
      0x4a };
      OSCRTLSAFEMEMCPY ((void*)pvalue->mappedSST, 1, testdata, 1);
   }

   pvalue->m.mappedSDPresent = 1;
   {
      static const OSOCTET testdata[] = {
      0xbb, 0x2b, 0x2c };
      OSCRTLSAFEMEMCPY ((void*)pvalue->mappedSD, 3, testdata, 3);
   }
   return (pvalue);
}

TS24501IE_PartialExtRejectedNSSAI*
    asn1Test_TS24501IE_PartialExtRejectedNSSAI (OSCTXT* pctxt)
{
   TS24501IE_PartialExtRejectedNSSAI* pvalue = rtxMemAllocType (pctxt, TS24501IE_PartialExtRejectedNSSAI);
   asn1Init_TS24501IE_PartialExtRejectedNSSAI (pvalue);

   pvalue->spare = 0;

   pvalue->listType = TS24501IE_PERNTypes_pernWithoutTimer;

   pvalue->numElems = 11;

   switch (pvalue->listType) {
      /* withoutTimer */
      case 0:
         break;

      /* timerValue */
      case 1:
         pvalue->backoffTimer.u.timerValue = 46;
         break;

      default: break;
   }

   pvalue->rejectedSNSSAI.n = 1;

   pvalue->rejectedSNSSAI.elem[0].length = 5;

   pvalue->rejectedSNSSAI.elem[0].cause = TS24501IE_ExtRejectedNSSAI_cause_unavailInCurrPlmn;

   pvalue->rejectedSNSSAI.elem[0].sst = 183;

   pvalue->rejectedSNSSAI.elem[0].m.sdPresent = 1;
   pvalue->rejectedSNSSAI.elem[0].sd = 4109814;

   pvalue->rejectedSNSSAI.elem[0].m.mappedSSTPresent = 1;
   {
      static const OSOCTET testdata[] = {
      0x02 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->rejectedSNSSAI.elem[0].mappedSST, 1, testdata, 1);
   }

   pvalue->rejectedSNSSAI.elem[0].m.mappedSDPresent = 1;
   {
      static const OSOCTET testdata[] = {
      0xf7, 0x13, 0xb8 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->rejectedSNSSAI.elem[0].mappedSD, 3, testdata, 3);
   }

   return (pvalue);
}

TS24501IE_ExtRejectedNSSAIList*
    asn1Test_TS24501IE_ExtRejectedNSSAIList (OSCTXT* pctxt)
{
   TS24501IE_ExtRejectedNSSAIList* pvalue = rtxMemAllocType (pctxt, TS24501IE_ExtRejectedNSSAIList);
   asn1Init_TS24501IE_ExtRejectedNSSAIList (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->rejectedNSSAI.n = 1;

   pvalue->rejectedNSSAI.elem[0].spare = 0;

   pvalue->rejectedNSSAI.elem[0].listType = TS24501IE_PERNTypes_pernWithoutTimer;

   pvalue->rejectedNSSAI.elem[0].numElems = 8;

   switch (pvalue->rejectedNSSAI.elem[0].listType) {
      /* withoutTimer */
      case 0:
         break;

      /* timerValue */
      case 1:
         pvalue->rejectedNSSAI.elem[0].backoffTimer.u.timerValue = 232;
         break;

      default: break;
   }

   pvalue->rejectedNSSAI.elem[0].rejectedSNSSAI.n = 1;

   pvalue->rejectedNSSAI.elem[0].rejectedSNSSAI.elem[0].length = 7;

   pvalue->rejectedNSSAI.elem[0].rejectedSNSSAI.elem[0].cause = TS24501IE_ExtRejectedNSSAI_cause_unavailInCurrPlmn;

   pvalue->rejectedNSSAI.elem[0].rejectedSNSSAI.elem[0].sst = 169;

   pvalue->rejectedNSSAI.elem[0].rejectedSNSSAI.elem[0].m.sdPresent = 1;
   pvalue->rejectedNSSAI.elem[0].rejectedSNSSAI.elem[0].sd = 13500071;

   pvalue->rejectedNSSAI.elem[0].rejectedSNSSAI.elem[0].m.mappedSSTPresent = 1;
   {
      static const OSOCTET testdata[] = {
      0x20 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->rejectedNSSAI.elem[0].rejectedSNSSAI.elem[0].mappedSST, 1, testdata, 1);
   }

   pvalue->rejectedNSSAI.elem[0].rejectedSNSSAI.elem[0].m.mappedSDPresent = 1;
   {
      static const OSOCTET testdata[] = {
      0xb5, 0xf1, 0xe1 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->rejectedNSSAI.elem[0].rejectedSNSSAI.elem[0].mappedSD, 3, testdata, 3);
   }

   return (pvalue);
}

TS24501IE_MCCElement* asn1Test_TS24501IE_MCCElement (OSCTXT* pctxt)
{
   TS24501IE_MCCElement* pvalue = rtxMemAllocType (pctxt, TS24501IE_MCCElement);
   asn1Init_TS24501IE_MCCElement (pvalue);

   pvalue->mccDigit2 = 14;

   pvalue->mccDigit1 = 3;

   pvalue->mccInd = 0;

   pvalue->spare = 2;

   pvalue->mccDigit3 = 4;
   return (pvalue);
}

TS24501IE_MCCList* asn1Test_TS24501IE_MCCList (OSCTXT* pctxt)
{
   TS24501IE_MCCList* pvalue = rtxMemAllocType (pctxt, TS24501IE_MCCList);
   asn1Init_TS24501IE_MCCList (pvalue);

   pvalue->length = 0; /* length will be calculated */

   /* zero elements */
   return (pvalue);
}

TS24501IE_NetworkId* asn1Test_TS24501IE_NetworkId (OSCTXT* pctxt)
{
   TS24501IE_NetworkId* pvalue = rtxMemAllocType (pctxt, TS24501IE_NetworkId);
   asn1Init_TS24501IE_NetworkId (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->nidDigit1 = 0;

   pvalue->assignMode = 6;

   pvalue->nidDigit3 = 2;

   pvalue->nidDigit2 = 14;

   pvalue->nidDigit5 = 6;

   pvalue->nidDigit4 = 4;

   pvalue->nidDigit7 = 14;

   pvalue->nidDigit6 = 10;

   pvalue->nidDigit9 = 14;

   pvalue->nidDigit8 = 2;

   pvalue->spare = 11;

   pvalue->nidDigit10 = 1;
   return (pvalue);
}

TS24501IE_SMCapability* asn1Test_TS24501IE_SMCapability (OSCTXT* pctxt)
{
   TS24501IE_SMCapability* pvalue = rtxMemAllocType (pctxt, TS24501IE_SMCapability);
   asn1Init_TS24501IE_SMCapability (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->tpmic = 1;

   pvalue->atsll = TS24501IE_ATSSSModes_anyMode;

   pvalue->epts1 = 0;

   pvalue->mh6Pdu = 0;

   pvalue->rqos = 0;

   pvalue->m.octet4Present = 1;

   pvalue->octet4.spare = 12;

   pvalue->octet4.nonDefQosRule = 0;

   pvalue->m.sparePresent = 1;
   pvalue->spare.numocts = 6;
   pvalue->spare.data = (OSOCTET*) rtxMemAlloc (pctxt, 6);
   {
      static const OSOCTET testdata[] = {
      0x82, 0x78, 0x99, 0x38, 0xe9, 0xfa };
      OSCRTLSAFEMEMCPY ((void*)pvalue->spare.data, 6, testdata, 6);
   }
   return (pvalue);
}

TS24501IE_AlwaysOnPDUSessionInd*
    asn1Test_TS24501IE_AlwaysOnPDUSessionInd (OSCTXT* pctxt)
{
   TS24501IE_AlwaysOnPDUSessionInd* pvalue = rtxMemAllocType (pctxt, TS24501IE_AlwaysOnPDUSessionInd);
   asn1Init_TS24501IE_AlwaysOnPDUSessionInd (pvalue);

   pvalue->spare = 6;

   pvalue->apsi = 1;
   return (pvalue);
}

TS24501IE_AlwaysOnPDUSessionReq*
    asn1Test_TS24501IE_AlwaysOnPDUSessionReq (OSCTXT* pctxt)
{
   TS24501IE_AlwaysOnPDUSessionReq* pvalue = rtxMemAllocType (pctxt, TS24501IE_AlwaysOnPDUSessionReq);
   asn1Init_TS24501IE_AlwaysOnPDUSessionReq (pvalue);

   pvalue->spare = 1;

   pvalue->apsr = 0;
   return (pvalue);
}

TS24501IE_AllowedSSCMode* asn1Test_TS24501IE_AllowedSSCMode (OSCTXT* pctxt)
{
   TS24501IE_AllowedSSCMode* pvalue = rtxMemAllocType (pctxt, TS24501IE_AllowedSSCMode);
   asn1Init_TS24501IE_AllowedSSCMode (pvalue);

   pvalue->spare = 0;

   pvalue->ssc3 = 1;

   pvalue->ssc2 = 0;

   pvalue->ssc1 = 1;
   return (pvalue);
}

TS24501IE_IntegrityProtMaxDataRate*
    asn1Test_TS24501IE_IntegrityProtMaxDataRate (OSCTXT* pctxt)
{
   TS24501IE_IntegrityProtMaxDataRate* pvalue = rtxMemAllocType (pctxt, TS24501IE_IntegrityProtMaxDataRate);

   pvalue->maxUEDataRateUplink = 227;

   pvalue->maxUEDataRateDownlink = 139;
   return (pvalue);
}

TS24501IE_EPSParam* asn1Test_TS24501IE_EPSParam (OSCTXT* pctxt)
{
   TS24501IE_EPSParam* pvalue = rtxMemAllocType (pctxt, TS24501IE_EPSParam);
   asn1Init_TS24501IE_EPSParam (pvalue);

   pvalue->id = TS24501IE_EPSParamId_epsParamMax;

   switch (pvalue->id) {
      /* epsQoS */
      case 1:
         pvalue->content.u.epsQoS.length = 0; /* length will be calculated */

         pvalue->content.u.epsQoS.qci = 67;

         pvalue->content.u.epsQoS.m.bitRatesPresent = 1;
         /* zero elements */
         break;

      /* extEpsQos */
      case 2:
         pvalue->content.u.extEpsQos.length = 0; /* length will be calculated */

         pvalue->content.u.extEpsQos.maxBRUnit = 190;

         pvalue->content.u.extEpsQos.maxUplinkBR = 14732;

         pvalue->content.u.extEpsQos.maxDownlinkBR = 59068;

         pvalue->content.u.extEpsQos.guaranteedBRUnit = 244;

         pvalue->content.u.extEpsQos.guaranteedUplinkBR = 11308;

         pvalue->content.u.extEpsQos.guaranteedDownlinkBR = 24742;
         break;

      /* tft */
      case 3:
         pvalue->content.u.tft.length = 0; /* length will be calculated */

         pvalue->content.u.tft.octet1.tftOperationCode = TS24008IE_TFTOctet1_tftOperationCode_addPktFilters;

         pvalue->content.u.tft.octet1.eBit = 0;

         pvalue->content.u.tft.octet1.numPacketFilters = 5;

         switch (pvalue->content.u.tft.octet1.tftOperationCode) {
            /* identifiers */
            case 5:
               pvalue->content.u.tft.packetFilterList.u.identifiers.numocts = 1;
               pvalue->content.u.tft.packetFilterList.u.identifiers.data = (OSOCTET*) rtxMemAlloc (pctxt, 1);
               {
                  static const OSOCTET testdata[] = {
                  0xb1 };
                  OSCRTLSAFEMEMCPY ((void*)pvalue->content.u.tft.packetFilterList.u.identifiers.data, 1, testdata, 1);
               }
               break;

            /* filterItems */
            default:
               /* zero elements */
               break;

         }

         /* zero elements */
         break;

      /* apnAmbr */
      case 4:
         pvalue->content.u.apnAmbr.length = 0; /* length will be calculated */

         pvalue->content.u.apnAmbr.apnAmbrforDL = 212;

         pvalue->content.u.apnAmbr.apnAmbrforUL = 209;

         pvalue->content.u.apnAmbr.m.extPresent = 1;
         /* zero elements */
         break;

      /* extApnAmbr */
      case 5:
         pvalue->content.u.extApnAmbr.length = 0; /* length will be calculated */

         pvalue->content.u.extApnAmbr.extApnAmbrUnitForDL = 169;

         {
            static const OSOCTET testdata[] = {
            0x57, 0x4a };
            OSCRTLSAFEMEMCPY ((void*)pvalue->content.u.extApnAmbr.extApnAmbrForDL, 2, testdata, 2);
         }

         pvalue->content.u.extApnAmbr.extApnAmbrUnitForUL = 194;

         {
            static const OSOCTET testdata[] = {
            0x10, 0x35 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->content.u.extApnAmbr.extApnAmbrForUL, 2, testdata, 2);
         }
         break;

      /* unknown */
      default:
         pvalue->content.u.unknown.numocts = 15;
         pvalue->content.u.unknown.data = (OSOCTET*) rtxMemAlloc (pctxt, 15);
         {
            static const OSOCTET testdata[] = {
            0x31, 0x03, 0xfd, 0x42, 0x47, 0xcd, 0xfe, 0xab, 
            0xd8, 0x6e, 0x6e, 0x97, 0x34, 0x12, 0x0c };
            OSCRTLSAFEMEMCPY ((void*)pvalue->content.u.unknown.data, 15, testdata, 15);
         }
         break;

   }
   return (pvalue);
}

TS24501IE_EPSBearerCtxt* asn1Test_TS24501IE_EPSBearerCtxt (OSCTXT* pctxt)
{
   TS24501IE_EPSBearerCtxt* pvalue = rtxMemAllocType (pctxt, TS24501IE_EPSBearerCtxt);
   asn1Init_TS24501IE_EPSBearerCtxt (pvalue);

   pvalue->bearerId = 13;

   pvalue->bearerCtxtLen = 25015;

   pvalue->opCode = 1;

   pvalue->spare = 0;

   pvalue->eBit = 1;

   pvalue->numParams = 7;

   pvalue->m.paramsListPresent = 1;
   /* zero elements */
   return (pvalue);
}

TS24501IE_EPSBearerCtxts* asn1Test_TS24501IE_EPSBearerCtxts (OSCTXT* pctxt)
{
   TS24501IE_EPSBearerCtxts* pvalue = rtxMemAllocType (pctxt, TS24501IE_EPSBearerCtxts);
   asn1Init_TS24501IE_EPSBearerCtxts (pvalue);

   pvalue->length = 0; /* length will be calculated */

   /* zero elements */
   return (pvalue);
}

TS24501IE_MaxSupportedPacketFilters*
    asn1Test_TS24501IE_MaxSupportedPacketFilters (OSCTXT* pctxt)
{
   TS24501IE_MaxSupportedPacketFilters* pvalue = rtxMemAllocType (pctxt, TS24501IE_MaxSupportedPacketFilters);
   asn1Init_TS24501IE_MaxSupportedPacketFilters (pvalue);

   pvalue->maxFilters = 78;

   pvalue->spare = 28;
   return (pvalue);
}

TS24501IE_PDUAddress* asn1Test_TS24501IE_PDUAddress (OSCTXT* pctxt)
{
   TS24501IE_PDUAddress* pvalue = rtxMemAllocType (pctxt, TS24501IE_PDUAddress);
   asn1Init_TS24501IE_PDUAddress (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 10;

   pvalue->s16LLA = 0;

   pvalue->sessionType = TS24501IE_PDUAddressValues_pduAddrValMAX;

   switch (pvalue->sessionType) {
      /* addressInfoIpv4 */
      case 1:
         {
            static const OSOCTET testdata[] = {
            0x68, 0x0a, 0xa9, 0x78 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->addressInfo.u.addressInfoIpv4, 4, testdata, 4);
         }
         break;

      /* addressInfoIpv6 */
      case 2:
         {
            static const OSOCTET testdata[] = {
            0xbe, 0x68, 0x29, 0xc1, 0xe5, 0x6b, 0x89, 0xb3 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->addressInfo.u.addressInfoIpv6, 8, testdata, 8);
         }
         break;

      /* addressInfoIpv4v6 */
      case 3:

         {
            static const OSOCTET testdata[] = {
            0xe9, 0xb4, 0x8c, 0x59, 0x23, 0xa3, 0x0d, 0xb4 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->addressInfo.u.addressInfoIpv4v6.ipv6, 8, testdata, 8);
         }

         {
            static const OSOCTET testdata[] = {
            0xb0, 0x99, 0xce, 0x61 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->addressInfo.u.addressInfoIpv4v6.ipv4, 4, testdata, 4);
         }
         break;

      default: break;
   }

   switch (pvalue->s16LLA) {
      /* absent */
      case 0:
         break;

      /* present */
      case 1:
         {
            static const OSOCTET testdata[] = {
            0xa5, 0x0a, 0x4e, 0xe1, 0x9b, 0x0d, 0x48, 0x84 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->smfIp6Addr.u.present, 8, testdata, 8);
         }
         break;

      default: break;
   }
   return (pvalue);
}

TS24501IE_PDUSessionType* asn1Test_TS24501IE_PDUSessionType (OSCTXT* pctxt)
{
   TS24501IE_PDUSessionType* pvalue = rtxMemAllocType (pctxt, TS24501IE_PDUSessionType);
   asn1Init_TS24501IE_PDUSessionType (pvalue);

   pvalue->spare = 0;

   pvalue->sessionType = TS24501IE_SessionType_st_unstructured;
   return (pvalue);
}

TS24501IE_Parameter* asn1Test_TS24501IE_Parameter (OSCTXT* pctxt)
{
   TS24501IE_Parameter* pvalue = rtxMemAllocType (pctxt, TS24501IE_Parameter);
   asn1Init_TS24501IE_Parameter (pvalue);

   pvalue->id = TS24501IE_ParameterId_fiveQI;
   pvalue->length = 0; /* length will be calculated */

   switch (pvalue->id) {
      /* fiveQI */
      case 1:
         pvalue->content.u.fiveQI = 124;
         break;

      /* gfbrUL */
      case 2:

         pvalue->content.u.gfbrUL.unit = 85;

         pvalue->content.u.gfbrUL.guarFlow = 59633;
         break;

      /* gfbrDL */
      case 3:

         pvalue->content.u.gfbrDL.unit = 166;

         pvalue->content.u.gfbrDL.guarFlow = 48601;
         break;

      /* mfbrUL */
      case 4:

         pvalue->content.u.mfbrUL.unit = 64;

         pvalue->content.u.mfbrUL.guarFlow = 18888;
         break;

      /* mfbrDL */
      case 5:

         pvalue->content.u.mfbrDL.unit = 160;

         pvalue->content.u.mfbrDL.guarFlow = 38876;
         break;

      /* avgWindow */
      case 6:
         pvalue->content.u.avgWindow = 51124;
         break;

      /* epsBearerIdent */
      case 7:

         pvalue->content.u.epsBearerIdent.value = 10;

         pvalue->content.u.epsBearerIdent.spare = 8;
         break;

      /* unknown */
      default:
         pvalue->content.u.unknown.numocts = 1;
         pvalue->content.u.unknown.data = (OSOCTET*) rtxMemAlloc (pctxt, 1);
         {
            static const OSOCTET testdata[] = {
            0x78 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->content.u.unknown.data, 1, testdata, 1);
         }
         break;

   }
   return (pvalue);
}

TS24501IE_QOSFlowDescription*
    asn1Test_TS24501IE_QOSFlowDescription (OSCTXT* pctxt)
{
   TS24501IE_QOSFlowDescription* pvalue = rtxMemAllocType (pctxt, TS24501IE_QOSFlowDescription);
   asn1Init_TS24501IE_QOSFlowDescription (pvalue);

   pvalue->spare = 2;

   pvalue->qfi = 56;

   pvalue->opCode = TS24501IE_FlowOpCodes_flowDelete;

   pvalue->spare2 = 25;

   pvalue->spare3 = 0;

   pvalue->eBit = 0;

   pvalue->numParams = 3;

   pvalue->m.paramsListPresent = 1;
   /* zero elements */
   return (pvalue);
}

TS24501IE_QOSFlowDescriptions*
    asn1Test_TS24501IE_QOSFlowDescriptions (OSCTXT* pctxt)
{
   TS24501IE_QOSFlowDescriptions* pvalue = rtxMemAllocType (pctxt, TS24501IE_QOSFlowDescriptions);
   asn1Init_TS24501IE_QOSFlowDescriptions (pvalue);

   pvalue->length = 0; /* length will be calculated */

   /* zero elements */
   return (pvalue);
}

TS24501IE_PFComponent* asn1Test_TS24501IE_PFComponent (OSCTXT* pctxt)
{
   TS24501IE_PFComponent* pvalue = rtxMemAllocType (pctxt, TS24501IE_PFComponent);
   asn1Init_TS24501IE_PFComponent (pvalue);

   pvalue->typeId = TS24501IE_PacketFilterTypeId_ipv4Remote;

   switch (pvalue->typeId) {
      /* matchAll */
      case 1:
         break;

      /* ipv4Remote */
      case 16:
         {
            static const OSOCTET testdata[] = {
            0x86, 0x04, 0x83, 0xa1, 0x11, 0xcc, 0x26, 0xa8 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.ipv4Remote, 8, testdata, 8);
         }
         break;

      /* ipv4Local */
      case 17:
         {
            static const OSOCTET testdata[] = {
            0x3f, 0x23, 0x7d, 0x99, 0xc9, 0x94, 0x59, 0x5b };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.ipv4Local, 8, testdata, 8);
         }
         break;

      /* ipv6Remote */
      case 33:
         {
            static const OSOCTET testdata[] = {
            0x35, 0xcd, 0xd7, 0x8a, 0xce, 0xac, 0x82, 0x73, 
            0x10, 0xb0, 0x48, 0x0c, 0xab, 0xfd, 0x2e, 0x32, 
            0x02 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.ipv6Remote, 17, testdata, 17);
         }
         break;

      /* ipv6Local */
      case 35:
         {
            static const OSOCTET testdata[] = {
            0x31, 0x54, 0x92, 0x7d, 0xf9, 0x3b, 0x3c, 0x1d, 
            0x39, 0xd5, 0xe6, 0xcd, 0xaf, 0x43, 0x04, 0x7d, 
            0x9a };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.ipv6Local, 17, testdata, 17);
         }
         break;

      /* protId */
      case 48:
         {
            static const OSOCTET testdata[] = {
            0x0e };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.protId, 1, testdata, 1);
         }
         break;

      /* singleLocalPort */
      case 64:
         {
            static const OSOCTET testdata[] = {
            0xcb, 0x48 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.singleLocalPort, 2, testdata, 2);
         }
         break;

      /* localPortRange */
      case 65:
         {
            static const OSOCTET testdata[] = {
            0x91, 0x3f, 0xd7, 0xc1 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.localPortRange, 4, testdata, 4);
         }
         break;

      /* singleRemPort */
      case 80:
         {
            static const OSOCTET testdata[] = {
            0x07, 0xe3 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.singleRemPort, 2, testdata, 2);
         }
         break;

      /* remPortRange */
      case 81:
         {
            static const OSOCTET testdata[] = {
            0x6d, 0x84, 0x91, 0x20 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.remPortRange, 4, testdata, 4);
         }
         break;

      /* secParam */
      case 96:
         {
            static const OSOCTET testdata[] = {
            0x86, 0x42, 0x74, 0x1a };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.secParam, 4, testdata, 4);
         }
         break;

      /* typeOfSvc */
      case 112:
         {
            static const OSOCTET testdata[] = {
            0xc0, 0xed };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.typeOfSvc, 2, testdata, 2);
         }
         break;

      /* flowLabel */
      case 128:
         {
            static const OSOCTET testdata[] = {
            0xd4, 0xfc, 0x0c };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.flowLabel, 3, testdata, 3);
         }
         break;

      /* destMacAddr */
      case 129:
         {
            static const OSOCTET testdata[] = {
            0x0e, 0x53, 0x72, 0x5c, 0x03, 0x35 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.destMacAddr, 6, testdata, 6);
         }
         break;

      /* srcMacAddr */
      case 130:
         {
            static const OSOCTET testdata[] = {
            0x60, 0x00, 0xd0, 0x6e, 0xcc, 0x98 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.srcMacAddr, 6, testdata, 6);
         }
         break;

      /* ctagVid */
      case 131:
         {
            static const OSOCTET testdata[] = {
            0x7f, 0x8b };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.ctagVid, 2, testdata, 2);
         }
         break;

      /* stagVid */
      case 132:
         {
            static const OSOCTET testdata[] = {
            0x70, 0x41 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.stagVid, 2, testdata, 2);
         }
         break;

      /* ctagPcp */
      case 133:
         {
            static const OSOCTET testdata[] = {
            0x13 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.ctagPcp, 1, testdata, 1);
         }
         break;

      /* stagPcp */
      case 134:
         {
            static const OSOCTET testdata[] = {
            0xd3 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.stagPcp, 1, testdata, 1);
         }
         break;

      /* ethernet */
      case 135:
         {
            static const OSOCTET testdata[] = {
            0xaf, 0x97 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->value.u.ethernet, 2, testdata, 2);
         }
         break;

      default: break;
   }
   return (pvalue);
}

TS24501IE_PFCreateNew* asn1Test_TS24501IE_PFCreateNew (OSCTXT* pctxt)
{
   TS24501IE_PFCreateNew* pvalue = rtxMemAllocType (pctxt, TS24501IE_PFCreateNew);
   asn1Init_TS24501IE_PFCreateNew (pvalue);

   pvalue->spare = 0;

   pvalue->filterDirection = 1;

   pvalue->filterId = 1;
   pvalue->filterContentLen = 0; /* length will be calculated */

   /* zero elements */
   return (pvalue);
}

TS24501IE_PFModifyAndDelete*
    asn1Test_TS24501IE_PFModifyAndDelete (OSCTXT* pctxt)
{
   TS24501IE_PFModifyAndDelete* pvalue = rtxMemAllocType (pctxt, TS24501IE_PFModifyAndDelete);
   asn1Init_TS24501IE_PFModifyAndDelete (pvalue);

   pvalue->spare = 9;

   pvalue->filterId = 0;
   return (pvalue);
}

TS24501IE_QoSRule* asn1Test_TS24501IE_QoSRule (OSCTXT* pctxt)
{
   TS24501IE_QoSRule* pvalue = rtxMemAllocType (pctxt, TS24501IE_QoSRule);
   asn1Init_TS24501IE_QoSRule (pvalue);

   pvalue->ruleId = 184;

   pvalue->ruleLen = 8136;

   pvalue->ruleOpCode = TS24501IE_RuleOpCodes_createNew;

   pvalue->dqr = 1;

   pvalue->numPacketFilters = 11;

   switch (pvalue->ruleOpCode) {
      /* createNew */
      case 1:
         /* zero elements */
         break;

      /* delete */
      case 2:
         break;

      /* modifyAndAdd */
      case 3:
         pvalue->packetFilterList.u.modifyAndAdd.n = 1;

         pvalue->packetFilterList.u.modifyAndAdd.elem[0].spare = 1;

         pvalue->packetFilterList.u.modifyAndAdd.elem[0].filterDirection = 2;

         pvalue->packetFilterList.u.modifyAndAdd.elem[0].filterId = 4;
         pvalue->packetFilterList.u.modifyAndAdd.elem[0].filterContentLen = 0; /* length will be calculated */

         /* zero elements */

         break;

      /* modifyAndReplace */
      case 4:
         /* zero elements */
         break;

      /* modifyAndDelete */
      case 5:
         pvalue->packetFilterList.u.modifyAndDelete.n = 1;

         pvalue->packetFilterList.u.modifyAndDelete.elem[0].spare = 11;

         pvalue->packetFilterList.u.modifyAndDelete.elem[0].filterId = 7;

         break;

      /* modifyNoModify */
      case 6:
         break;

      default: break;
   }

   pvalue->precedence = 187;

   pvalue->spare1 = 0;

   pvalue->segregation = 0;

   pvalue->flowId = 7;
   return (pvalue);
}

TS24501IE_QoSRules* asn1Test_TS24501IE_QoSRules (OSCTXT* pctxt)
{
   TS24501IE_QoSRules* pvalue = rtxMemAllocType (pctxt, TS24501IE_QoSRules);
   asn1Init_TS24501IE_QoSRules (pvalue);

   pvalue->length = 0; /* length will be calculated */

   /* zero elements */
   return (pvalue);
}

TS24501IE_SessionAMBR* asn1Test_TS24501IE_SessionAMBR (OSCTXT* pctxt)
{
   TS24501IE_SessionAMBR* pvalue = rtxMemAllocType (pctxt, TS24501IE_SessionAMBR);
   asn1Init_TS24501IE_SessionAMBR (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->unitAmbrDL = 54;

   pvalue->sessionAmbrDL = 39340;

   pvalue->unitAmbrUL = 8;

   pvalue->sessionAmbrUL = 46616;
   return (pvalue);
}

TS24501IE_SmPduDnReqContainer*
    asn1Test_TS24501IE_SmPduDnReqContainer (OSCTXT* pctxt)
{
   TS24501IE_SmPduDnReqContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_SmPduDnReqContainer);
   asn1Init_TS24501IE_SmPduDnReqContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->m.dnSpecificIdPresent = 1;
   pvalue->dnSpecificId.numocts = 4;
   pvalue->dnSpecificId.data = (OSOCTET*) rtxMemAlloc (pctxt, 4);
   {
      static const OSOCTET testdata[] = {
      0x94, 0xbe, 0x87, 0xa7 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->dnSpecificId.data, 4, testdata, 4);
   }
   return (pvalue);
}

TS24501IE_SSCMode* asn1Test_TS24501IE_SSCMode (OSCTXT* pctxt)
{
   TS24501IE_SSCMode* pvalue = rtxMemAllocType (pctxt, TS24501IE_SSCMode);
   asn1Init_TS24501IE_SSCMode (pvalue);

   pvalue->spare = 0;

   pvalue->sscMode = TS24501IE_SSCModeValue_ssc_mode1;
   return (pvalue);
}

TS24501IE_ReattemptIndicator*
    asn1Test_TS24501IE_ReattemptIndicator (OSCTXT* pctxt)
{
   TS24501IE_ReattemptIndicator* pvalue = rtxMemAllocType (pctxt, TS24501IE_ReattemptIndicator);
   asn1Init_TS24501IE_ReattemptIndicator (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 61;

   pvalue->eplmnc = 1;

   pvalue->ratc = 1;
   return (pvalue);
}

TS24501IE_SMNetworkFeatureSupport*
    asn1Test_TS24501IE_SMNetworkFeatureSupport (OSCTXT* pctxt)
{
   TS24501IE_SMNetworkFeatureSupport* pvalue = rtxMemAllocType (pctxt, TS24501IE_SMNetworkFeatureSupport);
   asn1Init_TS24501IE_SMNetworkFeatureSupport (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 74;

   pvalue->eptS1 = 1;

   pvalue->m.spare2Present = 1;
   pvalue->spare2.numocts = 4;
   pvalue->spare2.data = (OSOCTET*) rtxMemAlloc (pctxt, 4);
   {
      static const OSOCTET testdata[] = {
      0xc9, 0x16, 0x06, 0xfb };
      OSCRTLSAFEMEMCPY ((void*)pvalue->spare2.data, 4, testdata, 4);
   }
   return (pvalue);
}

TS24501IE_CongestionReattemptIndicator*
    asn1Test_TS24501IE_CongestionReattemptIndicator (OSCTXT* pctxt)
{
   TS24501IE_CongestionReattemptIndicator* pvalue = rtxMemAllocType (pctxt, TS24501IE_CongestionReattemptIndicator);
   asn1Init_TS24501IE_CongestionReattemptIndicator (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 113;

   pvalue->abo = 1;
   return (pvalue);
}

TS24501IE_ATSSSContainer* asn1Test_TS24501IE_ATSSSContainer (OSCTXT* pctxt)
{
   TS24501IE_ATSSSContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_ATSSSContainer);
   asn1Init_TS24501IE_ATSSSContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->m.contentsPresent = 1;
   pvalue->contents.numocts = 15;
   pvalue->contents.data = (OSOCTET*) rtxMemAlloc (pctxt, 15);
   {
      static const OSOCTET testdata[] = {
      0xbf, 0x24, 0x69, 0x37, 0xdf, 0xcf, 0x0f, 0x1c, 
      0x85, 0xd4, 0x24, 0x55, 0x9b, 0xb8, 0x93 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.data, 15, testdata, 15);
   }
   return (pvalue);
}

TS24501IE_ControlPlaneIndication*
    asn1Test_TS24501IE_ControlPlaneIndication (OSCTXT* pctxt)
{
   TS24501IE_ControlPlaneIndication* pvalue = rtxMemAllocType (pctxt, TS24501IE_ControlPlaneIndication);
   asn1Init_TS24501IE_ControlPlaneIndication (pvalue);

   pvalue->spare = 0;

   pvalue->cpoi = 0;
   return (pvalue);
}

TS24501IE_HeaderCompressionConfig*
    asn1Test_TS24501IE_HeaderCompressionConfig (OSCTXT* pctxt)
{
   TS24501IE_HeaderCompressionConfig* pvalue = rtxMemAllocType (pctxt, TS24501IE_HeaderCompressionConfig);
   asn1Init_TS24501IE_HeaderCompressionConfig (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 0;

   pvalue->p0x0104 = 0;

   pvalue->p0x0103 = 0;

   pvalue->p0x0102 = 0;

   pvalue->p0x0006 = 1;

   pvalue->p0x0004 = 0;

   pvalue->p0x0003 = 1;

   pvalue->p0x0002 = 0;

   {
      static const OSOCTET testdata[] = {
      0x2b, 0x94 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->maxCID, 2, testdata, 2);
   }

   pvalue->m.addlCompressParamsTypePresent = 1;
   pvalue->addlCompressParamsType = 66;

   pvalue->m.addlCompressParamsContainerPresent = 1;
   pvalue->addlCompressParamsContainer.numocts = 12;
   pvalue->addlCompressParamsContainer.data = (OSOCTET*) rtxMemAlloc (pctxt, 12);
   {
      static const OSOCTET testdata[] = {
      0x38, 0xad, 0x60, 0x77, 0xd2, 0x49, 0xae, 0x32, 
      0x98, 0xbd, 0x4e, 0x1f };
      OSCRTLSAFEMEMCPY ((void*)pvalue->addlCompressParamsContainer.data, 12, testdata, 12);
   }
   return (pvalue);
}

TS24501IE_DSTTEthMACAddr* asn1Test_TS24501IE_DSTTEthMACAddr (OSCTXT* pctxt)
{
   TS24501IE_DSTTEthMACAddr* pvalue = rtxMemAllocType (pctxt, TS24501IE_DSTTEthMACAddr);

   pvalue->length = 0; /* length will be calculated */

   {
      static const OSOCTET testdata[] = {
      0x12, 0xf2, 0x74, 0x2e, 0x2b, 0x87 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents, 6, testdata, 6);
   }
   return (pvalue);
}

TS24501IE_DSTTResidenceTime*
    asn1Test_TS24501IE_DSTTResidenceTime (OSCTXT* pctxt)
{
   TS24501IE_DSTTResidenceTime* pvalue = rtxMemAllocType (pctxt, TS24501IE_DSTTResidenceTime);

   pvalue->length = 0; /* length will be calculated */

   {
      static const OSOCTET testdata[] = {
      0xd1, 0x0c, 0xad, 0x2c, 0xab, 0x4b, 0x0e, 0x29 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents, 8, testdata, 8);
   }
   return (pvalue);
}

TS24501IE_PortMgmtInfoContainer*
    asn1Test_TS24501IE_PortMgmtInfoContainer (OSCTXT* pctxt)
{
   TS24501IE_PortMgmtInfoContainer* pvalue = rtxMemAllocType (pctxt, TS24501IE_PortMgmtInfoContainer);
   asn1Init_TS24501IE_PortMgmtInfoContainer (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->container.numocts = 1;
   pvalue->container.data = (OSOCTET*) rtxMemAlloc (pctxt, 1);
   {
      static const OSOCTET testdata[] = {
      0x86 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->container.data, 1, testdata, 1);
   }
   return (pvalue);
}

TS24501IE_EthHdrCompressConfig*
    asn1Test_TS24501IE_EthHdrCompressConfig (OSCTXT* pctxt)
{
   TS24501IE_EthHdrCompressConfig* pvalue = rtxMemAllocType (pctxt, TS24501IE_EthHdrCompressConfig);
   asn1Init_TS24501IE_EthHdrCompressConfig (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 56;

   pvalue->cidLength = 1;
   return (pvalue);
}

