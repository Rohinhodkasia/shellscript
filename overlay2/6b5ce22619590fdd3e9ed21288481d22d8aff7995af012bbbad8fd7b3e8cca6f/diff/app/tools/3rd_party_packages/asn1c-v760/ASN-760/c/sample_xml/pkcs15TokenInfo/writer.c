/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0A, Date: 22-Jun-2006.
 */
#include "PKCS15TokenInfo.h"
#include "rtxsrc/rtxCommon.h"

#include <stdio.h>
#include <stdlib.h>

int main (int argc, char** argv)
{
   TokenInfo    tokenInfo;
   OSCTXT       ctxt, ctxt2;
   OSBOOL       trace = TRUE, verbose = FALSE;
   OSXMLNamespace asn1NS;
   const char*  filename = "message.xml";
   int          i, stat;

   OSOCTET msgbuf1[100];
   OSOCTET msgbuf2[400];
   OSOCTET param2[] = { 0, 0, 0, 0, 0, 0, 0, 0 };

   OSOCTET serialNumber[] = {
      0x15, 0x97, 0x52, 0x22, 0x25, 0x15, 0x40, 0x12, 0x40
   } ;

   SecurityEnvironmentInfo seRec;

   ASN1OBJID algId [4] = {
      { 6, { 1, 3, 14, 3, 2, 26 } },
      { 8, { 1, 3, 36, 3, 4, 3, 2, 1 } },
      { 3, { 1, 0, 0 } },
      { 6, { 1, 2, 840, 113549, 3, 7 } }
   };

   AlgorithmInfo algorithmInfo[4];
   
   /* Process command line arguments */
   if (argc > 1) {
      for (i = 1; i < argc; i++) {
         if (!strcmp (argv[i], "-v")) verbose = TRUE;
         else if (!strcmp (argv[i], "-o")) filename = argv[++i];
         else if (!strcmp (argv[i], "-notrace")) trace = FALSE;
         else {
            printf ("usage: writer [ -v ] [ -o <filename>] [ -cxer ]\n");
            printf ("   -v  verbose mode: print trace info\n");
            printf ("   -o <filename>  write encoded msg to <filename>\n");
            printf ("   -notrace  do not display trace info\n");
            return 0;
         }
      }
   }

   /* Init context */

   stat = rtXmlInitContext (&ctxt);
   if (stat != 0) {
      rtxErrPrint (&ctxt);
      return stat;
   }
   rtxSetDiag (&ctxt, verbose);

   // Encode open type parameters

   strcpy ((char*)msgbuf1, "<NULL/>");

   if (rtXmlInitContext (&ctxt2) != 0) {
      rtxErrPrint (&ctxt2);
      return -1;
   }

   rtxSetDiag (&ctxt2, verbose);

   asn1NS.prefix = OSUTF8("asn1");
   asn1NS.uri = 0;
   rtXmlSetEncBufPtr (&ctxt2, msgbuf2, sizeof(msgbuf2));
   rtXmlEncHexBinary 
      (&ctxt2, sizeof(param2), param2, OSUTF8("OctetString"), &asn1NS);
   OSRTZTERM(&ctxt2);

   // Populate tokenInfo

   memset (&tokenInfo, 0, sizeof (tokenInfo));

   tokenInfo.version = v1;
   tokenInfo.serialNumber.numocts = sizeof (serialNumber);
   tokenInfo.serialNumber.data = serialNumber;
   tokenInfo.m.manufacturerIDPresent = TRUE;
   tokenInfo.manufacturerID = OSUTF8("XY, Inc.");
   tokenInfo.m.labelPresent = TRUE;
   tokenInfo.label = OSUTF8("Digital signature card");
   
   tokenInfo.tokenflags.numbits = 3;
   rtxSetBit (tokenInfo.tokenflags.data, tokenInfo.tokenflags.numbits,
      TokenFlags_prnGeneration);

   // Populate Security Environment Info 

   tokenInfo.m.seInfoPresent = TRUE;

   rtxDListInit (&tokenInfo.seInfo);

   asn1Init_SecurityEnvironmentInfo (&seRec);
   seRec.se = 1;
   seRec.owner.numids = 3;
   seRec.owner.subid[0] = 1;
   seRec.owner.subid[1] = 0;
   seRec.owner.subid[2] = 0;

   rtxDListAppend (&ctxt, &tokenInfo.seInfo, &seRec);

   // Populate supported Algorithms array

   tokenInfo.m.supportedAlgorithmsPresent = TRUE;

   memset (&algorithmInfo, 0, sizeof (algorithmInfo));
   rtxDListInit (&tokenInfo.supportedAlgorithms);
   
   algorithmInfo[0].reference = 1;
   algorithmInfo[0].algorithm = 1;
   algorithmInfo[0].parameters.numocts = rtxUTF8LenBytes (msgbuf1);
   algorithmInfo[0].parameters.data = msgbuf1;
   algorithmInfo[0].supportedOperations.numbits = 7;
      
   rtxSetBit (algorithmInfo[0].supportedOperations.data,
      algorithmInfo[0].supportedOperations.numbits,
      Operations_hash);

   algorithmInfo[0].m.algIdPresent = TRUE;
   algorithmInfo[0].algId = algId[0];

   rtxDListAppend (&ctxt, &tokenInfo.supportedAlgorithms, &algorithmInfo[0]);

   algorithmInfo[1].reference = 2;
   algorithmInfo[1].algorithm = 2;
   algorithmInfo[1].parameters.numocts = rtxUTF8LenBytes (msgbuf1);
   algorithmInfo[1].parameters.data = msgbuf1;
   algorithmInfo[1].supportedOperations.numbits = 2;
      
   rtxSetBit (algorithmInfo[1].supportedOperations.data,
      algorithmInfo[1].supportedOperations.numbits,
      Operations_compute_signature);

   algorithmInfo[1].m.algIdPresent = TRUE;
   algorithmInfo[1].algId = algId[1];

   rtxDListAppend (&ctxt, &tokenInfo.supportedAlgorithms, &algorithmInfo[1]);

   algorithmInfo[2].reference = 3;
   algorithmInfo[2].algorithm = 3;
   algorithmInfo[2].parameters.numocts = rtxUTF8LenBytes (msgbuf1);
   algorithmInfo[2].parameters.data = msgbuf1;
   algorithmInfo[2].supportedOperations.numbits = 3;
      
   rtxSetBit (algorithmInfo[2].supportedOperations.data,
      algorithmInfo[2].supportedOperations.numbits,
      Operations_compute_checksum);

   rtxSetBit (algorithmInfo[2].supportedOperations.data,
      algorithmInfo[2].supportedOperations.numbits,
      Operations_verify_checksum);

   algorithmInfo[2].m.algIdPresent = TRUE;
   algorithmInfo[2].algId = algId[2];

   rtxDListAppend (&ctxt, &tokenInfo.supportedAlgorithms, &algorithmInfo[2]);

   algorithmInfo[3].reference = 4;
   algorithmInfo[3].algorithm = 4;
   algorithmInfo[3].parameters.numocts = rtxUTF8LenBytes (msgbuf2);
   algorithmInfo[3].parameters.data = msgbuf2;
   algorithmInfo[3].supportedOperations.numbits = 6;
      
   rtxSetBit (algorithmInfo[3].supportedOperations.data,
      algorithmInfo[3].supportedOperations.numbits,
      Operations_decipher);

   rtxSetBit (algorithmInfo[3].supportedOperations.data,
      algorithmInfo[3].supportedOperations.numbits,
      Operations_encipher);

   algorithmInfo[3].m.algIdPresent = TRUE;
   algorithmInfo[3].algId = algId[3];

   rtxDListAppend (&ctxt, &tokenInfo.supportedAlgorithms, &algorithmInfo[3]);

   tokenInfo.m.issuerIdPresent = TRUE;
   tokenInfo.issuerId = OSUTF8("wxy");
   tokenInfo.m.holderIdPresent = TRUE;
   tokenInfo.holderId = OSUTF8("vwx");

   /* Encode */

   stat = rtXmlSetEncBufPtr (&ctxt, 0, 0);

   if (stat == 0)
      stat = XmlEnc_TokenInfo_PDU (&ctxt, &tokenInfo);

   if (stat == 0) {
      if (trace) {
         printf ("encoded XML message:\n");
         puts ((char*)rtXmlGetEncBufPtr(&ctxt));
         printf ("\n");
      }
   }
   else {
      printf ("Encoding failed\n");
      rtxErrPrint (&ctxt);
      return (stat);
   }

   /* Write the encoded message out to the output file */

   stat = rtXmlWriteToFile (&ctxt, filename);
   if (0 != stat) {
      printf ("Error opening %s for write access\n", filename);
      rtxErrPrint (&ctxt);
   }
   rtxFreeContext (&ctxt);

   return 0;
}
