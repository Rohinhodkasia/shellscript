/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0A, Date: 20-Jun-2006.
 */
#include "Test.h"
#include "rtxsrc/rtxCommon.h"

#include <stdio.h>
#include <stdlib.h>

static void fill_Name (Name* pName, char* fn, char* mi, char* ln);
static void fill_jSmith (OSCTXT* pctxt, TestType* pPR);

int main (int argc, char** argv)
{
   TestType     testData;
   OSCTXT       ctxt;
   OSBOOL       trace = TRUE, verbose = FALSE;
   const char*  filename = "message.xml";
   int          i, lseq[1024], stat;
   OSUINT32     melem[] = { married, single, divorced, children };
   OSREAL       relem[] = { 1.0, 3.14159, 2e-2, 3, 4, 5, 6, 0};
   OSBOOL       belem[] = { 0,1,1,0,1};
   OSOCTET      bs[10], *pdata;
   ChoiceType   choices[3];
   Name         name;
   TestType_iseqof_element ielem[] = { 0,1,2,3,4 };

   /* Process command line arguments */
   if (argc > 1) {
      for (i = 1; i < argc; i++) {
         if (!strcmp (argv[i], "-v")) verbose = TRUE;
         else if (!strcmp (argv[i], "-o")) filename = argv[++i];
         else if (!strcmp (argv[i], "-notrace")) trace = FALSE;
         else {
            printf ("usage: writer [ -v ] [ -o <filename>] [ -cxer ]\n");
            printf ("   -v  verbose mode: print trace info\n");
            printf ("   -o <filename>  write encoded msg to <filename>\n");
            printf ("   -notrace  do not display trace info\n");
            return 0;
         }
      }
   }

   /* Init context */

   stat = rtXmlInitContext (&ctxt);
   if (stat != 0) {
      rtxErrPrint (&ctxt);
      return stat;
   }
   rtxSetDiag (&ctxt, verbose);

   /* Populate structure of generated type */
   
   asn1Init_TestType (&testData);

   testData.utc = "030922190538-0400";
   testData.utc1 = "040229190538Z";
   testData.gtc = "20030922190538.3141+0430";
   testData.gtc1 = "20040229190538.3141Z";

   testData.real = 3.14159;
   testData.m.boolean_Present = 1;
   testData.boolean_ = 1;
   testData.nan = rtxGetNaN();
   testData.enum_ = yes;
   testData.iseqof2.n = 5;
   testData.iseqof2.elem[0] = 1;
   testData.iseqof2.elem[1] = 2;
   testData.iseqof2.elem[2] = 3;
   testData.iseqof2.elem[3] = 4;
   testData.iseqof2.elem[4] = 5;

   testData.seqofEnum.n = 4;
   testData.seqofEnum.elem = melem;

   testData.iseqof.n = 5;
   testData.iseqof.elem = ielem;

   relem[3] = rtxGetMinusZero();
   relem[4] = rtxGetMinusInfinity();
   relem[5] = rtxGetNaN();
   relem[6] = rtxGetPlusInfinity();
   testData.rseqof.n = 8;
   testData.rseqof.elem = relem;

   testData.bseqof.n = 5;
   testData.bseqof.elem = belem;

   testData.m.bs3Present = 1;
   testData.bs3.numbits = 7;
   testData.bs3.data[0] = 0;
   rtxSetBit (testData.bs3.data, testData.bs3.numbits, BS3_zero);
   rtxSetBit (testData.bs3.data, testData.bs3.numbits, BS3_a);
   rtxSetBit (testData.bs3.data, testData.bs3.numbits, BS3_b);
   rtxSetBit (testData.bs3.data, testData.bs3.numbits, BS3_c);

   testData.bs1.numbits = 8;
   testData.bs1.data[0] = 0;
   rtxSetBit (testData.bs1.data, testData.bs1.numbits, TestType_bs1_zero_1);
   rtxSetBit (testData.bs1.data, testData.bs1.numbits, TestType_bs1_a_1);
   rtxSetBit (testData.bs1.data, testData.bs1.numbits, TestType_bs1_b_1);
   rtxSetBit (testData.bs1.data, testData.bs1.numbits, TestType_bs1_c_1);

   testData.bs0.numbits = 10*8 - 2;
   testData.bs0.data = bs;
   for (i = 0; i < sizeof (bs); i++)
      bs[i] = (OSOCTET) (0xAA* (i + 1));

   testData.bs2.numbits = 0;
   testData.bs2.data = 0;

   { ASN1DynBitStr* pbitstr;
   rtxDListInit (&testData.bsseqof1);
   for (i = 0; i < 4; i++) {
      int j;
      pbitstr = rtxMemAllocType (&ctxt, ASN1DynBitStr);
      pbitstr->numbits = 5*8 - 1;
      pdata = (OSOCTET*) rtxMemAlloc (&ctxt, 5);
      for (j = 0; j < 5; j++) {
         pdata[j] = (OSOCTET) ((i + 1)* (j + 1) * 0xCC);
      }
      pbitstr->data = pdata;
      rtxDListAppend (&ctxt, &testData.bsseqof1, (void*)pbitstr);
   }}

   { TestType_bsseqof2_element* pbitstr;
   testData.m.bsseqof2Present = 1;
   rtxDListInit (&testData.bsseqof2);
   for (i = 0; i < 4; i++) {
      int j;
      pbitstr = rtxMemAllocType (&ctxt, TestType_bsseqof2_element);
      pbitstr->numbits = 7;
      for (j = 0; j < 1; j++) {
         pbitstr->data[j] = (OSOCTET) ((i + 1)* (j + 1) * 0xCC);
      }
      rtxDListAppend (&ctxt, &testData.bsseqof2, (void*)pbitstr);
   }}

   { ASN1DynOctStr* poctstr;
   testData.m.osseqof1Present = 1;
   rtxDListInit (&testData.osseqof1);
   for (i = 0; i < 4; i++) {
      int j;
      poctstr = rtxMemAllocType (&ctxt, ASN1DynOctStr);
      poctstr->numocts = 5;
      pdata = (OSOCTET*) rtxMemAlloc (&ctxt, 5);
      for (j = 0; j < 5; j++) {
         pdata[j] = (OSOCTET) ((i + 1)* (j + 1) * 0xCC);
      }
      poctstr->data = pdata;
      rtxDListAppend (&ctxt, &testData.osseqof1, (void*)poctstr);
   }}

   { static const char* str[] = { "Objective", "Systems", "Inc." };
   rtxDListInit (&testData.csseqof1);
   for (i = 0; i < 3; i++) {
      rtxDListAppend (&ctxt, &testData.csseqof1, (void*)str[i]);
   }}

   testData.val1 = 21;
   testData.val2 = value2;

   testData.m.nullvalPresent = 1;

   for (i = 0; i < 20; i++)
      lseq[i] = i;
   testData.iseqof1.n = 20;
   testData.iseqof1.elem = lseq;

   rtxDListInit (&testData.seqofChoice);

   choices[0].t = T_ChoiceType_e1;
   choices[0].u.e1 = 1;
   rtxDListAppend (&ctxt, &testData.seqofChoice, &choices[0]);

   choices[1].t = T_ChoiceType_e2;
   choices[1].u.e2 = "String data";
   rtxDListAppend (&ctxt, &testData.seqofChoice, &choices[1]);

   choices[2].t = T_ChoiceType_e3;
   fill_Name (&name, "Art", "S", "Bolgar");
   choices[2].u.e3 = &name;
   rtxDListAppend (&ctxt, &testData.seqofChoice, &choices[2]);

   fill_jSmith (&ctxt, &testData);

   /* Encode */

   stat = rtXmlSetEncBufPtr (&ctxt, 0, 0);

   if (stat == 0)
      stat = XmlEnc_TestType_PDU (&ctxt, &testData);

   if (stat == 0) {
      if (trace) {
         printf ("encoded XML message:\n");
         puts ((char*)rtXmlGetEncBufPtr(&ctxt));
         printf ("\n");
      }
   }
   else {
      printf ("Encoding failed\n");
      rtxErrPrint (&ctxt);
      return (stat);
   }

   /* Write the encoded message out to the output file */

   stat = rtXmlWriteToFile (&ctxt, filename);
   if (0 != stat) {
      printf ("Error opening %s for write access\n", filename);
      rtxErrPrint (&ctxt);
   }
   rtxFreeContext (&ctxt);

   return 0;
}

/* Routine to fill the testData record with test data */

static void fill_jSmith (OSCTXT* pctxt, TestType* pPR)
{
   ChildInformation* pChildInfo;

   fill_Name (&pPR->name, "John", "P", "Smith");

   rtxDListInit (&pPR->children);

   /* fill first child record */

   pChildInfo = rtxMemAllocType (pctxt, ChildInformation);
   fill_Name (&pChildInfo->name, "Ralph", "T", "Smith");
   pChildInfo->dateOfBirth = "19571111";
   rtxDListAppend (pctxt, &pPR->children, pChildInfo);

   /* fill second child record */

   pChildInfo = rtxMemAllocType (pctxt, ChildInformation);
   fill_Name (&pChildInfo->name, "Susan", "B", "Jones");
   pChildInfo->dateOfBirth = "19590717";
   rtxDListAppend (pctxt, &pPR->children, pChildInfo);
}

/* Routine to fill a name structure */

static void fill_Name (Name* pName, char* fn, char* mi, char* ln)
{
   pName->givenName = fn;
   pName->initial = mi;
   pName->familyName = ln;
}
