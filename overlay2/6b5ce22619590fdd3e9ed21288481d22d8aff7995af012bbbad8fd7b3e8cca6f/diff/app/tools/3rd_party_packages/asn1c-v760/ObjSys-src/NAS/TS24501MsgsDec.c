/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.6.0, Date: 15-Feb-2022.
 */
#include "TS24501Msgs.h"
#include "rtxsrc/rtxCommon.h"
#include "rtxsrc/rtxBitDecode.h"
#include "rtxsrc/rtxIntDecode.h"
#include "rt3gppsrc/rtx3GPP.h"
#include "rt3gppsrc/rt3gppNasSec.h"
#include "rtxsrc/rtxDiagBitTrace.h"

EXTERN int NASDec_TS24501Msg_NAS5GProtoDiscr (OSCTXT* pctxt
   , TS24501Msg_NAS5GProtoDiscr* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS5GProtoDiscr");

   /* Decode ENUMERATED value */
   RTDIAG_NEWBITFIELD (pctxt, "ENUMERATED");

   {
      OSUINT8 tmpval;
      ret = rtxDecBitsToByte (pctxt, &tmpval, 8);
      if (ret < 0) return LOG_RTERR (pctxt, ret);
      *pvalue = tmpval;
   }

   RTDIAG_SETBITFLDCOUNT (pctxt);
   switch (*pvalue) {
      case TS24501Msg_NAS5GProtoDiscr_sessMgmt5G:
      case TS24501Msg_NAS5GProtoDiscr_mobMgmt5G:
      case TS24501Msg_NAS5GProtoDiscr_maxProtoDiscr:
         break;

      default:
         rtxErrAddUIntParm (pctxt, *pvalue);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_NAS5GSecHdrType (OSCTXT* pctxt
   , TS24501Msg_NAS5GSecHdrType* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS5GSecHdrType");

   /* Decode ENUMERATED value */
   RTDIAG_NEWBITFIELD (pctxt, "ENUMERATED");

   {
      OSUINT8 tmpval;
      ret = rtxDecBitsToByte (pctxt, &tmpval, 4);
      if (ret < 0) return LOG_RTERR (pctxt, ret);
      *pvalue = tmpval;
   }

   RTDIAG_SETBITFLDCOUNT (pctxt);
   switch (*pvalue) {
      case TS24501Msg_NAS5GSecHdrType_noSec:
      case TS24501Msg_NAS5GSecHdrType_integProt:
      case TS24501Msg_NAS5GSecHdrType_integProtAndCipher:
      case TS24501Msg_NAS5GSecHdrType_integProtAnd5GSecCtxt:
      case TS24501Msg_NAS5GSecHdrType_integProtAndCipherAnd5GSecCtxt:
      case TS24501Msg_NAS5GSecHdrType_secMax:
         break;

      default:
         rtxErrAddUIntParm (pctxt, *pvalue);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_PDUSessionIdentity (OSCTXT* pctxt
   , TS24501Msg_PDUSessionIdentity* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionIdentity");

   /* Decode ENUMERATED value */
   RTDIAG_NEWBITFIELD (pctxt, "ENUMERATED");

   {
      OSUINT8 tmpval;
      ret = rtxDecBitsToByte (pctxt, &tmpval, 8);
      if (ret < 0) return LOG_RTERR (pctxt, ret);
      *pvalue = tmpval;
   }

   RTDIAG_SETBITFLDCOUNT (pctxt);
   switch (*pvalue) {
      case TS24501Msg_PDUSessionIdentity_noPduId:
      case TS24501Msg_PDUSessionIdentity_pduId1:
      case TS24501Msg_PDUSessionIdentity_pduId2:
      case TS24501Msg_PDUSessionIdentity_pduId3:
      case TS24501Msg_PDUSessionIdentity_pduId4:
      case TS24501Msg_PDUSessionIdentity_pduId5:
      case TS24501Msg_PDUSessionIdentity_pduId6:
      case TS24501Msg_PDUSessionIdentity_pduId7:
      case TS24501Msg_PDUSessionIdentity_pduId8:
      case TS24501Msg_PDUSessionIdentity_pduId9:
      case TS24501Msg_PDUSessionIdentity_pduId10:
      case TS24501Msg_PDUSessionIdentity_pduId11:
      case TS24501Msg_PDUSessionIdentity_pduId12:
      case TS24501Msg_PDUSessionIdentity_pduId13:
      case TS24501Msg_PDUSessionIdentity_pduId14:
      case TS24501Msg_PDUSessionIdentity_pduId15:
      case TS24501Msg_PDUSessionIdentity_pduIdMax:
         break;

      default:
         rtxErrAddUIntParm (pctxt, *pvalue);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_NAS5GSecProtMsgHdr (OSCTXT* pctxt
   , TS24501Msg_NAS5GSecProtMsgHdr* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS5GSecProtMsgHdr");

   /* decode protoDiscr */

   RTXCTXTPUSHELEMNAME (pctxt, "protoDiscr");

   ret = NASDec_TS24501Msg_NAS5GProtoDiscr (pctxt, &pvalue->protoDiscr);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spare1 */

   RTXCTXTPUSHELEMNAME (pctxt, "spare1");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare1, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode secHdrType */

   RTXCTXTPUSHELEMNAME (pctxt, "secHdrType");

   ret = NASDec_TS24501Msg_NAS5GSecHdrType (pctxt, &pvalue->secHdrType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode msgAuthCode */

   RTXCTXTPUSHELEMNAME (pctxt, "msgAuthCode");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecUInt32 (pctxt, &pvalue->msgAuthCode, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode seqNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "seqNumber");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->seqNumber, 8);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_AuthRequest (OSCTXT* pctxt
   , TS24501Msg_AuthRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nasKeySetIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdent");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->nasKeySetIdent
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode abba */

   RTXCTXTPUSHELEMNAME (pctxt, "abba");

   ret = NASDec_TS24501IE_ABBA (pctxt, &pvalue->abba);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 33: {
               if (lastRow == 0) {
                  /* decode authParamRAND */
                  RTXCTXTPUSHELEMNAME (pctxt, "authParamRAND");

                  ret = NASDec_TS24008IE_AuthParamRAND (pctxt, &pvalue->
                     authParamRAND);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authParamRANDPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 16;
               }
               break;
            }
            case 32: {
               if (lastRow <= 1) {
                  /* decode authParamAUTN */
                  RTXCTXTPUSHELEMNAME (pctxt, "authParamAUTN");

                  ret = NASDec_TS24008IE_AuthParamAUTN (pctxt, &pvalue->
                     authParamAUTN);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authParamAUTNPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 120: {
               if (lastRow <= 2) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_AuthResponse (OSCTXT* pctxt
   , TS24501Msg_AuthResponse* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthResponse");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 45: {
               if (lastRow == 0) {
                  /* decode authRespParam */
                  RTXCTXTPUSHELEMNAME (pctxt, "authRespParam");

                  ret = NASDec_TS24301IE_AuthRespParam (pctxt, &pvalue->
                     authRespParam);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authRespParamPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 120: {
               if (lastRow <= 1) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_AuthResult (OSCTXT* pctxt
   , TS24501Msg_AuthResult* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthResult");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nasKeySetIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdent");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->nasKeySetIdent
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eapMessage */

   RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

   ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 56: {
               if (lastRow == 0) {
                  /* decode abba */
                  RTXCTXTPUSHELEMNAME (pctxt, "abba");

                  ret = NASDec_TS24501IE_ABBA (pctxt, &pvalue->abba);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.abbaPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_AuthFailure (OSCTXT* pctxt
   , TS24501Msg_AuthFailure* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthFailure");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_MMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 48: {
               if (lastRow == 0) {
                  /* decode authFailureParam */
                  RTXCTXTPUSHELEMNAME (pctxt, "authFailureParam");

                  ret = NASDec_TS24008IE_AuthFailureParam (pctxt, &pvalue->
                     authFailureParam);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authFailureParamPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_AuthReject (OSCTXT* pctxt
   , TS24501Msg_AuthReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 120: {
               if (lastRow == 0) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_RegRequest (OSCTXT* pctxt
   , TS24501Msg_RegRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RegRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode nasKeySetIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdent");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->nasKeySetIdent
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode registrationType */

   RTXCTXTPUSHELEMNAME (pctxt, "registrationType");

   ret = NASDec_TS24501IE_RegistrationType (pctxt, &pvalue->registrationType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileId */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileId");

   ret = NASDec_TS24501IE_MobileIdentity (pctxt, &pvalue->mobileId);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 12 || nibble == 11 || nibble == 8 || nibble == 9 || nibble == 10) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 12: {
               if (lastRow == 0) {
                  /* decode nativeNasKeySetIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "nativeNasKeySetIdent");

                  ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->
                     nativeNasKeySetIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.nativeNasKeySetIdentPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 16: {
               if (lastRow <= 1) {
                  /* decode capability */
                  RTXCTXTPUSHELEMNAME (pctxt, "capability");

                  ret = NASDec_TS24501IE_MMCapability (pctxt, &pvalue->
                     capability);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.capabilityPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 46: {
               if (lastRow <= 2) {
                  /* decode securityCapability */
                  RTXCTXTPUSHELEMNAME (pctxt, "securityCapability");

                  ret = NASDec_TS24501IE_UESecurityCapability (pctxt, &pvalue->
                     securityCapability);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.securityCapabilityPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 47: {
               if (lastRow <= 3) {
                  /* decode requestedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "requestedNSSAI");

                  ret = NASDec_TS24501IE_NSSAI (pctxt, &pvalue->requestedNSSAI
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.requestedNSSAIPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 82: {
               if (lastRow <= 4) {
                  /* decode lastVisitedTAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "lastVisitedTAI");

                  ret = NASDec_TS24501IE_TrackingAreaIdent (pctxt, &pvalue->
                     lastVisitedTAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lastVisitedTAIPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 6;
               }
               break;
            }
            case 23: {
               if (lastRow <= 5) {
                  /* decode s1NetworkCapability */
                  RTXCTXTPUSHELEMNAME (pctxt, "s1NetworkCapability");

                  ret = NASDec_TS24301IE_UENetworkCapability (pctxt, &pvalue->
                     s1NetworkCapability);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.s1NetworkCapabilityPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 64: {
               if (lastRow <= 6) {
                  /* decode uplinkStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "uplinkStat");

                  ret = NASDec_TS24501IE_UplinkDataStatus (pctxt, &pvalue->
                     uplinkStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.uplinkStatPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 80: {
               if (lastRow <= 7) {
                  /* decode sessionStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "sessionStat");

                  ret = NASDec_TS24501IE_PDUSessionStatus (pctxt, &pvalue->
                     sessionStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.sessionStatPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 11: {
               if (lastRow <= 8) {
                  /* decode micoInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "micoInd");

                  ret = NASDec_TS24501IE_MICOIndication (pctxt, &pvalue->
                     micoInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.micoIndPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 43: {
               if (lastRow <= 9) {
                  /* decode ueStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueStat");

                  ret = NASDec_TS24301IE_UEStatus (pctxt, &pvalue->ueStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueStatPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 119: {
               if (lastRow <= 10) {
                  /* decode addlGUTI */
                  RTXCTXTPUSHELEMNAME (pctxt, "addlGUTI");

                  ret = NASDec_TS24501IE_MobileIdentity (pctxt, &pvalue->
                     addlGUTI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addlGUTIPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 37: {
               if (lastRow <= 11) {
                  /* decode allowedSessionStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "allowedSessionStat");

                  ret = NASDec_TS24501IE_AllowedPDUSessionStatus (pctxt, &
                     pvalue->allowedSessionStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.allowedSessionStatPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 24: {
               if (lastRow <= 12) {
                  /* decode ueUsage */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueUsage");

                  ret = NASDec_TS24501IE_UEUsageSetting (pctxt, &pvalue->
                     ueUsage);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueUsagePresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 81: {
               if (lastRow <= 13) {
                  /* decode reqDrxParams */
                  RTXCTXTPUSHELEMNAME (pctxt, "reqDrxParams");

                  ret = NASDec_TS24501IE_DRXParams (pctxt, &pvalue->
                     reqDrxParams);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reqDrxParamsPresent = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 112: {
               if (lastRow <= 14) {
                  /* decode epsContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsContainer");

                  ret = NASDec_TS24501IE_EPSMessageContainer (pctxt, &pvalue->
                     epsContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsContainerPresent = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 116: {
               if (lastRow <= 15) {
                  /* decode ladnInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "ladnInd");

                  ret = NASDec_TS24501IE_LADNIndication (pctxt, &pvalue->
                     ladnInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ladnIndPresent = 1;

                  lastRow = 16;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 8: {
               if (lastRow <= 16) {
                  /* decode containerType */
                  RTXCTXTPUSHELEMNAME (pctxt, "containerType");

                  ret = NASDec_TS24501IE_PayloadContainerType (pctxt, &pvalue->
                     containerType);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.containerTypePresent = 1;

                  lastRow = 17;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 123: {
               if (lastRow <= 17) {
                  /* decode container */
                  RTXCTXTPUSHELEMNAME (pctxt, "container");

                  /* Decode choice data value */

                  switch (pvalue->containerType)
                  {
                     /* uePolicy */
                     case 5:
                        RTXCTXTPUSHELEMNAME (pctxt, "uePolicy");

                        ret = NASDec_TS24501IE_OpaqueData (pctxt, &pvalue->
                           container.u.uePolicy);
                        if (ret < 0) return LOG_RTERR (pctxt, ret);

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                     default:
                        return LOG_RTERR (pctxt, RTERR_INVOPT);
                  }
                  pvalue->m.containerPresent = 1;

                  lastRow = 18;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 9: {
               if (lastRow <= 18) {
                  /* decode netSliceInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "netSliceInd");

                  ret = NASDec_TS24501IE_NetSliceIndication (pctxt, &pvalue->
                     netSliceInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.netSliceIndPresent = 1;

                  lastRow = 19;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 83: {
               if (lastRow <= 19) {
                  /* decode updateType */
                  RTXCTXTPUSHELEMNAME (pctxt, "updateType");

                  ret = NASDec_TS24501IE_UpdateType (pctxt, &pvalue->updateType
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.updateTypePresent = 1;

                  lastRow = 20;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 113: {
               if (lastRow <= 20) {
                  /* decode nasContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "nasContainer");

                  ret = NASDec_TS24501IE_NASMessageContainer2 (pctxt, &pvalue->
                     nasContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.nasContainerPresent = 1;

                  lastRow = 21;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 96: {
               if (lastRow <= 21) {
                  /* decode epsBearerStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsBearerStat");

                  ret = NASDec_TS24301IE_EPSBearerContextStatus (pctxt, &pvalue
                     ->epsBearerStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsBearerStatPresent = 1;

                  lastRow = 22;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 65: {
               if (lastRow <= 22) {
                  /* decode mobileStationClassmark2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "mobileStationClassmark2");

                  ret = NASDec_TS24008IE_MobileStationClassmark2 (pctxt, &
                     pvalue->mobileStationClassmark2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mobileStationClassmark2Present = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 23;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 66: {
               if (lastRow <= 23) {
                  /* decode supportedCodecs */
                  RTXCTXTPUSHELEMNAME (pctxt, "supportedCodecs");

                  ret = NASDec_TS24008IE_SupportedCodecList (pctxt, &pvalue->
                     supportedCodecs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.supportedCodecsPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 24;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 110: {
               if (lastRow <= 24) {
                  /* decode reqDRXParams */
                  RTXCTXTPUSHELEMNAME (pctxt, "reqDRXParams");

                  ret = NASDec_TS24008IE_ExtDRXParams (pctxt, &pvalue->
                     reqDRXParams);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reqDRXParamsPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 25;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 106: {
               if (lastRow <= 25) {
                  /* decode t3324 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3324");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3324);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3324Present = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 26;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 103: {
               if (lastRow <= 26) {
                  /* decode ueRadioCapabilityId */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueRadioCapabilityId");

                  ret = NASDec_TS24301IE_UERadioCapId (pctxt, &pvalue->
                     ueRadioCapabilityId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueRadioCapabilityIdPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 27;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 53: {
               if (lastRow <= 27) {
                  /* decode reqMappedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "reqMappedNSSAI");

                  ret = NASDec_TS24501IE_MappedNSSAI (pctxt, &pvalue->
                     reqMappedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reqMappedNSSAIPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 28;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 72: {
               if (lastRow <= 28) {
                  /* decode addlInfoRequested */
                  RTXCTXTPUSHELEMNAME (pctxt, "addlInfoRequested");

                  ret = NASDec_TS24501IE_AdditionalInfoRequested (pctxt, &
                     pvalue->addlInfoRequested);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addlInfoRequestedPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 29;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 26: {
               if (lastRow <= 29) {
                  /* decode wusAssistInfo */
                  RTXCTXTPUSHELEMNAME (pctxt, "wusAssistInfo");

                  ret = NASDec_TS24301IE_WUSAssistanceInfo (pctxt, &pvalue->
                     wusAssistInfo);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.wusAssistInfoPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 30;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 10: {
               if (lastRow <= 30) {
                  /* decode n5gcInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "n5gcInd");

                  ret = NASDec_TS24501IE_N5GCIndication (pctxt, &pvalue->
                     n5gcInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.n5gcIndPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 31;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 48: {
               if (lastRow <= 31) {
                  /* decode reqNBN1Params */
                  RTXCTXTPUSHELEMNAME (pctxt, "reqNBN1Params");

                  ret = NASDec_TS24501IE_NBN1ModeDRXParams (pctxt, &pvalue->
                     reqNBN1Params);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reqNBN1ParamsPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 32;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_RegAccept (OSCTXT* pctxt
   , TS24501Msg_RegAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RegAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode regResult */

   RTXCTXTPUSHELEMNAME (pctxt, "regResult");

   ret = NASDec_TS24501IE_RegistrationResult (pctxt, &pvalue->regResult);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 11 || nibble == 9 || nibble == 10 || nibble == 13 || nibble == 14) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 119: {
               if (lastRow == 0) {
                  /* decode guti */
                  RTXCTXTPUSHELEMNAME (pctxt, "guti");

                  ret = NASDec_TS24501IE_MobileIdentity (pctxt, &pvalue->guti
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.gutiPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 74: {
               if (lastRow <= 1) {
                  /* decode plmnList */
                  RTXCTXTPUSHELEMNAME (pctxt, "plmnList");

                  ret = NASDec_TS24008IE_PLMNList (pctxt, &pvalue->plmnList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.plmnListPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 84: {
               if (lastRow <= 2) {
                  /* decode taiList */
                  RTXCTXTPUSHELEMNAME (pctxt, "taiList");

                  ret = NASDec_TS24501IE_TrackingAreaIdentList (pctxt, &pvalue
                     ->taiList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.taiListPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 21: {
               if (lastRow <= 3) {
                  /* decode allowedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "allowedNSSAI");

                  ret = NASDec_TS24501IE_NSSAI (pctxt, &pvalue->allowedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.allowedNSSAIPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 17: {
               if (lastRow <= 4) {
                  /* decode rejectedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "rejectedNSSAI");

                  ret = NASDec_TS24501IE_RejectedNSSAIList (pctxt, &pvalue->
                     rejectedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.rejectedNSSAIPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 49: {
               if (lastRow <= 5) {
                  /* decode configuredNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "configuredNSSAI");

                  ret = NASDec_TS24501IE_NSSAI (pctxt, &pvalue->configuredNSSAI
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.configuredNSSAIPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 33: {
               if (lastRow <= 6) {
                  /* decode netSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "netSupport");

                  ret = NASDec_TS24501IE_NetworkFeatureSupport (pctxt, &pvalue
                     ->netSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.netSupportPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 80: {
               if (lastRow <= 7) {
                  /* decode sessionStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "sessionStat");

                  ret = NASDec_TS24501IE_PDUSessionStatus (pctxt, &pvalue->
                     sessionStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.sessionStatPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 38: {
               if (lastRow <= 8) {
                  /* decode reactivateRslt */
                  RTXCTXTPUSHELEMNAME (pctxt, "reactivateRslt");

                  ret = NASDec_TS24501IE_SessionReactivateRslt (pctxt, &pvalue
                     ->reactivateRslt);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reactivateRsltPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 114: {
               if (lastRow <= 9) {
                  /* decode reactivateRsltCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "reactivateRsltCause");

                  ret = NASDec_TS24501IE_SessionReactivateCause (pctxt, &pvalue
                     ->reactivateRsltCause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reactivateRsltCausePresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 121: {
               if (lastRow <= 10) {
                  /* decode ladn */
                  RTXCTXTPUSHELEMNAME (pctxt, "ladn");

                  ret = NASDec_TS24501IE_LADNList (pctxt, &pvalue->ladn);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ladnPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 11: {
               if (lastRow <= 11) {
                  /* decode micoInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "micoInd");

                  ret = NASDec_TS24501IE_MICOIndication (pctxt, &pvalue->
                     micoInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.micoIndPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 9: {
               if (lastRow <= 12) {
                  /* decode netSliceInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "netSliceInd");

                  ret = NASDec_TS24501IE_NetSliceIndication (pctxt, &pvalue->
                     netSliceInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.netSliceIndPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 39: {
               if (lastRow <= 13) {
                  /* decode svcAreaList */
                  RTXCTXTPUSHELEMNAME (pctxt, "svcAreaList");

                  ret = NASDec_TS24501IE_TrackingAreaIdentList (pctxt, &pvalue
                     ->svcAreaList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.svcAreaListPresent = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 94: {
               if (lastRow <= 14) {
                  /* decode t3512 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3512");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3512);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3512Present = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 93: {
               if (lastRow <= 15) {
                  /* decode non3GPPDeregTimer */
                  RTXCTXTPUSHELEMNAME (pctxt, "non3GPPDeregTimer");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->
                     non3GPPDeregTimer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.non3GPPDeregTimerPresent = 1;

                  lastRow = 16;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 22: {
               if (lastRow <= 16) {
                  /* decode t3502 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3502");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3502);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3502Present = 1;

                  lastRow = 17;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 52: {
               if (lastRow <= 17) {
                  /* decode emergencyNumList */
                  RTXCTXTPUSHELEMNAME (pctxt, "emergencyNumList");

                  ret = NASDec_TS24008IE_EmergencyNumberList (pctxt, &pvalue->
                     emergencyNumList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.emergencyNumListPresent = 1;

                  lastRow = 18;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 122: {
               if (lastRow <= 18) {
                  /* decode extEmergencyNumList */
                  RTXCTXTPUSHELEMNAME (pctxt, "extEmergencyNumList");

                  ret = NASDec_TS24301IE_ExtEmergencyNumberList (pctxt, &pvalue
                     ->extEmergencyNumList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extEmergencyNumListPresent = 1;

                  lastRow = 19;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 115: {
               if (lastRow <= 19) {
                  /* decode transparentContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "transparentContainer");

                  ret = NASDec_TS24501IE_SORTransparentContainer (pctxt, &
                     pvalue->transparentContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.transparentContainerPresent = 1;

                  lastRow = 20;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 120: {
               if (lastRow <= 20) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 21;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 10: {
               if (lastRow <= 21) {
                  /* decode inclusionMode */
                  RTXCTXTPUSHELEMNAME (pctxt, "inclusionMode");

                  ret = NASDec_TS24501IE_NSSAIInclusionMode (pctxt, &pvalue->
                     inclusionMode);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.inclusionModePresent = 1;

                  lastRow = 22;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 118: {
               if (lastRow <= 22) {
                  /* decode accessDefs */
                  RTXCTXTPUSHELEMNAME (pctxt, "accessDefs");

                  ret = NASDec_TS24501IE_AccessCategoryDefinitions (pctxt, &
                     pvalue->accessDefs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.accessDefsPresent = 1;

                  lastRow = 23;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 81: {
               if (lastRow <= 23) {
                  /* decode negotiatedDrxParams */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedDrxParams");

                  ret = NASDec_TS24501IE_DRXParams (pctxt, &pvalue->
                     negotiatedDrxParams);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedDrxParamsPresent = 1;

                  lastRow = 24;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 13: {
               if (lastRow <= 24) {
                  /* decode non3GPPNWPolicies */
                  RTXCTXTPUSHELEMNAME (pctxt, "non3GPPNWPolicies");

                  ret = NASDec_TS24008IE_Non3GPPNetPolicies (pctxt, &pvalue->
                     non3GPPNWPolicies);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.non3GPPNWPoliciesPresent = 1;

                  lastRow = 25;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 96: {
               if (lastRow <= 25) {
                  /* decode epsBearerStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsBearerStat");

                  ret = NASDec_TS24301IE_EPSBearerContextStatus (pctxt, &pvalue
                     ->epsBearerStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsBearerStatPresent = 1;

                  lastRow = 26;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 110: {
               if (lastRow <= 26) {
                  /* decode negotiatedExtDrxParams */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedExtDrxParams");

                  ret = NASDec_TS24008IE_ExtDRXParams (pctxt, &pvalue->
                     negotiatedExtDrxParams);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedExtDrxParamsPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 27;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 108: {
               if (lastRow <= 27) {
                  /* decode t3447 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3447");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3447);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3447Present = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 28;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 107: {
               if (lastRow <= 28) {
                  /* decode t3448 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3448");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3448);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3448Present = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 29;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 106: {
               if (lastRow <= 29) {
                  /* decode t3324 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3324");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3324);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3324Present = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 30;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 103: {
               if (lastRow <= 30) {
                  /* decode ueRadioCapabilityId */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueRadioCapabilityId");

                  ret = NASDec_TS24301IE_UERadioCapId (pctxt, &pvalue->
                     ueRadioCapabilityId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueRadioCapabilityIdPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 31;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 14: {
               if (lastRow <= 31) {
                  /* decode ueRadioCapIdDeletionIndication */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueRadioCapIdDeletionIndication");

                  ret = NASDec_TS24301IE_UERadioCapIdDeletionInd (pctxt, &
                     pvalue->ueRadioCapIdDeletionIndication);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueRadioCapIdDeletionIndicationPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 32;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 57: {
               if (lastRow <= 32) {
                  /* decode pendingNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "pendingNSSAI");

                  ret = NASDec_TS24501IE_NSSAI (pctxt, &pvalue->pendingNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pendingNSSAIPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 33;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 116: {
               if (lastRow <= 33) {
                  /* decode cipherKeyData */
                  RTXCTXTPUSHELEMNAME (pctxt, "cipherKeyData");

                  ret = NASDec_TS24501IE_CipheringKeyData (pctxt, &pvalue->
                     cipherKeyData);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.cipherKeyDataPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 34;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 117: {
               if (lastRow <= 34) {
                  /* decode cagInfoList */
                  RTXCTXTPUSHELEMNAME (pctxt, "cagInfoList");

                  ret = NASDec_TS24501IE_CAGInfoList (pctxt, &pvalue->
                     cagInfoList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.cagInfoListPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 35;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 27: {
               if (lastRow <= 35) {
                  /* decode truncatedConfig */
                  RTXCTXTPUSHELEMNAME (pctxt, "truncatedConfig");

                  ret = NASDec_TS24501IE_TruncatedTMSIConfig (pctxt, &pvalue->
                     truncatedConfig);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.truncatedConfigPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 36;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 28: {
               if (lastRow <= 36) {
                  /* decode negotiatedWUSAssistInfo */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedWUSAssistInfo");

                  ret = NASDec_TS24301IE_WUSAssistanceInfo (pctxt, &pvalue->
                     negotiatedWUSAssistInfo);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedWUSAssistInfoPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 37;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 41: {
               if (lastRow <= 37) {
                  /* decode negotiatedNBN1Params */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedNBN1Params");

                  ret = NASDec_TS24501IE_NBN1ModeDRXParams (pctxt, &pvalue->
                     negotiatedNBN1Params);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedNBN1ParamsPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 38;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 104: {
               if (lastRow <= 38) {
                  /* decode extRejectedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "extRejectedNSSAI");

                  ret = NASDec_TS24501IE_ExtRejectedNSSAIList (pctxt, &pvalue->
                     extRejectedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extRejectedNSSAIPresent = 1;
                  pvalue->m._v17ExtPresent = 1;

                  lastRow = 39;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_RegComplete (OSCTXT* pctxt
   , TS24501Msg_RegComplete* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RegComplete");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 115: {
               if (lastRow == 0) {
                  /* decode transparentContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "transparentContainer");

                  ret = NASDec_TS24501IE_SORTransparentContainer (pctxt, &
                     pvalue->transparentContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.transparentContainerPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_RegReject (OSCTXT* pctxt
   , TS24501Msg_RegReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RegReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_MMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 95: {
               if (lastRow == 0) {
                  /* decode t3346 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3346");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3346);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3346Present = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 22: {
               if (lastRow <= 1) {
                  /* decode t3502 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3502");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3502);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3502Present = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 120: {
               if (lastRow <= 2) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 105: {
               if (lastRow <= 3) {
                  /* decode rejectedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "rejectedNSSAI");

                  ret = NASDec_TS24501IE_RejectedNSSAIList (pctxt, &pvalue->
                     rejectedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.rejectedNSSAIPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 117: {
               if (lastRow <= 4) {
                  /* decode cagInfoList */
                  RTXCTXTPUSHELEMNAME (pctxt, "cagInfoList");

                  ret = NASDec_TS24501IE_CAGInfoList (pctxt, &pvalue->
                     cagInfoList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.cagInfoListPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 104: {
               if (lastRow <= 5) {
                  /* decode extRejectedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "extRejectedNSSAI");

                  ret = NASDec_TS24501IE_ExtRejectedNSSAIList (pctxt, &pvalue->
                     extRejectedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extRejectedNSSAIPresent = 1;
                  pvalue->m._v17ExtPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_EstablishRequest (OSCTXT* pctxt
   , TS24501Msg_EstablishRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EstablishRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode integProtMaxRate */

   RTXCTXTPUSHELEMNAME (pctxt, "integProtMaxRate");

   ret = NASDec_TS24501IE_IntegrityProtMaxDataRate (pctxt, &pvalue->
      integProtMaxRate);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 9 || nibble == 10 || nibble == 11) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 9: {
               if (lastRow == 0) {
                  /* decode pduSessionType */
                  RTXCTXTPUSHELEMNAME (pctxt, "pduSessionType");

                  ret = NASDec_TS24501IE_PDUSessionType (pctxt, &pvalue->
                     pduSessionType);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pduSessionTypePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 10: {
               if (lastRow <= 1) {
                  /* decode sscMode */
                  RTXCTXTPUSHELEMNAME (pctxt, "sscMode");

                  ret = NASDec_TS24501IE_SSCMode (pctxt, &pvalue->sscMode);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.sscModePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 40: {
               if (lastRow <= 2) {
                  /* decode capability */
                  RTXCTXTPUSHELEMNAME (pctxt, "capability");

                  ret = NASDec_TS24501IE_SMCapability (pctxt, &pvalue->
                     capability);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.capabilityPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 85: {
               if (lastRow <= 3) {
                  /* decode maxPktFilters */
                  RTXCTXTPUSHELEMNAME (pctxt, "maxPktFilters");

                  ret = NASDec_TS24501IE_MaxSupportedPacketFilters (pctxt, &
                     pvalue->maxPktFilters);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.maxPktFiltersPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 2;
               }
               break;
            }
            case 11: {
               if (lastRow <= 4) {
                  /* decode alwaysOnPDUSession */
                  RTXCTXTPUSHELEMNAME (pctxt, "alwaysOnPDUSession");

                  ret = NASDec_TS24501IE_AlwaysOnPDUSessionReq (pctxt, &pvalue
                     ->alwaysOnPDUSession);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.alwaysOnPDUSessionPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 57: {
               if (lastRow <= 5) {
                  /* decode reqContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "reqContainer");

                  ret = NASDec_TS24501IE_SmPduDnReqContainer (pctxt, &pvalue->
                     reqContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reqContainerPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 123: {
               if (lastRow <= 6) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 102: {
               if (lastRow <= 7) {
                  /* decode headerCompressionCfg */
                  RTXCTXTPUSHELEMNAME (pctxt, "headerCompressionCfg");

                  ret = NASDec_TS24501IE_HeaderCompressionConfig (pctxt, &
                     pvalue->headerCompressionCfg);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.headerCompressionCfgPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 110: {
               if (lastRow <= 8) {
                  /* decode dsttPortMacAddr */
                  RTXCTXTPUSHELEMNAME (pctxt, "dsttPortMacAddr");

                  ret = NASDec_TS24501IE_DSTTEthMACAddr (pctxt, &pvalue->
                     dsttPortMacAddr);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.dsttPortMacAddrPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 111: {
               if (lastRow <= 9) {
                  /* decode dsttResidenceTime */
                  RTXCTXTPUSHELEMNAME (pctxt, "dsttResidenceTime");

                  ret = NASDec_TS24501IE_DSTTResidenceTime (pctxt, &pvalue->
                     dsttResidenceTime);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.dsttResidenceTimePresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 116: {
               if (lastRow <= 10) {
                  /* decode portMgmtInfoContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "portMgmtInfoContainer");

                  ret = NASDec_TS24501IE_PortMgmtInfoContainer (pctxt, &pvalue
                     ->portMgmtInfoContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.portMgmtInfoContainerPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 31: {
               if (lastRow <= 11) {
                  /* decode ethernetHdrCompressionCfg */
                  RTXCTXTPUSHELEMNAME (pctxt, "ethernetHdrCompressionCfg");

                  ret = NASDec_TS24501IE_EthHdrCompressConfig (pctxt, &pvalue->
                     ethernetHdrCompressionCfg);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ethernetHdrCompressionCfgPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 41: {
               if (lastRow <= 12) {
                  /* decode suggestedInterfaceId */
                  RTXCTXTPUSHELEMNAME (pctxt, "suggestedInterfaceId");

                  ret = NASDec_TS24501IE_PDUAddress (pctxt, &pvalue->
                     suggestedInterfaceId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.suggestedInterfaceIdPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_EstablishAccept (OSCTXT* pctxt
   , TS24501Msg_EstablishAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EstablishAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode sscMode */

   RTXCTXTPUSHELEMNAME (pctxt, "sscMode");

   ret = NASDec_TS24501IE_SSCMode (pctxt, &pvalue->sscMode);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pduSessionType */

   RTXCTXTPUSHELEMNAME (pctxt, "pduSessionType");

   ret = NASDec_TS24501IE_PDUSessionType (pctxt, &pvalue->pduSessionType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode qosRules */

   RTXCTXTPUSHELEMNAME (pctxt, "qosRules");

   ret = NASDec_TS24501IE_QoSRules (pctxt, &pvalue->qosRules);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sessionAMBR */

   RTXCTXTPUSHELEMNAME (pctxt, "sessionAMBR");

   ret = NASDec_TS24501IE_SessionAMBR (pctxt, &pvalue->sessionAMBR);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 8 || nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 89: {
               if (lastRow == 0) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 41: {
               if (lastRow <= 1) {
                  /* decode pduAddress */
                  RTXCTXTPUSHELEMNAME (pctxt, "pduAddress");

                  ret = NASDec_TS24501IE_PDUAddress (pctxt, &pvalue->pduAddress
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pduAddressPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 86: {
               if (lastRow <= 2) {
                  /* decode rqTimer */
                  RTXCTXTPUSHELEMNAME (pctxt, "rqTimer");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->rqTimer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.rqTimerPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 34: {
               if (lastRow <= 3) {
                  /* decode snssai */
                  RTXCTXTPUSHELEMNAME (pctxt, "snssai");

                  ret = NASDec_TS24501IE_SNSSAI (pctxt, &pvalue->snssai);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.snssaiPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 8: {
               if (lastRow <= 4) {
                  /* decode alwaysOnPDUSession */
                  RTXCTXTPUSHELEMNAME (pctxt, "alwaysOnPDUSession");

                  ret = NASDec_TS24501IE_AlwaysOnPDUSessionInd (pctxt, &pvalue
                     ->alwaysOnPDUSession);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.alwaysOnPDUSessionPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 117: {
               if (lastRow <= 5) {
                  /* decode epsBearerCtxts */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsBearerCtxts");

                  ret = NASDec_TS24501IE_EPSBearerCtxts (pctxt, &pvalue->
                     epsBearerCtxts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsBearerCtxtsPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 120: {
               if (lastRow <= 6) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 121: {
               if (lastRow <= 7) {
                  /* decode qosFlowDesr */
                  RTXCTXTPUSHELEMNAME (pctxt, "qosFlowDesr");

                  ret = NASDec_TS24501IE_QOSFlowDescriptions (pctxt, &pvalue->
                     qosFlowDesr);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.qosFlowDesrPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 123: {
               if (lastRow <= 8) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 37: {
               if (lastRow <= 9) {
                  /* decode dnn */
                  RTXCTXTPUSHELEMNAME (pctxt, "dnn");

                  ret = NASDec_TS24501IE_DNNList (pctxt, &pvalue->dnn);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.dnnPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 23: {
               if (lastRow <= 10) {
                  /* decode smNetFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "smNetFeatureSupport");

                  ret = NASDec_TS24501IE_SMNetworkFeatureSupport (pctxt, &
                     pvalue->smNetFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.smNetFeatureSupportPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 24: {
               if (lastRow <= 11) {
                  /* decode servingPLMNRateCtrl */
                  RTXCTXTPUSHELEMNAME (pctxt, "servingPLMNRateCtrl");

                  ret = NASDec_TS24301IE_ServPLMNRateCtrl (pctxt, &pvalue->
                     servingPLMNRateCtrl);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.servingPLMNRateCtrlPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 119: {
               if (lastRow <= 12) {
                  /* decode atsssContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "atsssContainer");

                  ret = NASDec_TS24501IE_ATSSSContainer (pctxt, &pvalue->
                     atsssContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.atsssContainerPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 12: {
               if (lastRow <= 13) {
                  /* decode ctrlPlaneOnlyIndication */
                  RTXCTXTPUSHELEMNAME (pctxt, "ctrlPlaneOnlyIndication");

                  ret = NASDec_TS24501IE_ControlPlaneIndication (pctxt, &pvalue
                     ->ctrlPlaneOnlyIndication);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ctrlPlaneOnlyIndicationPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 102: {
               if (lastRow <= 14) {
                  /* decode headerCompressionCfg */
                  RTXCTXTPUSHELEMNAME (pctxt, "headerCompressionCfg");

                  ret = NASDec_TS24501IE_HeaderCompressionConfig (pctxt, &
                     pvalue->headerCompressionCfg);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.headerCompressionCfgPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 31: {
               if (lastRow <= 15) {
                  /* decode ethernetHdrCompressionCfg */
                  RTXCTXTPUSHELEMNAME (pctxt, "ethernetHdrCompressionCfg");

                  ret = NASDec_TS24501IE_EthHdrCompressConfig (pctxt, &pvalue->
                     ethernetHdrCompressionCfg);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ethernetHdrCompressionCfgPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 16;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_EstablishReject (OSCTXT* pctxt
   , TS24501Msg_EstablishReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EstablishReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 15) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 55: {
               if (lastRow == 0) {
                  /* decode backoffTimer */
                  RTXCTXTPUSHELEMNAME (pctxt, "backoffTimer");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->
                     backoffTimer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.backoffTimerPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 15: {
               if (lastRow <= 1) {
                  /* decode allowedSSCMode */
                  RTXCTXTPUSHELEMNAME (pctxt, "allowedSSCMode");

                  ret = NASDec_TS24501IE_AllowedSSCMode (pctxt, &pvalue->
                     allowedSSCMode);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.allowedSSCModePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 120: {
               if (lastRow <= 2) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 123: {
               if (lastRow <= 3) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 97: {
               if (lastRow <= 4) {
                  /* decode congestionReattemptInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "congestionReattemptInd");

                  ret = NASDec_TS24501IE_CongestionReattemptIndicator (pctxt, &
                     pvalue->congestionReattemptInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.congestionReattemptIndPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 29: {
               if (lastRow <= 5) {
                  /* decode reattemptInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "reattemptInd");

                  ret = NASDec_TS24501IE_ReattemptIndicator (pctxt, &pvalue->
                     reattemptInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reattemptIndPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_SMAuthCmd (OSCTXT* pctxt
   , TS24501Msg_SMAuthCmd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SMAuthCmd");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode eapMessage */

   RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

   ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 123: {
               if (lastRow == 0) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_SMAuthDone (OSCTXT* pctxt
   , TS24501Msg_SMAuthDone* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SMAuthDone");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode eapMessage */

   RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

   ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 123: {
               if (lastRow == 0) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_SMAuthResult (OSCTXT* pctxt
   , TS24501Msg_SMAuthResult* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SMAuthResult");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 120: {
               if (lastRow == 0) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 123: {
               if (lastRow <= 1) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ModifyRequest (OSCTXT* pctxt
   , TS24501Msg_ModifyRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 11) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 40: {
               if (lastRow == 0) {
                  /* decode capability */
                  RTXCTXTPUSHELEMNAME (pctxt, "capability");

                  ret = NASDec_TS24501IE_SMCapability (pctxt, &pvalue->
                     capability);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.capabilityPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 89: {
               if (lastRow <= 1) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 85: {
               if (lastRow <= 2) {
                  /* decode maxPktFilters */
                  RTXCTXTPUSHELEMNAME (pctxt, "maxPktFilters");

                  ret = NASDec_TS24501IE_MaxSupportedPacketFilters (pctxt, &
                     pvalue->maxPktFilters);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.maxPktFiltersPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 2;
               }
               break;
            }
            case 11: {
               if (lastRow <= 3) {
                  /* decode alwaysOnPDUSession */
                  RTXCTXTPUSHELEMNAME (pctxt, "alwaysOnPDUSession");

                  ret = NASDec_TS24501IE_AlwaysOnPDUSessionReq (pctxt, &pvalue
                     ->alwaysOnPDUSession);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.alwaysOnPDUSessionPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 19: {
               if (lastRow <= 4) {
                  /* decode integProtMaxRate */
                  RTXCTXTPUSHELEMNAME (pctxt, "integProtMaxRate");

                  ret = NASDec_TS24501IE_IntegrityProtMaxDataRate (pctxt, &
                     pvalue->integProtMaxRate);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.integProtMaxRatePresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 2;
               }
               break;
            }
            case 122: {
               if (lastRow <= 5) {
                  /* decode qosRules */
                  RTXCTXTPUSHELEMNAME (pctxt, "qosRules");

                  ret = NASDec_TS24501IE_QoSRules (pctxt, &pvalue->qosRules);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.qosRulesPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 121: {
               if (lastRow <= 6) {
                  /* decode qosFlowDesr */
                  RTXCTXTPUSHELEMNAME (pctxt, "qosFlowDesr");

                  ret = NASDec_TS24501IE_QOSFlowDescriptions (pctxt, &pvalue->
                     qosFlowDesr);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.qosFlowDesrPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 117: {
               if (lastRow <= 7) {
                  /* decode epsBearerCtxts */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsBearerCtxts");

                  ret = NASDec_TS24501IE_EPSBearerCtxts (pctxt, &pvalue->
                     epsBearerCtxts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsBearerCtxtsPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 123: {
               if (lastRow <= 8) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 116: {
               if (lastRow <= 9) {
                  /* decode portMgmtInfoContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "portMgmtInfoContainer");

                  ret = NASDec_TS24501IE_PortMgmtInfoContainer (pctxt, &pvalue
                     ->portMgmtInfoContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.portMgmtInfoContainerPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 102: {
               if (lastRow <= 10) {
                  /* decode headerCompressionCfg */
                  RTXCTXTPUSHELEMNAME (pctxt, "headerCompressionCfg");

                  ret = NASDec_TS24501IE_HeaderCompressionConfig (pctxt, &
                     pvalue->headerCompressionCfg);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.headerCompressionCfgPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 31: {
               if (lastRow <= 11) {
                  /* decode ethernetHdrCompressionCfg */
                  RTXCTXTPUSHELEMNAME (pctxt, "ethernetHdrCompressionCfg");

                  ret = NASDec_TS24501IE_EthHdrCompressConfig (pctxt, &pvalue->
                     ethernetHdrCompressionCfg);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ethernetHdrCompressionCfgPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ModifyReject (OSCTXT* pctxt
   , TS24501Msg_ModifyReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 55: {
               if (lastRow == 0) {
                  /* decode backoffTimer */
                  RTXCTXTPUSHELEMNAME (pctxt, "backoffTimer");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->
                     backoffTimer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.backoffTimerPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 123: {
               if (lastRow <= 1) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 97: {
               if (lastRow <= 2) {
                  /* decode congestionReattemptInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "congestionReattemptInd");

                  ret = NASDec_TS24501IE_CongestionReattemptIndicator (pctxt, &
                     pvalue->congestionReattemptInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.congestionReattemptIndPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 29: {
               if (lastRow <= 3) {
                  /* decode reattemptInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "reattemptInd");

                  ret = NASDec_TS24501IE_ReattemptIndicator (pctxt, &pvalue->
                     reattemptInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reattemptIndPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ModifyCmd (OSCTXT* pctxt
   , TS24501Msg_ModifyCmd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyCmd");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 8) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 89: {
               if (lastRow == 0) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 42: {
               if (lastRow <= 1) {
                  /* decode sessionAMBR */
                  RTXCTXTPUSHELEMNAME (pctxt, "sessionAMBR");

                  ret = NASDec_TS24501IE_SessionAMBR (pctxt, &pvalue->
                     sessionAMBR);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.sessionAMBRPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 86: {
               if (lastRow <= 2) {
                  /* decode rqTimer */
                  RTXCTXTPUSHELEMNAME (pctxt, "rqTimer");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->rqTimer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.rqTimerPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 8: {
               if (lastRow <= 3) {
                  /* decode alwaysOnPDUSession */
                  RTXCTXTPUSHELEMNAME (pctxt, "alwaysOnPDUSession");

                  ret = NASDec_TS24501IE_AlwaysOnPDUSessionReq (pctxt, &pvalue
                     ->alwaysOnPDUSession);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.alwaysOnPDUSessionPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 122: {
               if (lastRow <= 4) {
                  /* decode qosRules */
                  RTXCTXTPUSHELEMNAME (pctxt, "qosRules");

                  ret = NASDec_TS24501IE_QoSRules (pctxt, &pvalue->qosRules);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.qosRulesPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 117: {
               if (lastRow <= 5) {
                  /* decode epsBearerCtxts */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsBearerCtxts");

                  ret = NASDec_TS24501IE_EPSBearerCtxts (pctxt, &pvalue->
                     epsBearerCtxts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsBearerCtxtsPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 121: {
               if (lastRow <= 6) {
                  /* decode qosFlowDesr */
                  RTXCTXTPUSHELEMNAME (pctxt, "qosFlowDesr");

                  ret = NASDec_TS24501IE_QOSFlowDescriptions (pctxt, &pvalue->
                     qosFlowDesr);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.qosFlowDesrPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 123: {
               if (lastRow <= 7) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 119: {
               if (lastRow <= 8) {
                  /* decode atsssContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "atsssContainer");

                  ret = NASDec_TS24501IE_ATSSSContainer (pctxt, &pvalue->
                     atsssContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.atsssContainerPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 102: {
               if (lastRow <= 9) {
                  /* decode headerCompressionCfg */
                  RTXCTXTPUSHELEMNAME (pctxt, "headerCompressionCfg");

                  ret = NASDec_TS24501IE_HeaderCompressionConfig (pctxt, &
                     pvalue->headerCompressionCfg);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.headerCompressionCfgPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 116: {
               if (lastRow <= 10) {
                  /* decode portMgmtInfoContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "portMgmtInfoContainer");

                  ret = NASDec_TS24501IE_PortMgmtInfoContainer (pctxt, &pvalue
                     ->portMgmtInfoContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.portMgmtInfoContainerPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 30: {
               if (lastRow <= 11) {
                  /* decode servingPLMNRateCtrl */
                  RTXCTXTPUSHELEMNAME (pctxt, "servingPLMNRateCtrl");

                  ret = NASDec_TS24301IE_ServPLMNRateCtrl (pctxt, &pvalue->
                     servingPLMNRateCtrl);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.servingPLMNRateCtrlPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 31: {
               if (lastRow <= 12) {
                  /* decode ethernetHdrCompressionCfg */
                  RTXCTXTPUSHELEMNAME (pctxt, "ethernetHdrCompressionCfg");

                  ret = NASDec_TS24501IE_EthHdrCompressConfig (pctxt, &pvalue->
                     ethernetHdrCompressionCfg);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ethernetHdrCompressionCfgPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ModifyDone (OSCTXT* pctxt
   , TS24501Msg_ModifyDone* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyDone");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 123: {
               if (lastRow == 0) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 116: {
               if (lastRow <= 1) {
                  /* decode portMgmtInfoContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "portMgmtInfoContainer");

                  ret = NASDec_TS24501IE_PortMgmtInfoContainer (pctxt, &pvalue
                     ->portMgmtInfoContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.portMgmtInfoContainerPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ModifyCmdReject (OSCTXT* pctxt
   , TS24501Msg_ModifyCmdReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyCmdReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 123: {
               if (lastRow == 0) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ReleaseRequest (OSCTXT* pctxt
   , TS24501Msg_ReleaseRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReleaseRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 89: {
               if (lastRow == 0) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 123: {
               if (lastRow <= 1) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ReleaseReject (OSCTXT* pctxt
   , TS24501Msg_ReleaseReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReleaseReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 123: {
               if (lastRow == 0) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ReleaseCmd (OSCTXT* pctxt
   , TS24501Msg_ReleaseCmd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReleaseCmd");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 13) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 55: {
               if (lastRow == 0) {
                  /* decode backoffTimer */
                  RTXCTXTPUSHELEMNAME (pctxt, "backoffTimer");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->
                     backoffTimer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.backoffTimerPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 120: {
               if (lastRow <= 1) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 97: {
               if (lastRow <= 2) {
                  /* decode congestionReattemptInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "congestionReattemptInd");

                  ret = NASDec_TS24501IE_CongestionReattemptIndicator (pctxt, &
                     pvalue->congestionReattemptInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.congestionReattemptIndPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 123: {
               if (lastRow <= 3) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 13: {
               if (lastRow <= 4) {
                  /* decode accessType */
                  RTXCTXTPUSHELEMNAME (pctxt, "accessType");

                  ret = NASDec_TS24501IE_AccessType (pctxt, &pvalue->accessType
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.accessTypePresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ReleaseDone (OSCTXT* pctxt
   , TS24501Msg_ReleaseDone* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReleaseDone");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 89: {
               if (lastRow == 0) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 123: {
               if (lastRow <= 1) {
                  /* decode extProtoCfgOpts */
                  RTXCTXTPUSHELEMNAME (pctxt, "extProtoCfgOpts");

                  ret = NASDec_TS24008IE_ExtProtoConfigOptions (pctxt, &pvalue
                     ->extProtoCfgOpts);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extProtoCfgOptsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_SMStatus (OSCTXT* pctxt
   , TS24501Msg_SMStatus* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SMStatus");

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_SMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_SMSMessage (OSCTXT* pctxt
   , TS24501Msg_SMSMessage* pvalue)
{
   OSSIZE endIndex;
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SMSMessage");

   /* decode length */

   RTXCTXTPUSHELEMNAME (pctxt, "length");
   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->length, 8);
   if (0 != ret) return LOG_RTERR (pctxt, ret);
   endIndex = rtxCtxtGetBitOffset (pctxt) + (pvalue->length) * 8;

   ret = rtxCtxtPushContainerBytes(pctxt, pvalue->length);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cpPdu */

   RTXCTXTPUSHELEMNAME (pctxt, "cpPdu");

   ret = NASDec_TS24011Msg_CP_PDU (pctxt, &pvalue->cpPdu);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   if (rtxCtxtGetBitOffset(pctxt) > endIndex)
      return LOG_RTERR (pctxt, RTERR_INVLEN);

   rtxCtxtSetBitOffset(pctxt, endIndex);
   rtxCtxtPopContainer(pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ControlPlaneServReq (OSCTXT* pctxt
   , TS24501Msg_ControlPlaneServReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ControlPlaneServReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode nasKeySetIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdent");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->nasKeySetIdent
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ctrlPlaneServType */

   RTXCTXTPUSHELEMNAME (pctxt, "ctrlPlaneServType");

   ret = NASDec_TS24501IE_ControlPlaneServiceType (pctxt, &pvalue->
      ctrlPlaneServType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 8 || nibble == 15) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 8: {
               if (lastRow == 0) {
                  /* decode containerType */
                  RTXCTXTPUSHELEMNAME (pctxt, "containerType");

                  ret = NASDec_TS24501IE_PayloadContainerType (pctxt, &pvalue->
                     containerType);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.containerTypePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 123: {
               if (lastRow <= 1) {
                  /* decode container */
                  RTXCTXTPUSHELEMNAME (pctxt, "container");

                  /* Decode choice data value */

                  switch (pvalue->containerType)
                  {
                     /* sms */
                     case 2:
                        RTXCTXTPUSHELEMNAME (pctxt, "sms");

                        ret = NASDec_TS24501Msg_SMSMessage (pctxt, &pvalue->
                           container.u.sms);
                        if (ret < 0) return LOG_RTERR (pctxt, ret);

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                     /* locSvcs */
                     case 7:
                        RTXCTXTPUSHELEMNAME (pctxt, "locSvcs");

                        ret = NASDec_TS24501IE_OpaqueData (pctxt, &pvalue->
                           container.u.locSvcs);
                        if (ret < 0) return LOG_RTERR (pctxt, ret);

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                     /* cIOTUserData */
                     case 8:
                        RTXCTXTPUSHELEMNAME (pctxt, "cIOTUserData");

                        ret = NASDec_TS24301IE_UserDataContainer (pctxt, &
                           pvalue->container.u.cIOTUserData);
                        if (ret < 0) return LOG_RTERR (pctxt, ret);

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                     default:
                        return LOG_RTERR (pctxt, RTERR_INVOPT);
                  }
                  pvalue->m.containerPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 18: {
               if (lastRow <= 2) {
                  /* decode pduSessionId */
                  RTXCTXTPUSHELEMNAME (pctxt, "pduSessionId");

                  ret = NASDec_TS24501IE_PDUSessionId2 (pctxt, &pvalue->
                     pduSessionId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pduSessionIdPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 80: {
               if (lastRow <= 3) {
                  /* decode sessionStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "sessionStat");

                  ret = NASDec_TS24501IE_PDUSessionStatus (pctxt, &pvalue->
                     sessionStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.sessionStatPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 15: {
               if (lastRow <= 4) {
                  /* decode releaseAssistIndication */
                  RTXCTXTPUSHELEMNAME (pctxt, "releaseAssistIndication");

                  ret = NASDec_TS24301IE_ReleaseAssistInd (pctxt, &pvalue->
                     releaseAssistIndication);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.releaseAssistIndicationPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 64: {
               if (lastRow <= 5) {
                  /* decode uplinkStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "uplinkStat");

                  ret = NASDec_TS24501IE_UplinkDataStatus (pctxt, &pvalue->
                     uplinkStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.uplinkStatPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 113: {
               if (lastRow <= 6) {
                  /* decode nasMsgContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "nasMsgContainer");

                  ret = NASDec_TS24501IE_NASMessageContainer2 (pctxt, &pvalue->
                     nasMsgContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.nasMsgContainerPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 36: {
               if (lastRow <= 7) {
                  /* decode addlInfo */
                  RTXCTXTPUSHELEMNAME (pctxt, "addlInfo");

                  ret = NASDec_TS24501IE_AdditionalInfo (pctxt, &pvalue->
                     addlInfo);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addlInfoPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 111: {
               if (lastRow <= 8) {
                  /* decode ciotSmallDataContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "ciotSmallDataContainer");

                  ret = NASDec_TS24501IE_CIoTSmallDataContainer (pctxt, &pvalue
                     ->ciotSmallDataContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ciotSmallDataContainerPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 37: {
               if (lastRow <= 9) {
                  /* decode allowedPduSessStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "allowedPduSessStat");

                  ret = NASDec_TS24501IE_AllowedPDUSessionStatus (pctxt, &
                     pvalue->allowedPduSessStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.allowedPduSessStatPresent = 1;
                  pvalue->m._v17ExtPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_NetSliceAuthCmd (OSCTXT* pctxt
   , TS24501Msg_NetSliceAuthCmd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NetSliceAuthCmd");

   /* decode snssai */

   RTXCTXTPUSHELEMNAME (pctxt, "snssai");

   ret = NASDec_TS24501IE_SNSSAI (pctxt, &pvalue->snssai);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eapMessage */

   RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

   ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_NetSliceAuthDone (OSCTXT* pctxt
   , TS24501Msg_NetSliceAuthDone* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NetSliceAuthDone");

   /* decode snssai */

   RTXCTXTPUSHELEMNAME (pctxt, "snssai");

   ret = NASDec_TS24501IE_SNSSAI (pctxt, &pvalue->snssai);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eapMessage */

   RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

   ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_NetSliceAuthResult (OSCTXT* pctxt
   , TS24501Msg_NetSliceAuthResult* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NetSliceAuthResult");

   /* decode snssai */

   RTXCTXTPUSHELEMNAME (pctxt, "snssai");

   ret = NASDec_TS24501IE_SNSSAI (pctxt, &pvalue->snssai);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eapMessage */

   RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

   ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_PDU_SM (OSCTXT* pctxt, TS24501Msg_PDU_SM* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDU_SM");

   /* decode protoDiscr */

   RTXCTXTPUSHELEMNAME (pctxt, "protoDiscr");

   ret = NASDec_TS24501Msg_NAS5GProtoDiscr (pctxt, &pvalue->protoDiscr);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pduSessIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "pduSessIdent");

   ret = NASDec_TS24501Msg_PDUSessionIdentity (pctxt, &pvalue->pduSessIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode procTransIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "procTransIdent");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->procTransIdent, 8);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode msgType */

   RTXCTXTPUSHELEMNAME (pctxt, "msgType");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->msgType, 8);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode data */

   RTXCTXTPUSHELEMNAME (pctxt, "data");

   switch (pvalue->protoDiscr) {
      /* obj_EstablishRequest5G */
      case TS24501Msg_NAS5GProtoDiscr_sessMgmt5G:
      switch (pvalue->msgType) {
         /* obj_EstablishRequest5G */
         case ASN1V_ts24501Msg_st_EstablishRequest5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_EstablishRequest5G;

            pvalue->data.u.obj_EstablishRequest5G = rtxMemAllocType (pctxt, 
               TS24501Msg_EstablishRequest);

            if (pvalue->data.u.obj_EstablishRequest5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_EstablishRequest (pvalue->data.
               u.obj_EstablishRequest5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_EstablishRequest5G");

            ret = NASDec_TS24501Msg_EstablishRequest (pctxt, pvalue->data.
               u.obj_EstablishRequest5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_EstablishAccept5G */
         case ASN1V_ts24501Msg_st_EstablishAccept5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_EstablishAccept5G;

            pvalue->data.u.obj_EstablishAccept5G = rtxMemAllocType (pctxt, 
               TS24501Msg_EstablishAccept);

            if (pvalue->data.u.obj_EstablishAccept5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_EstablishAccept (pvalue->data.
               u.obj_EstablishAccept5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_EstablishAccept5G");

            ret = NASDec_TS24501Msg_EstablishAccept (pctxt, pvalue->data.
               u.obj_EstablishAccept5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_EstablishReject5G */
         case ASN1V_ts24501Msg_st_EstablishReject5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_EstablishReject5G;

            pvalue->data.u.obj_EstablishReject5G = rtxMemAllocType (pctxt, 
               TS24501Msg_EstablishReject);

            if (pvalue->data.u.obj_EstablishReject5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_EstablishReject (pvalue->data.
               u.obj_EstablishReject5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_EstablishReject5G");

            ret = NASDec_TS24501Msg_EstablishReject (pctxt, pvalue->data.
               u.obj_EstablishReject5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_SMAuthCmd5G */
         case ASN1V_ts24501Msg_st_AuthCmd5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_SMAuthCmd5G;

            pvalue->data.u.obj_SMAuthCmd5G = rtxMemAllocType (pctxt, 
               TS24501Msg_SMAuthCmd);

            if (pvalue->data.u.obj_SMAuthCmd5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_SMAuthCmd (pvalue->data.u.obj_SMAuthCmd5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SMAuthCmd5G");

            ret = NASDec_TS24501Msg_SMAuthCmd (pctxt, pvalue->data.
               u.obj_SMAuthCmd5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_SMAuthDone5G */
         case ASN1V_ts24501Msg_st_AuthDone5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_SMAuthDone5G;

            pvalue->data.u.obj_SMAuthDone5G = rtxMemAllocType (pctxt, 
               TS24501Msg_SMAuthDone);

            if (pvalue->data.u.obj_SMAuthDone5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_SMAuthDone (pvalue->data.u.obj_SMAuthDone5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SMAuthDone5G");

            ret = NASDec_TS24501Msg_SMAuthDone (pctxt, pvalue->data.
               u.obj_SMAuthDone5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_SMAuthResult5G */
         case ASN1V_ts24501Msg_st_AuthResult5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_SMAuthResult5G;

            pvalue->data.u.obj_SMAuthResult5G = rtxMemAllocType (pctxt, 
               TS24501Msg_SMAuthResult);

            if (pvalue->data.u.obj_SMAuthResult5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_SMAuthResult (pvalue->data.u.obj_SMAuthResult5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SMAuthResult5G");

            ret = NASDec_TS24501Msg_SMAuthResult (pctxt, pvalue->data.
               u.obj_SMAuthResult5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ModifyRequest5G */
         case ASN1V_ts24501Msg_st_ModifyRequest5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_ModifyRequest5G;

            pvalue->data.u.obj_ModifyRequest5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ModifyRequest);

            if (pvalue->data.u.obj_ModifyRequest5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ModifyRequest (pvalue->data.
               u.obj_ModifyRequest5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ModifyRequest5G");

            ret = NASDec_TS24501Msg_ModifyRequest (pctxt, pvalue->data.
               u.obj_ModifyRequest5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ModifyReject5G */
         case ASN1V_ts24501Msg_st_ModifyReject5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_ModifyReject5G;

            pvalue->data.u.obj_ModifyReject5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ModifyReject);

            if (pvalue->data.u.obj_ModifyReject5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ModifyReject (pvalue->data.u.obj_ModifyReject5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ModifyReject5G");

            ret = NASDec_TS24501Msg_ModifyReject (pctxt, pvalue->data.
               u.obj_ModifyReject5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ModifyCmd5G */
         case ASN1V_ts24501Msg_st_ModifyCmd5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_ModifyCmd5G;

            pvalue->data.u.obj_ModifyCmd5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ModifyCmd);

            if (pvalue->data.u.obj_ModifyCmd5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ModifyCmd (pvalue->data.u.obj_ModifyCmd5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ModifyCmd5G");

            ret = NASDec_TS24501Msg_ModifyCmd (pctxt, pvalue->data.
               u.obj_ModifyCmd5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ModifyDone5G */
         case ASN1V_ts24501Msg_st_ModifyDone5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_ModifyDone5G;

            pvalue->data.u.obj_ModifyDone5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ModifyDone);

            if (pvalue->data.u.obj_ModifyDone5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ModifyDone (pvalue->data.u.obj_ModifyDone5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ModifyDone5G");

            ret = NASDec_TS24501Msg_ModifyDone (pctxt, pvalue->data.
               u.obj_ModifyDone5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ModifyCmdReject5G */
         case ASN1V_ts24501Msg_st_ModifyCmdReject5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_ModifyCmdReject5G;

            pvalue->data.u.obj_ModifyCmdReject5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ModifyCmdReject);

            if (pvalue->data.u.obj_ModifyCmdReject5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ModifyCmdReject (pvalue->data.
               u.obj_ModifyCmdReject5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ModifyCmdReject5G");

            ret = NASDec_TS24501Msg_ModifyCmdReject (pctxt, pvalue->data.
               u.obj_ModifyCmdReject5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ReleaseRequest5G */
         case ASN1V_ts24501Msg_st_ReleaseRequest5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_ReleaseRequest5G;

            pvalue->data.u.obj_ReleaseRequest5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ReleaseRequest);

            if (pvalue->data.u.obj_ReleaseRequest5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ReleaseRequest (pvalue->data.
               u.obj_ReleaseRequest5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ReleaseRequest5G");

            ret = NASDec_TS24501Msg_ReleaseRequest (pctxt, pvalue->data.
               u.obj_ReleaseRequest5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ReleaseReject5G */
         case ASN1V_ts24501Msg_st_ReleaseReject5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_ReleaseReject5G;

            pvalue->data.u.obj_ReleaseReject5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ReleaseReject);

            if (pvalue->data.u.obj_ReleaseReject5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ReleaseReject (pvalue->data.
               u.obj_ReleaseReject5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ReleaseReject5G");

            ret = NASDec_TS24501Msg_ReleaseReject (pctxt, pvalue->data.
               u.obj_ReleaseReject5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ReleaseCmd5G */
         case ASN1V_ts24501Msg_st_ReleaseCmd5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_ReleaseCmd5G;

            pvalue->data.u.obj_ReleaseCmd5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ReleaseCmd);

            if (pvalue->data.u.obj_ReleaseCmd5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ReleaseCmd (pvalue->data.u.obj_ReleaseCmd5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ReleaseCmd5G");

            ret = NASDec_TS24501Msg_ReleaseCmd (pctxt, pvalue->data.
               u.obj_ReleaseCmd5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ReleaseDone5G */
         case ASN1V_ts24501Msg_st_ReleaseDone5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_ReleaseDone5G;

            pvalue->data.u.obj_ReleaseDone5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ReleaseDone);

            if (pvalue->data.u.obj_ReleaseDone5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ReleaseDone (pvalue->data.u.obj_ReleaseDone5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ReleaseDone5G");

            ret = NASDec_TS24501Msg_ReleaseDone (pctxt, pvalue->data.
               u.obj_ReleaseDone5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_SMStatus5G */
         case ASN1V_ts24501Msg_st_SMStatus5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_SMStatus5G;

            pvalue->data.u.obj_SMStatus5G = rtxMemAllocTypeZ (pctxt, 
               TS24501Msg_SMStatus);

            if (pvalue->data.u.obj_SMStatus5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SMStatus5G");

            ret = NASDec_TS24501Msg_SMStatus (pctxt, pvalue->data.
               u.obj_SMStatus5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERRNEW (pctxt,
               rtxErrInvUIntOpt (pctxt, pvalue->msgType));
            break;
      }

      break;

   /* obj_EstablishAccept5G */
   /* obj_EstablishReject5G */
   /* obj_SMAuthCmd5G */
   /* obj_SMAuthDone5G */
   /* obj_SMAuthResult5G */
   /* obj_ModifyRequest5G */
   /* obj_ModifyReject5G */
   /* obj_ModifyCmd5G */
   /* obj_ModifyDone5G */
   /* obj_ModifyCmdReject5G */
   /* obj_ReleaseRequest5G */
   /* obj_ReleaseReject5G */
   /* obj_ReleaseCmd5G */
   /* obj_ReleaseDone5G */
   /* obj_SMStatus5G */
   /* obj_ControlPlaneServReq5G */
   case TS24501Msg_NAS5GProtoDiscr_mobMgmt5G:
   switch (pvalue->msgType) {
      /* obj_ControlPlaneServReq5G */
      case ASN1V_ts24501Msg_mt_ControlPlaneServReq5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_ControlPlaneServReq5G;

         pvalue->data.u.obj_ControlPlaneServReq5G = rtxMemAllocType (pctxt, 
            TS24501Msg_ControlPlaneServReq);

         if (pvalue->data.u.obj_ControlPlaneServReq5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_ControlPlaneServReq (pvalue->data.
            u.obj_ControlPlaneServReq5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ControlPlaneServReq5G");

         ret = NASDec_TS24501Msg_ControlPlaneServReq (pctxt, pvalue->data.
            u.obj_ControlPlaneServReq5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_NetSliceAuthCmd5G */
      case ASN1V_ts24501Msg_mt_NetSliceAuthCmd5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_NetSliceAuthCmd5G;

         pvalue->data.u.obj_NetSliceAuthCmd5G = rtxMemAllocType (pctxt, 
            TS24501Msg_NetSliceAuthCmd);

         if (pvalue->data.u.obj_NetSliceAuthCmd5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_NetSliceAuthCmd (pvalue->data.
            u.obj_NetSliceAuthCmd5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_NetSliceAuthCmd5G");

         ret = NASDec_TS24501Msg_NetSliceAuthCmd (pctxt, pvalue->data.
            u.obj_NetSliceAuthCmd5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_NetSliceAuthDone5G */
      case ASN1V_ts24501Msg_mt_NetSliceAuthDone5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_NetSliceAuthDone5G;

         pvalue->data.u.obj_NetSliceAuthDone5G = rtxMemAllocType (pctxt, 
            TS24501Msg_NetSliceAuthDone);

         if (pvalue->data.u.obj_NetSliceAuthDone5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_NetSliceAuthDone (pvalue->data.
            u.obj_NetSliceAuthDone5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_NetSliceAuthDone5G");

         ret = NASDec_TS24501Msg_NetSliceAuthDone (pctxt, pvalue->data.
            u.obj_NetSliceAuthDone5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_NetSliceAuthResult5G */
      case ASN1V_ts24501Msg_mt_NetSliceAuthResult5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_SM_OBJECTSET_obj_NetSliceAuthResult5G;

         pvalue->data.u.obj_NetSliceAuthResult5G = rtxMemAllocType (pctxt, 
            TS24501Msg_NetSliceAuthResult);

         if (pvalue->data.u.obj_NetSliceAuthResult5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_NetSliceAuthResult (pvalue->data.
            u.obj_NetSliceAuthResult5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_NetSliceAuthResult5G");

         ret = NASDec_TS24501Msg_NetSliceAuthResult (pctxt, pvalue->data.
            u.obj_NetSliceAuthResult5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERRNEW (pctxt,
            rtxErrInvUIntOpt (pctxt, pvalue->msgType));
         break;
   }

   break;

/* obj_NetSliceAuthCmd5G */
/* obj_NetSliceAuthDone5G */
/* obj_NetSliceAuthResult5G */
default:
   return LOG_RTERRNEW (pctxt,
      rtxErrInvUIntOpt (pctxt, pvalue->protoDiscr));
   break;
}

RTXCTXTPOPELEMNAME (pctxt);

RTXCTXTPOPTYPENAME (pctxt);

return (ret);
}

EXTERN int NASDec_TS24501Msg_N1SMPayloadContainer (OSCTXT* pctxt
   , TS24501Msg_N1SMPayloadContainer* pvalue)
{
   OSSIZE endIndex;
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "N1SMPayloadContainer");

   /* decode length */

   RTXCTXTPUSHELEMNAME (pctxt, "length");
   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecUInt16 (pctxt, &pvalue->length, 2);
   if (0 != ret) return LOG_RTERR (pctxt, ret);
   endIndex = rtxCtxtGetBitOffset (pctxt) + (pvalue->length) * 8;

   ret = rtxCtxtPushContainerBytes(pctxt, pvalue->length);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pduSm */

   RTXCTXTPUSHELEMNAME (pctxt, "pduSm");

   ret = NASDec_TS24501Msg_PDU_SM (pctxt, &pvalue->pduSm);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   if (rtxCtxtGetBitOffset(pctxt) > endIndex)
      return LOG_RTERR (pctxt, RTERR_INVLEN);

   rtxCtxtSetBitOffset(pctxt, endIndex);
   rtxCtxtPopContainer(pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ULNASTrans (OSCTXT* pctxt
   , TS24501Msg_ULNASTrans* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULNASTrans");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode containerType */

   RTXCTXTPUSHELEMNAME (pctxt, "containerType");

   ret = NASDec_TS24501IE_PayloadContainerType (pctxt, &pvalue->containerType
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode container */

   RTXCTXTPUSHELEMNAME (pctxt, "container");

   /* Decode choice data value */

   switch (pvalue->containerType)
   {
      /* n1sm */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "n1sm");

	 /* AMF needs opaque n1sm container. */
         //ret = NASDec_TS24501Msg_N1SMPayloadContainer (pctxt, &pvalue->
         //   container.u.n1sm);

         ret = NASDec_TS24501IE_OpaqueData (pctxt, &pvalue->container.u.n1sm);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sms */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "sms");

         ret = NASDec_TS24501Msg_SMSMessage (pctxt, &pvalue->container.u.sms);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* lpp */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "lpp");

         ret = NASDec_TS24501IE_OpaqueData (pctxt, &pvalue->container.u.lpp);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sor */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "sor");

         ret = NASDec_TS24501IE_SORAck (pctxt, &pvalue->container.u.sor);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* uePolicy */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "uePolicy");

         ret = NASDec_TS24501IE_OpaqueData (pctxt, &pvalue->container.
            u.uePolicy);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* ueParamUpdate */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "ueParamUpdate");

         ret = NASDec_TS24501IE_UEParamUpdateAck (pctxt, &pvalue->container.
            u.ueParamUpdate);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* locSvcs */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "locSvcs");

         ret = NASDec_TS24501IE_OpaqueData (pctxt, &pvalue->container.u.locSvcs
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* cIOTUserData */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "cIOTUserData");

         ret = NASDec_TS24301IE_UserDataContainer (pctxt, &pvalue->container.
            u.cIOTUserData);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* multiple */
      case 15:
         RTXCTXTPUSHELEMNAME (pctxt, "multiple");

         ret = NASDec_TS24501IE_MultiPayloadContainer (pctxt, &pvalue->
            container.u.multiple);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 8 || nibble == 10 || nibble == 15) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 18: {
               if (lastRow == 0) {
                  /* decode pduSessionId */
                  RTXCTXTPUSHELEMNAME (pctxt, "pduSessionId");

                  ret = NASDec_TS24501IE_PDUSessionId2 (pctxt, &pvalue->
                     pduSessionId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pduSessionIdPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 89: {
               if (lastRow <= 1) {
                  /* decode oldPduSessionId */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldPduSessionId");

                  ret = NASDec_TS24501IE_PDUSessionId2 (pctxt, &pvalue->
                     oldPduSessionId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldPduSessionIdPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 8: {
               if (lastRow <= 2) {
                  /* decode requestType */
                  RTXCTXTPUSHELEMNAME (pctxt, "requestType");

                  ret = NASDec_TS24501IE_RequestType (pctxt, &pvalue->
                     requestType);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.requestTypePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 34: {
               if (lastRow <= 3) {
                  /* decode snssai */
                  RTXCTXTPUSHELEMNAME (pctxt, "snssai");

                  ret = NASDec_TS24501IE_SNSSAI (pctxt, &pvalue->snssai);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.snssaiPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 37: {
               if (lastRow <= 4) {
                  /* decode dnn */
                  RTXCTXTPUSHELEMNAME (pctxt, "dnn");

                  ret = NASDec_TS24501IE_DNNList (pctxt, &pvalue->dnn);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.dnnPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 36: {
               if (lastRow <= 5) {
                  /* decode addlInfo */
                  RTXCTXTPUSHELEMNAME (pctxt, "addlInfo");

                  ret = NASDec_TS24501IE_AdditionalInfo (pctxt, &pvalue->
                     addlInfo);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addlInfoPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 10: {
               if (lastRow <= 6) {
                  /* decode maPduSessionInfo */
                  RTXCTXTPUSHELEMNAME (pctxt, "maPduSessionInfo");

                  ret = NASDec_TS24501IE_MAPDUSessionInfo (pctxt, &pvalue->
                     maPduSessionInfo);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.maPduSessionInfoPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 15: {
               if (lastRow <= 7) {
                  /* decode relAssistInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "relAssistInd");

                  ret = NASDec_TS24301IE_ReleaseAssistInd (pctxt, &pvalue->
                     relAssistInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.relAssistIndPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_DLNASTrans (OSCTXT* pctxt
   , TS24501Msg_DLNASTrans* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DLNASTrans");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode containerType */

   RTXCTXTPUSHELEMNAME (pctxt, "containerType");

   ret = NASDec_TS24501IE_PayloadContainerType (pctxt, &pvalue->containerType
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode container */

   RTXCTXTPUSHELEMNAME (pctxt, "container");

   /* Decode choice data value */

   switch (pvalue->containerType)
   {
      /* n1sm */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "n1sm");

         //ret = NASDec_TS24501Msg_N1SMPayloadContainer (pctxt, &pvalue->
           // container.u.n1sm);
         ret = NASDec_TS24501IE_OpaqueData (pctxt, &pvalue->container.u.n1sm);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sms */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "sms");

         ret = NASDec_TS24501Msg_SMSMessage (pctxt, &pvalue->container.u.sms);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* lpp */
      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "lpp");

         ret = NASDec_TS24501IE_OpaqueData (pctxt, &pvalue->container.u.lpp);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sor */
      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "sor");

         ret = NASDec_TS24501IE_SORSteering (pctxt, &pvalue->container.u.sor);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* uePolicy */
      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "uePolicy");

         ret = NASDec_TS24501IE_OpaqueData (pctxt, &pvalue->container.
            u.uePolicy);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* ueParamUpdate */
      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "ueParamUpdate");

         ret = NASDec_TS24501IE_UEParamUpdate (pctxt, &pvalue->container.
            u.ueParamUpdate);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* locSvcs */
      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "locSvcs");

         ret = NASDec_TS24501IE_OpaqueData (pctxt, &pvalue->container.u.locSvcs
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* cIOTUserData */
      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "cIOTUserData");

         ret = NASDec_TS24301IE_UserDataContainer (pctxt, &pvalue->container.
            u.cIOTUserData);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* multiple */
      case 15:
         RTXCTXTPUSHELEMNAME (pctxt, "multiple");

         ret = NASDec_TS24501IE_MultiPayloadContainer (pctxt, &pvalue->
            container.u.multiple);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 18: {
               if (lastRow == 0) {
                  /* decode pduSessionId */
                  RTXCTXTPUSHELEMNAME (pctxt, "pduSessionId");

                  ret = NASDec_TS24501IE_PDUSessionId2 (pctxt, &pvalue->
                     pduSessionId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pduSessionIdPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 36: {
               if (lastRow <= 1) {
                  /* decode addlInfo */
                  RTXCTXTPUSHELEMNAME (pctxt, "addlInfo");

                  ret = NASDec_TS24501IE_AdditionalInfo (pctxt, &pvalue->
                     addlInfo);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addlInfoPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 88: {
               if (lastRow <= 2) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24501IE_MMCause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 55: {
               if (lastRow <= 3) {
                  /* decode backoffTimer */
                  RTXCTXTPUSHELEMNAME (pctxt, "backoffTimer");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->
                     backoffTimer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.backoffTimerPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_DeregReqUEOrig (OSCTXT* pctxt
   , TS24501Msg_DeregReqUEOrig* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeregReqUEOrig");

   /* decode nasKeySetIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdent");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->nasKeySetIdent
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deregType */

   RTXCTXTPUSHELEMNAME (pctxt, "deregType");

   ret = NASDec_TS24501IE_DeregistrationType (pctxt, &pvalue->deregType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileId */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileId");

   ret = NASDec_TS24501IE_MobileIdentity (pctxt, &pvalue->mobileId);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_DeregReqUETerm (OSCTXT* pctxt
   , TS24501Msg_DeregReqUETerm* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeregReqUETerm");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deregType */

   RTXCTXTPUSHELEMNAME (pctxt, "deregType");

   ret = NASDec_TS24501IE_DeregistrationType (pctxt, &pvalue->deregType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 88: {
               if (lastRow == 0) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24501IE_MMCause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 95: {
               if (lastRow <= 1) {
                  /* decode t3346 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3346");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3346);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3346Present = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 109: {
               if (lastRow <= 2) {
                  /* decode rejectedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "rejectedNSSAI");

                  ret = NASDec_TS24501IE_RejectedNSSAIList (pctxt, &pvalue->
                     rejectedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.rejectedNSSAIPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 117: {
               if (lastRow <= 3) {
                  /* decode cagInfoList */
                  RTXCTXTPUSHELEMNAME (pctxt, "cagInfoList");

                  ret = NASDec_TS24501IE_CAGInfoList (pctxt, &pvalue->
                     cagInfoList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.cagInfoListPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 104: {
               if (lastRow <= 4) {
                  /* decode extRejectedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "extRejectedNSSAI");

                  ret = NASDec_TS24501IE_ExtRejectedNSSAIList (pctxt, &pvalue->
                     extRejectedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extRejectedNSSAIPresent = 1;
                  pvalue->m._v17ExtPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ServRequest (OSCTXT* pctxt
   , TS24501Msg_ServRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ServRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode serviceType */

   RTXCTXTPUSHELEMNAME (pctxt, "serviceType");

   ret = NASDec_TS24501IE_ServiceType (pctxt, &pvalue->serviceType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nasKeySetIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdent");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->nasKeySetIdent
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode stmsi */

   RTXCTXTPUSHELEMNAME (pctxt, "stmsi");

   ret = NASDec_TS24501IE_MobileIdentity (pctxt, &pvalue->stmsi);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 64: {
               if (lastRow == 0) {
                  /* decode uplinkStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "uplinkStat");

                  ret = NASDec_TS24501IE_UplinkDataStatus (pctxt, &pvalue->
                     uplinkStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.uplinkStatPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 80: {
               if (lastRow <= 1) {
                  /* decode sessionStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "sessionStat");

                  ret = NASDec_TS24501IE_PDUSessionStatus (pctxt, &pvalue->
                     sessionStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.sessionStatPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 37: {
               if (lastRow <= 2) {
                  /* decode allowedSessionStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "allowedSessionStat");

                  ret = NASDec_TS24501IE_AllowedPDUSessionStatus (pctxt, &
                     pvalue->allowedSessionStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.allowedSessionStatPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 113: {
               if (lastRow <= 3) {
                  /* decode nasContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "nasContainer");

                  ret = NASDec_TS24501IE_NASMessageContainer2 (pctxt, &pvalue->
                     nasContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.nasContainerPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ServAccept (OSCTXT* pctxt
   , TS24501Msg_ServAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ServAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 80: {
               if (lastRow == 0) {
                  /* decode sessionStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "sessionStat");

                  ret = NASDec_TS24501IE_PDUSessionStatus (pctxt, &pvalue->
                     sessionStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.sessionStatPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 38: {
               if (lastRow <= 1) {
                  /* decode reactivateRslt */
                  RTXCTXTPUSHELEMNAME (pctxt, "reactivateRslt");

                  ret = NASDec_TS24501IE_SessionReactivateRslt (pctxt, &pvalue
                     ->reactivateRslt);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reactivateRsltPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 114: {
               if (lastRow <= 2) {
                  /* decode reactivateRsltCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "reactivateRsltCause");

                  ret = NASDec_TS24501IE_SessionReactivateCause (pctxt, &pvalue
                     ->reactivateRsltCause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reactivateRsltCausePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 120: {
               if (lastRow <= 3) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 107: {
               if (lastRow <= 4) {
                  /* decode t3448 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3448");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3448);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3448Present = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_ServReject (OSCTXT* pctxt
   , TS24501Msg_ServReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ServReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_MMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 80: {
               if (lastRow == 0) {
                  /* decode sessionStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "sessionStat");

                  ret = NASDec_TS24501IE_PDUSessionStatus (pctxt, &pvalue->
                     sessionStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.sessionStatPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 95: {
               if (lastRow <= 1) {
                  /* decode t3346 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3346");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3346);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3346Present = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 120: {
               if (lastRow <= 2) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 107: {
               if (lastRow <= 3) {
                  /* decode t3448 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3448");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3448);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3448Present = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 117: {
               if (lastRow <= 4) {
                  /* decode cagInfoList */
                  RTXCTXTPUSHELEMNAME (pctxt, "cagInfoList");

                  ret = NASDec_TS24501IE_CAGInfoList (pctxt, &pvalue->
                     cagInfoList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.cagInfoListPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_CfgUpdateCmd (OSCTXT* pctxt
   , TS24501Msg_CfgUpdateCmd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CfgUpdateCmd");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 13 || nibble == 11 || nibble == 9 || nibble == 15 || nibble == 10 || nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 13: {
               if (lastRow == 0) {
                  /* decode cfgUpdIndication */
                  RTXCTXTPUSHELEMNAME (pctxt, "cfgUpdIndication");

                  ret = NASDec_TS24501IE_ConfigUpdateIndication (pctxt, &pvalue
                     ->cfgUpdIndication);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.cfgUpdIndicationPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 119: {
               if (lastRow <= 1) {
                  /* decode guti */
                  RTXCTXTPUSHELEMNAME (pctxt, "guti");

                  ret = NASDec_TS24501IE_MobileIdentity (pctxt, &pvalue->guti
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.gutiPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 84: {
               if (lastRow <= 2) {
                  /* decode taiList */
                  RTXCTXTPUSHELEMNAME (pctxt, "taiList");

                  ret = NASDec_TS24501IE_TrackingAreaIdentList (pctxt, &pvalue
                     ->taiList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.taiListPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 21: {
               if (lastRow <= 3) {
                  /* decode allowedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "allowedNSSAI");

                  ret = NASDec_TS24501IE_NSSAI (pctxt, &pvalue->allowedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.allowedNSSAIPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 4) {
                  /* decode svcAreaList */
                  RTXCTXTPUSHELEMNAME (pctxt, "svcAreaList");

                  ret = NASDec_TS24501IE_TrackingAreaIdentList (pctxt, &pvalue
                     ->svcAreaList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.svcAreaListPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 67: {
               if (lastRow <= 5) {
                  /* decode fullNetworkName */
                  RTXCTXTPUSHELEMNAME (pctxt, "fullNetworkName");

                  ret = NASDec_TS24008IE_NetworkName (pctxt, &pvalue->
                     fullNetworkName);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.fullNetworkNamePresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 69: {
               if (lastRow <= 6) {
                  /* decode shortNetworkName */
                  RTXCTXTPUSHELEMNAME (pctxt, "shortNetworkName");

                  ret = NASDec_TS24008IE_NetworkName (pctxt, &pvalue->
                     shortNetworkName);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.shortNetworkNamePresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 70: {
               if (lastRow <= 7) {
                  /* decode localTZ */
                  RTXCTXTPUSHELEMNAME (pctxt, "localTZ");

                  ret = NASDec_TS24008IE_TimeZone (pctxt, &pvalue->localTZ);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.localTZPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 71: {
               if (lastRow <= 8) {
                  /* decode univAndLocalTZ */
                  RTXCTXTPUSHELEMNAME (pctxt, "univAndLocalTZ");

                  ret = NASDec_TS24008IE_TimeZoneAndTime (pctxt, &pvalue->
                     univAndLocalTZ);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.univAndLocalTZPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 7;
               }
               break;
            }
            case 73: {
               if (lastRow <= 9) {
                  /* decode dst */
                  RTXCTXTPUSHELEMNAME (pctxt, "dst");

                  ret = NASDec_TS24008IE_DaylightSavingTime (pctxt, &pvalue->
                     dst);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.dstPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 121: {
               if (lastRow <= 10) {
                  /* decode ladn */
                  RTXCTXTPUSHELEMNAME (pctxt, "ladn");

                  ret = NASDec_TS24501IE_LADNList (pctxt, &pvalue->ladn);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ladnPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 11: {
               if (lastRow <= 11) {
                  /* decode micoInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "micoInd");

                  ret = NASDec_TS24501IE_MICOIndication (pctxt, &pvalue->
                     micoInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.micoIndPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 9: {
               if (lastRow <= 12) {
                  /* decode netSliceInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "netSliceInd");

                  ret = NASDec_TS24501IE_NetSliceIndication (pctxt, &pvalue->
                     netSliceInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.netSliceIndPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 49: {
               if (lastRow <= 13) {
                  /* decode configuredNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "configuredNSSAI");

                  ret = NASDec_TS24501IE_NSSAI (pctxt, &pvalue->configuredNSSAI
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.configuredNSSAIPresent = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 17: {
               if (lastRow <= 14) {
                  /* decode rejectedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "rejectedNSSAI");

                  ret = NASDec_TS24501IE_RejectedNSSAIList (pctxt, &pvalue->
                     rejectedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.rejectedNSSAIPresent = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 118: {
               if (lastRow <= 15) {
                  /* decode accessDefs */
                  RTXCTXTPUSHELEMNAME (pctxt, "accessDefs");

                  ret = NASDec_TS24501IE_AccessCategoryDefinitions (pctxt, &
                     pvalue->accessDefs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.accessDefsPresent = 1;

                  lastRow = 16;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 15: {
               if (lastRow <= 16) {
                  /* decode smsInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "smsInd");

                  ret = NASDec_TS24501IE_SMSIndication (pctxt, &pvalue->smsInd
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.smsIndPresent = 1;

                  lastRow = 17;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 108: {
               if (lastRow <= 17) {
                  /* decode t3447 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3447");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3447);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3447Present = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 18;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 117: {
               if (lastRow <= 18) {
                  /* decode cagInfoList */
                  RTXCTXTPUSHELEMNAME (pctxt, "cagInfoList");

                  ret = NASDec_TS24501IE_CAGInfoList (pctxt, &pvalue->
                     cagInfoList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.cagInfoListPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 19;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 103: {
               if (lastRow <= 19) {
                  /* decode ueRadioCapabilityId */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueRadioCapabilityId");

                  ret = NASDec_TS24301IE_UERadioCapId (pctxt, &pvalue->
                     ueRadioCapabilityId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueRadioCapabilityIdPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 20;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 10: {
               if (lastRow <= 20) {
                  /* decode ueRadioCapIdDeletionIndication */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueRadioCapIdDeletionIndication");

                  ret = NASDec_TS24301IE_UERadioCapIdDeletionInd (pctxt, &
                     pvalue->ueRadioCapIdDeletionIndication);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueRadioCapIdDeletionIndicationPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 21;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 68: {
               if (lastRow <= 21) {
                  /* decode regResult */
                  RTXCTXTPUSHELEMNAME (pctxt, "regResult");

                  ret = NASDec_TS24501IE_RegistrationResult (pctxt, &pvalue->
                     regResult);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.regResultPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 22;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 27: {
               if (lastRow <= 22) {
                  /* decode truncatedConfig */
                  RTXCTXTPUSHELEMNAME (pctxt, "truncatedConfig");

                  ret = NASDec_TS24501IE_TruncatedTMSIConfig (pctxt, &pvalue->
                     truncatedConfig);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.truncatedConfigPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 23;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 12: {
               if (lastRow <= 23) {
                  /* decode additionalConfigIndication */
                  RTXCTXTPUSHELEMNAME (pctxt, "additionalConfigIndication");

                  ret = NASDec_TS24501IE_AddlConfigIndication (pctxt, &pvalue->
                     additionalConfigIndication);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.additionalConfigIndicationPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 24;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 104: {
               if (lastRow <= 24) {
                  /* decode extRejectedNSSAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "extRejectedNSSAI");

                  ret = NASDec_TS24501IE_ExtRejectedNSSAIList (pctxt, &pvalue->
                     extRejectedNSSAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.extRejectedNSSAIPresent = 1;
                  pvalue->m._v17ExtPresent = 1;

                  lastRow = 25;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_IdentityRequest (OSCTXT* pctxt
   , TS24501Msg_IdentityRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IdentityRequest");

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode identity */

   RTXCTXTPUSHELEMNAME (pctxt, "identity");

   ret = NASDec_TS24501IE_IdentityType (pctxt, &pvalue->identity);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_IdentityResponse (OSCTXT* pctxt
   , TS24501Msg_IdentityResponse* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IdentityResponse");

   /* decode mobileId */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileId");

   ret = NASDec_TS24501IE_MobileIdentity (pctxt, &pvalue->mobileId);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_Notify (OSCTXT* pctxt, TS24501Msg_Notify* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Notify");

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode access */

   RTXCTXTPUSHELEMNAME (pctxt, "access");

   ret = NASDec_TS24501IE_AccessType (pctxt, &pvalue->access_);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_NotifyResponse (OSCTXT* pctxt
   , TS24501Msg_NotifyResponse* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NotifyResponse");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 80: {
               if (lastRow == 0) {
                  /* decode sessionStat */
                  RTXCTXTPUSHELEMNAME (pctxt, "sessionStat");

                  ret = NASDec_TS24501IE_PDUSessionStatus (pctxt, &pvalue->
                     sessionStat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.sessionStatPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_SecModeCmd (OSCTXT* pctxt
   , TS24501Msg_SecModeCmd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecModeCmd");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode nasSecAlgorithm */

   RTXCTXTPUSHELEMNAME (pctxt, "nasSecAlgorithm");

   ret = NASDec_TS24501IE_NASSecurityAlgorithm (pctxt, &pvalue->nasSecAlgorithm
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nasKeySetIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdent");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->nasKeySetIdent
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode replayedUECapabilities */

   RTXCTXTPUSHELEMNAME (pctxt, "replayedUECapabilities");

   ret = NASDec_TS24501IE_UESecurityCapability (pctxt, &pvalue->
      replayedUECapabilities);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 14) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 14: {
               if (lastRow == 0) {
                  /* decode imeisvReq */
                  RTXCTXTPUSHELEMNAME (pctxt, "imeisvReq");

                  ret = NASDec_TS24008IE_IMEISVRequest (pctxt, &pvalue->
                     imeisvReq);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.imeisvReqPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 87: {
               if (lastRow <= 1) {
                  /* decode epsSecAlgorithm */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsSecAlgorithm");

                  ret = NASDec_TS24301IE_NASSecurityAlgorithms (pctxt, &pvalue
                     ->epsSecAlgorithm);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsSecAlgorithmPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 54: {
               if (lastRow <= 2) {
                  /* decode addlSecInfo */
                  RTXCTXTPUSHELEMNAME (pctxt, "addlSecInfo");

                  ret = NASDec_TS24501IE_AddlSecurityInfo (pctxt, &pvalue->
                     addlSecInfo);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addlSecInfoPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 120: {
               if (lastRow <= 3) {
                  /* decode eapMessage */
                  RTXCTXTPUSHELEMNAME (pctxt, "eapMessage");

                  ret = NASDec_TS24501IE_EAPMessage (pctxt, &pvalue->eapMessage
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eapMessagePresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 56: {
               if (lastRow <= 4) {
                  /* decode abba */
                  RTXCTXTPUSHELEMNAME (pctxt, "abba");

                  ret = NASDec_TS24501IE_ABBA (pctxt, &pvalue->abba);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.abbaPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 25: {
               if (lastRow <= 5) {
                  /* decode replayedS1UECapabilities */
                  RTXCTXTPUSHELEMNAME (pctxt, "replayedS1UECapabilities");

                  ret = NASDec_TS24501IE_UESecurityCapability (pctxt, &pvalue->
                     replayedS1UECapabilities);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.replayedS1UECapabilitiesPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_SecModeDone (OSCTXT* pctxt
   , TS24501Msg_SecModeDone* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecModeDone");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (rtxCtxtContainerHasRemBits(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 119: {
               if (lastRow == 0) {
                  /* decode imeisv */
                  RTXCTXTPUSHELEMNAME (pctxt, "imeisv");

                  ret = NASDec_TS24501IE_MobileIdentity (pctxt, &pvalue->imeisv
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.imeisvPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 113: {
               if (lastRow <= 1) {
                  /* decode nasMsgContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "nasMsgContainer");

                  ret = NASDec_TS24501IE_NASMessageContainer2 (pctxt, &pvalue->
                     nasMsgContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.nasMsgContainerPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 120: {
               if (lastRow <= 2) {
                  /* decode nonImeisvPei */
                  RTXCTXTPUSHELEMNAME (pctxt, "nonImeisvPei");

                  ret = NASDec_TS24501IE_MobileIdentity (pctxt, &pvalue->
                     nonImeisvPei);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.nonImeisvPeiPresent = 1;
                  pvalue->m._v16ExtPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBytes (pctxt, skipBytes);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_SecModeReject (OSCTXT* pctxt
   , TS24501Msg_SecModeReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecModeReject");

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_MMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_MMStatus (OSCTXT* pctxt
   , TS24501Msg_MMStatus* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MMStatus");

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24501IE_MMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24501Msg_PDU (OSCTXT* pctxt, TS24501Msg_PDU* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDU");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode secHdr */

   /* begin custom source file TS24501MsgDec_PDU_secHdr.c */

   /* start custom code */
   {
      OSRTBufSave savedBuf;
   
      rtxDiagSetBitFldDisabled (pctxt->pBitFldList, TRUE);
   
      /* Save context location (at begin of message, at extended protocol
         discriminator, and then restore below prior to decoding the security
         header, if present... */
      OSRTBUFSAVE2 (pctxt, &savedBuf);
   
      /* decode extended protocol discriminatory */
      ret = NASDec_TS24501Msg_NAS5GProtoDiscr (pctxt, &pvalue->secHdr.protoDiscr);
      if (0 != ret) return LOG_RTERR (pctxt, ret);
   
      /* only decode security header if this is not a plain message... */
      if (pvalue->secHdr.protoDiscr == TS24501Msg_NAS5GProtoDiscr_mobMgmt5G)
      {
         /* skip spare bits */
         ret = rtxSkipBits (pctxt, 4);
         if (0 != ret) return LOG_RTERR (pctxt, ret);
   
         /* decode security header type */
         ret = NASDec_TS24501Msg_NAS5GSecHdrType (pctxt, &pvalue->secHdr.secHdrType);
         if (0 != ret) return LOG_RTERR (pctxt, ret);
      }
   
      /* Restore context location to begin of message, at extended protocol
         discriminator, so that we can fully decode the security header... */
      OSRTBUFRESTORE2 (pctxt, &savedBuf);
      rtxDiagSetBitFldDisabled (pctxt->pBitFldList, FALSE);
   
      if ((pvalue->secHdr.secHdrType != TS24501Msg_NAS5GSecHdrType_noSec) && 
          (pvalue->secHdr.protoDiscr == TS24501Msg_NAS5GProtoDiscr_mobMgmt5G))
      {
         RTXCTXTPUSHELEMNAME (pctxt, "secHdr");
   
         ret = NASDec_TS24501Msg_NAS5GSecProtMsgHdr (pctxt, &pvalue->secHdr);
         if (ret < 0) return LOG_RTERR (pctxt, ret);
   
         pvalue->m.secHdrPresent = 1;
   
         RTXCTXTPOPELEMNAME (pctxt);
      }
   
      if (pvalue->m.secHdrPresent && 
          pvalue->secHdr.secHdrType != TS24501Msg_NAS5GSecHdrType_noSec)
      {
         OSOCTET* msg;
         OSSIZE   msgLen;
         OSUINT32 mac;
         
         /* Compute the MAC on the (possibly ciphered) plain message.
            Integrity protection applies to everything but the first 6 octets */
         msg = pctxt->buffer.data + savedBuf.byteIndex + 6;
         msgLen = pctxt->buffer.size - savedBuf.byteIndex - 6;
   
         ret = rtx3gppComputeMAC(pctxt, msg, msgLen, &mac);
         if (ret < 0) LOG_RTERR (pctxt, ret);            
         else {
            //check computed mac and expected mac agree
            if ( mac != pvalue->secHdr.msgAuthCode ) {
               rtxErrAddUIntParm(pctxt, pvalue->secHdr.msgAuthCode);
               rtxErrAddUIntParm(pctxt, mac); 
               LOG_RTERRNEW(pctxt, RTERR_INVMAC);
            }
         }
         
         if (pvalue->secHdr.secHdrType == 
                TS24501Msg_NAS5GSecHdrType_integProtAndCipher ||
             pvalue->secHdr.secHdrType == 
                TS24501Msg_NAS5GSecHdrType_integProtAndCipherAnd5GSecCtxt)
         {
            /* Decrypt the message in place.
               The first 7 bytes are the security protected message fields. 
               The plain message follows that. */
            msg = pctxt->buffer.data + savedBuf.byteIndex + 7;
            msgLen = pctxt->buffer.size - savedBuf.byteIndex - 7;
   
            ret = rtx3gppCipher(pctxt, msg, msgLen);
            
            if (ret < 0) return LOG_RTERR (pctxt, ret);   
         }            
      }
   }
   /* end custom code */

   /* end custom source file TS24501MsgDec_PDU_secHdr.c */

   /* decode protoDiscr */

   RTXCTXTPUSHELEMNAME (pctxt, "protoDiscr");

   ret = NASDec_TS24501Msg_NAS5GProtoDiscr (pctxt, &pvalue->protoDiscr);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode hdrData */

   RTXCTXTPUSHELEMNAME (pctxt, "hdrData");

   /* Decode choice data value */

   switch (pvalue->protoDiscr)
   {
      /* mm */
      case 126:
         RTXCTXTPUSHELEMNAME (pctxt, "mm");

         /* decode spare1 */

         RTXCTXTPUSHELEMNAME (pctxt, "spare1");

         RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

         ret = rtxDecBitsToByte (pctxt, &pvalue->hdrData.u.mm.spare1, 4);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         RTXCTXTPOPELEMNAME (pctxt);

         /* decode secHdrType */

         RTXCTXTPUSHELEMNAME (pctxt, "secHdrType");

         ret = NASDec_TS24501Msg_NAS5GSecHdrType (pctxt, &pvalue->hdrData.u.mm.
            secHdrType);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sm */
      case 46:
         RTXCTXTPUSHELEMNAME (pctxt, "sm");

         /* decode pduSessIdent */

         RTXCTXTPUSHELEMNAME (pctxt, "pduSessIdent");

         ret = NASDec_TS24501Msg_PDUSessionIdentity (pctxt, &pvalue->hdrData.
            u.sm.pduSessIdent);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         /* decode procTransIdent */

         RTXCTXTPUSHELEMNAME (pctxt, "procTransIdent");

         RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

         ret = rtxDecBitsToByte (pctxt, &pvalue->hdrData.u.sm.procTransIdent, 8);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         RTXCTXTPOPELEMNAME (pctxt);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode msgType */

   RTXCTXTPUSHELEMNAME (pctxt, "msgType");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->msgType, 8);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode data */

   RTXCTXTPUSHELEMNAME (pctxt, "data");

   switch (pvalue->protoDiscr) {
      /* obj_MMAuthRequest5G */
      case TS24501Msg_NAS5GProtoDiscr_mobMgmt5G:
      switch (pvalue->msgType) {
         /* obj_MMAuthRequest5G */
         case ASN1V_ts24501Msg_mt_AuthRequest5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_MMAuthRequest5G;

            pvalue->data.u.obj_MMAuthRequest5G = rtxMemAllocType (pctxt, 
               TS24501Msg_AuthRequest);

            if (pvalue->data.u.obj_MMAuthRequest5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_AuthRequest (pvalue->data.u.obj_MMAuthRequest5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_MMAuthRequest5G");

            ret = NASDec_TS24501Msg_AuthRequest (pctxt, pvalue->data.
               u.obj_MMAuthRequest5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_MMAuthResponse5G */
         case ASN1V_ts24501Msg_mt_AuthResponse5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_MMAuthResponse5G;

            pvalue->data.u.obj_MMAuthResponse5G = rtxMemAllocType (pctxt, 
               TS24501Msg_AuthResponse);

            if (pvalue->data.u.obj_MMAuthResponse5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_AuthResponse (pvalue->data.
               u.obj_MMAuthResponse5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_MMAuthResponse5G");

            ret = NASDec_TS24501Msg_AuthResponse (pctxt, pvalue->data.
               u.obj_MMAuthResponse5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_MMAuthResult5G */
         case ASN1V_ts24501Msg_mt_AuthResult5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_MMAuthResult5G;

            pvalue->data.u.obj_MMAuthResult5G = rtxMemAllocType (pctxt, 
               TS24501Msg_AuthResult);

            if (pvalue->data.u.obj_MMAuthResult5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_AuthResult (pvalue->data.u.obj_MMAuthResult5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_MMAuthResult5G");

            ret = NASDec_TS24501Msg_AuthResult (pctxt, pvalue->data.
               u.obj_MMAuthResult5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_MMAuthFailure5G */
         case ASN1V_ts24501Msg_mt_AuthFailure5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_MMAuthFailure5G;

            pvalue->data.u.obj_MMAuthFailure5G = rtxMemAllocType (pctxt, 
               TS24501Msg_AuthFailure);

            if (pvalue->data.u.obj_MMAuthFailure5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_AuthFailure (pvalue->data.u.obj_MMAuthFailure5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_MMAuthFailure5G");

            ret = NASDec_TS24501Msg_AuthFailure (pctxt, pvalue->data.
               u.obj_MMAuthFailure5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_MMAuthReject5G */
         case ASN1V_ts24501Msg_mt_AuthReject5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_MMAuthReject5G;

            pvalue->data.u.obj_MMAuthReject5G = rtxMemAllocType (pctxt, 
               TS24501Msg_AuthReject);

            if (pvalue->data.u.obj_MMAuthReject5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_AuthReject (pvalue->data.u.obj_MMAuthReject5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_MMAuthReject5G");

            ret = NASDec_TS24501Msg_AuthReject (pctxt, pvalue->data.
               u.obj_MMAuthReject5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_RegRequest5G */
         case ASN1V_ts24501Msg_mt_RegRequest5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_RegRequest5G;

            pvalue->data.u.obj_RegRequest5G = rtxMemAllocType (pctxt, 
               TS24501Msg_RegRequest);

            if (pvalue->data.u.obj_RegRequest5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_RegRequest (pvalue->data.u.obj_RegRequest5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_RegRequest5G");

            ret = NASDec_TS24501Msg_RegRequest (pctxt, pvalue->data.
               u.obj_RegRequest5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_RegAccept5G */
         case ASN1V_ts24501Msg_mt_RegAccept5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_RegAccept5G;

            pvalue->data.u.obj_RegAccept5G = rtxMemAllocType (pctxt, 
               TS24501Msg_RegAccept);

            if (pvalue->data.u.obj_RegAccept5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_RegAccept (pvalue->data.u.obj_RegAccept5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_RegAccept5G");

            ret = NASDec_TS24501Msg_RegAccept (pctxt, pvalue->data.
               u.obj_RegAccept5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_RegComplete5G */
         case ASN1V_ts24501Msg_mt_RegComplete5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_RegComplete5G;

            pvalue->data.u.obj_RegComplete5G = rtxMemAllocType (pctxt, 
               TS24501Msg_RegComplete);

            if (pvalue->data.u.obj_RegComplete5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_RegComplete (pvalue->data.u.obj_RegComplete5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_RegComplete5G");

            ret = NASDec_TS24501Msg_RegComplete (pctxt, pvalue->data.
               u.obj_RegComplete5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_RegReject5G */
         case ASN1V_ts24501Msg_mt_RegReject5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_RegReject5G;

            pvalue->data.u.obj_RegReject5G = rtxMemAllocType (pctxt, 
               TS24501Msg_RegReject);

            if (pvalue->data.u.obj_RegReject5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_RegReject (pvalue->data.u.obj_RegReject5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_RegReject5G");

            ret = NASDec_TS24501Msg_RegReject (pctxt, pvalue->data.
               u.obj_RegReject5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ULNASTrans5G */
         case ASN1V_ts24501Msg_mt_ULNASTrans5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ULNASTrans5G;

            pvalue->data.u.obj_ULNASTrans5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ULNASTrans);

            if (pvalue->data.u.obj_ULNASTrans5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ULNASTrans (pvalue->data.u.obj_ULNASTrans5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ULNASTrans5G");

            ret = NASDec_TS24501Msg_ULNASTrans (pctxt, pvalue->data.
               u.obj_ULNASTrans5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_DLNASTrans5G */
         case ASN1V_ts24501Msg_mt_DLNASTrans5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_DLNASTrans5G;

            pvalue->data.u.obj_DLNASTrans5G = rtxMemAllocType (pctxt, 
               TS24501Msg_DLNASTrans);

            if (pvalue->data.u.obj_DLNASTrans5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_DLNASTrans (pvalue->data.u.obj_DLNASTrans5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_DLNASTrans5G");

            ret = NASDec_TS24501Msg_DLNASTrans (pctxt, pvalue->data.
               u.obj_DLNASTrans5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_DeregReqUEOrig5G */
         case ASN1V_ts24501Msg_mt_DeregReqUEOrig5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_DeregReqUEOrig5G;

            pvalue->data.u.obj_DeregReqUEOrig5G = rtxMemAllocType (pctxt, 
               TS24501Msg_DeregReqUEOrig);

            if (pvalue->data.u.obj_DeregReqUEOrig5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_DeregReqUEOrig (pvalue->data.
               u.obj_DeregReqUEOrig5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_DeregReqUEOrig5G");

            ret = NASDec_TS24501Msg_DeregReqUEOrig (pctxt, pvalue->data.
               u.obj_DeregReqUEOrig5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_DeregAcceptUEOrig5G */
         case ASN1V_ts24501Msg_mt_DeregAcceptUEOrig5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_DeregAcceptUEOrig5G;

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_DeregAcceptUEOrig5G");

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_DeregReqUETerm5G */
         case ASN1V_ts24501Msg_mt_DeregReqUETerm5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_DeregReqUETerm5G;

            pvalue->data.u.obj_DeregReqUETerm5G = rtxMemAllocType (pctxt, 
               TS24501Msg_DeregReqUETerm);

            if (pvalue->data.u.obj_DeregReqUETerm5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_DeregReqUETerm (pvalue->data.
               u.obj_DeregReqUETerm5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_DeregReqUETerm5G");

            ret = NASDec_TS24501Msg_DeregReqUETerm (pctxt, pvalue->data.
               u.obj_DeregReqUETerm5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_DeregAcceptUETerm5G */
         case ASN1V_ts24501Msg_mt_DeregAcceptUETerm5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_DeregAcceptUETerm5G;

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_DeregAcceptUETerm5G");

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ServRequest5G */
         case ASN1V_ts24501Msg_mt_ServRequest5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ServRequest5G;

            pvalue->data.u.obj_ServRequest5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ServRequest);

            if (pvalue->data.u.obj_ServRequest5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ServRequest (pvalue->data.u.obj_ServRequest5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ServRequest5G");

            ret = NASDec_TS24501Msg_ServRequest (pctxt, pvalue->data.
               u.obj_ServRequest5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ServAccept5G */
         case ASN1V_ts24501Msg_mt_ServAccept5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ServAccept5G;

            pvalue->data.u.obj_ServAccept5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ServAccept);

            if (pvalue->data.u.obj_ServAccept5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ServAccept (pvalue->data.u.obj_ServAccept5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ServAccept5G");

            ret = NASDec_TS24501Msg_ServAccept (pctxt, pvalue->data.
               u.obj_ServAccept5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ServReject5G */
         case ASN1V_ts24501Msg_mt_ServReject5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ServReject5G;

            pvalue->data.u.obj_ServReject5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ServReject);

            if (pvalue->data.u.obj_ServReject5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ServReject (pvalue->data.u.obj_ServReject5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ServReject5G");

            ret = NASDec_TS24501Msg_ServReject (pctxt, pvalue->data.
               u.obj_ServReject5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_CfgUpdateCmd5G */
         case ASN1V_ts24501Msg_mt_CfgUpdateCmd5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_CfgUpdateCmd5G;

            pvalue->data.u.obj_CfgUpdateCmd5G = rtxMemAllocType (pctxt, 
               TS24501Msg_CfgUpdateCmd);

            if (pvalue->data.u.obj_CfgUpdateCmd5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_CfgUpdateCmd (pvalue->data.u.obj_CfgUpdateCmd5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_CfgUpdateCmd5G");

            ret = NASDec_TS24501Msg_CfgUpdateCmd (pctxt, pvalue->data.
               u.obj_CfgUpdateCmd5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_CfgUpdateDone5G */
         case ASN1V_ts24501Msg_mt_CfgUpdateDone5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_CfgUpdateDone5G;

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_CfgUpdateDone5G");

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_IdentityRequest5G */
         case ASN1V_ts24501Msg_mt_IdentityRequest5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_IdentityRequest5G;

            pvalue->data.u.obj_IdentityRequest5G = rtxMemAllocType (pctxt, 
               TS24501Msg_IdentityRequest);

            if (pvalue->data.u.obj_IdentityRequest5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_IdentityRequest (pvalue->data.
               u.obj_IdentityRequest5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_IdentityRequest5G");

            ret = NASDec_TS24501Msg_IdentityRequest (pctxt, pvalue->data.
               u.obj_IdentityRequest5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_IdentityResponse5G */
         case ASN1V_ts24501Msg_mt_IdentityResponse5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_IdentityResponse5G;

            pvalue->data.u.obj_IdentityResponse5G = rtxMemAllocType (pctxt, 
               TS24501Msg_IdentityResponse);

            if (pvalue->data.u.obj_IdentityResponse5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_IdentityResponse (pvalue->data.
               u.obj_IdentityResponse5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_IdentityResponse5G");

            ret = NASDec_TS24501Msg_IdentityResponse (pctxt, pvalue->data.
               u.obj_IdentityResponse5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_Notify5G */
         case ASN1V_ts24501Msg_mt_Notify5G:
            pvalue->data.t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_Notify5G;

            pvalue->data.u.obj_Notify5G = rtxMemAllocType (pctxt, 
               TS24501Msg_Notify);

            if (pvalue->data.u.obj_Notify5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_Notify (pvalue->data.u.obj_Notify5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_Notify5G");

            ret = NASDec_TS24501Msg_Notify (pctxt, pvalue->data.u.obj_Notify5G
               );
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_NotifyResponse5G */
         case ASN1V_ts24501Msg_mt_NotifyResponse5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_NotifyResponse5G;

            pvalue->data.u.obj_NotifyResponse5G = rtxMemAllocType (pctxt, 
               TS24501Msg_NotifyResponse);

            if (pvalue->data.u.obj_NotifyResponse5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_NotifyResponse (pvalue->data.
               u.obj_NotifyResponse5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_NotifyResponse5G");

            ret = NASDec_TS24501Msg_NotifyResponse (pctxt, pvalue->data.
               u.obj_NotifyResponse5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_SecModeCmd5G */
         case ASN1V_ts24501Msg_mt_SecModeCmd5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_SecModeCmd5G;

            pvalue->data.u.obj_SecModeCmd5G = rtxMemAllocType (pctxt, 
               TS24501Msg_SecModeCmd);

            if (pvalue->data.u.obj_SecModeCmd5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_SecModeCmd (pvalue->data.u.obj_SecModeCmd5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SecModeCmd5G");

            ret = NASDec_TS24501Msg_SecModeCmd (pctxt, pvalue->data.
               u.obj_SecModeCmd5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_SecModeDone5G */
         case ASN1V_ts24501Msg_mt_SecModeDone5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_SecModeDone5G;

            pvalue->data.u.obj_SecModeDone5G = rtxMemAllocType (pctxt, 
               TS24501Msg_SecModeDone);

            if (pvalue->data.u.obj_SecModeDone5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_SecModeDone (pvalue->data.u.obj_SecModeDone5G
               );

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SecModeDone5G");

            ret = NASDec_TS24501Msg_SecModeDone (pctxt, pvalue->data.
               u.obj_SecModeDone5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_SecModeReject5G */
         case ASN1V_ts24501Msg_mt_SecModeReject5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_SecModeReject5G;

            pvalue->data.u.obj_SecModeReject5G = rtxMemAllocTypeZ (pctxt, 
               TS24501Msg_SecModeReject);

            if (pvalue->data.u.obj_SecModeReject5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SecModeReject5G");

            ret = NASDec_TS24501Msg_SecModeReject (pctxt, pvalue->data.
               u.obj_SecModeReject5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_MMStatus5G */
         case ASN1V_ts24501Msg_mt_MMStatus5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_MMStatus5G;

            pvalue->data.u.obj_MMStatus5G = rtxMemAllocTypeZ (pctxt, 
               TS24501Msg_MMStatus);

            if (pvalue->data.u.obj_MMStatus5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_MMStatus5G");

            ret = NASDec_TS24501Msg_MMStatus (pctxt, pvalue->data.
               u.obj_MMStatus5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_ControlPlaneServReq5G */
         case ASN1V_ts24501Msg_mt_ControlPlaneServReq5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ControlPlaneServReq5G;

            pvalue->data.u.obj_ControlPlaneServReq5G = rtxMemAllocType (pctxt, 
               TS24501Msg_ControlPlaneServReq);

            if (pvalue->data.u.obj_ControlPlaneServReq5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_ControlPlaneServReq (pvalue->data.
               u.obj_ControlPlaneServReq5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ControlPlaneServReq5G");

            ret = NASDec_TS24501Msg_ControlPlaneServReq (pctxt, pvalue->data.
               u.obj_ControlPlaneServReq5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_NetSliceAuthCmd5G */
         case ASN1V_ts24501Msg_mt_NetSliceAuthCmd5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_NetSliceAuthCmd5G;

            pvalue->data.u.obj_NetSliceAuthCmd5G = rtxMemAllocType (pctxt, 
               TS24501Msg_NetSliceAuthCmd);

            if (pvalue->data.u.obj_NetSliceAuthCmd5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_NetSliceAuthCmd (pvalue->data.
               u.obj_NetSliceAuthCmd5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_NetSliceAuthCmd5G");

            ret = NASDec_TS24501Msg_NetSliceAuthCmd (pctxt, pvalue->data.
               u.obj_NetSliceAuthCmd5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_NetSliceAuthDone5G */
         case ASN1V_ts24501Msg_mt_NetSliceAuthDone5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_NetSliceAuthDone5G;

            pvalue->data.u.obj_NetSliceAuthDone5G = rtxMemAllocType (pctxt, 
               TS24501Msg_NetSliceAuthDone);

            if (pvalue->data.u.obj_NetSliceAuthDone5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_NetSliceAuthDone (pvalue->data.
               u.obj_NetSliceAuthDone5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_NetSliceAuthDone5G");

            ret = NASDec_TS24501Msg_NetSliceAuthDone (pctxt, pvalue->data.
               u.obj_NetSliceAuthDone5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* obj_NetSliceAuthResult5G */
         case ASN1V_ts24501Msg_mt_NetSliceAuthResult5G:
            pvalue->data.
               t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_NetSliceAuthResult5G;

            pvalue->data.u.obj_NetSliceAuthResult5G = rtxMemAllocType (pctxt, 
               TS24501Msg_NetSliceAuthResult);

            if (pvalue->data.u.obj_NetSliceAuthResult5G == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TS24501Msg_NetSliceAuthResult (pvalue->data.
               u.obj_NetSliceAuthResult5G);

            RTXCTXTPUSHELEMNAME (pctxt, "u.obj_NetSliceAuthResult5G");

            ret = NASDec_TS24501Msg_NetSliceAuthResult (pctxt, pvalue->data.
               u.obj_NetSliceAuthResult5G);
            if (ret < 0) return LOG_RTERR (pctxt, ret);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERRNEW (pctxt,
               rtxErrInvUIntOpt (pctxt, pvalue->msgType));
            break;
      }

      break;

   /* obj_MMAuthResponse5G */
   /* obj_MMAuthResult5G */
   /* obj_MMAuthFailure5G */
   /* obj_MMAuthReject5G */
   /* obj_RegRequest5G */
   /* obj_RegAccept5G */
   /* obj_RegComplete5G */
   /* obj_RegReject5G */
   /* obj_ULNASTrans5G */
   /* obj_DLNASTrans5G */
   /* obj_DeregReqUEOrig5G */
   /* obj_DeregAcceptUEOrig5G */
   /* obj_DeregReqUETerm5G */
   /* obj_DeregAcceptUETerm5G */
   /* obj_ServRequest5G */
   /* obj_ServAccept5G */
   /* obj_ServReject5G */
   /* obj_CfgUpdateCmd5G */
   /* obj_CfgUpdateDone5G */
   /* obj_IdentityRequest5G */
   /* obj_IdentityResponse5G */
   /* obj_Notify5G */
   /* obj_NotifyResponse5G */
   /* obj_SecModeCmd5G */
   /* obj_SecModeDone5G */
   /* obj_SecModeReject5G */
   /* obj_MMStatus5G */
   /* obj_EstablishRequest5G */
   case TS24501Msg_NAS5GProtoDiscr_sessMgmt5G:
   switch (pvalue->msgType) {
      /* obj_EstablishRequest5G */
      case ASN1V_ts24501Msg_st_EstablishRequest5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_EstablishRequest5G;

         pvalue->data.u.obj_EstablishRequest5G = rtxMemAllocType (pctxt, 
            TS24501Msg_EstablishRequest);

         if (pvalue->data.u.obj_EstablishRequest5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_EstablishRequest (pvalue->data.
            u.obj_EstablishRequest5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_EstablishRequest5G");

         ret = NASDec_TS24501Msg_EstablishRequest (pctxt, pvalue->data.
            u.obj_EstablishRequest5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_EstablishAccept5G */
      case ASN1V_ts24501Msg_st_EstablishAccept5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_EstablishAccept5G;

         pvalue->data.u.obj_EstablishAccept5G = rtxMemAllocType (pctxt, 
            TS24501Msg_EstablishAccept);

         if (pvalue->data.u.obj_EstablishAccept5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_EstablishAccept (pvalue->data.
            u.obj_EstablishAccept5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_EstablishAccept5G");

         ret = NASDec_TS24501Msg_EstablishAccept (pctxt, pvalue->data.
            u.obj_EstablishAccept5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_EstablishReject5G */
      case ASN1V_ts24501Msg_st_EstablishReject5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_EstablishReject5G;

         pvalue->data.u.obj_EstablishReject5G = rtxMemAllocType (pctxt, 
            TS24501Msg_EstablishReject);

         if (pvalue->data.u.obj_EstablishReject5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_EstablishReject (pvalue->data.
            u.obj_EstablishReject5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_EstablishReject5G");

         ret = NASDec_TS24501Msg_EstablishReject (pctxt, pvalue->data.
            u.obj_EstablishReject5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_SMAuthCmd5G */
      case ASN1V_ts24501Msg_st_AuthCmd5G:
         pvalue->data.t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_SMAuthCmd5G;

         pvalue->data.u.obj_SMAuthCmd5G = rtxMemAllocType (pctxt, 
            TS24501Msg_SMAuthCmd);

         if (pvalue->data.u.obj_SMAuthCmd5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_SMAuthCmd (pvalue->data.u.obj_SMAuthCmd5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SMAuthCmd5G");

         ret = NASDec_TS24501Msg_SMAuthCmd (pctxt, pvalue->data.
            u.obj_SMAuthCmd5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_SMAuthDone5G */
      case ASN1V_ts24501Msg_st_AuthDone5G:
         pvalue->data.t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_SMAuthDone5G;

         pvalue->data.u.obj_SMAuthDone5G = rtxMemAllocType (pctxt, 
            TS24501Msg_SMAuthDone);

         if (pvalue->data.u.obj_SMAuthDone5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_SMAuthDone (pvalue->data.u.obj_SMAuthDone5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SMAuthDone5G");

         ret = NASDec_TS24501Msg_SMAuthDone (pctxt, pvalue->data.
            u.obj_SMAuthDone5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_SMAuthResult5G */
      case ASN1V_ts24501Msg_st_AuthResult5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_SMAuthResult5G;

         pvalue->data.u.obj_SMAuthResult5G = rtxMemAllocType (pctxt, 
            TS24501Msg_SMAuthResult);

         if (pvalue->data.u.obj_SMAuthResult5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_SMAuthResult (pvalue->data.u.obj_SMAuthResult5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SMAuthResult5G");

         ret = NASDec_TS24501Msg_SMAuthResult (pctxt, pvalue->data.
            u.obj_SMAuthResult5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_ModifyRequest5G */
      case ASN1V_ts24501Msg_st_ModifyRequest5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ModifyRequest5G;

         pvalue->data.u.obj_ModifyRequest5G = rtxMemAllocType (pctxt, 
            TS24501Msg_ModifyRequest);

         if (pvalue->data.u.obj_ModifyRequest5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_ModifyRequest (pvalue->data.u.obj_ModifyRequest5G
            );

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ModifyRequest5G");

         ret = NASDec_TS24501Msg_ModifyRequest (pctxt, pvalue->data.
            u.obj_ModifyRequest5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_ModifyReject5G */
      case ASN1V_ts24501Msg_st_ModifyReject5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ModifyReject5G;

         pvalue->data.u.obj_ModifyReject5G = rtxMemAllocType (pctxt, 
            TS24501Msg_ModifyReject);

         if (pvalue->data.u.obj_ModifyReject5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_ModifyReject (pvalue->data.u.obj_ModifyReject5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ModifyReject5G");

         ret = NASDec_TS24501Msg_ModifyReject (pctxt, pvalue->data.
            u.obj_ModifyReject5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_ModifyCmd5G */
      case ASN1V_ts24501Msg_st_ModifyCmd5G:
         pvalue->data.t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ModifyCmd5G;

         pvalue->data.u.obj_ModifyCmd5G = rtxMemAllocType (pctxt, 
            TS24501Msg_ModifyCmd);

         if (pvalue->data.u.obj_ModifyCmd5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_ModifyCmd (pvalue->data.u.obj_ModifyCmd5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ModifyCmd5G");

         ret = NASDec_TS24501Msg_ModifyCmd (pctxt, pvalue->data.
            u.obj_ModifyCmd5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_ModifyDone5G */
      case ASN1V_ts24501Msg_st_ModifyDone5G:
         pvalue->data.t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ModifyDone5G;

         pvalue->data.u.obj_ModifyDone5G = rtxMemAllocType (pctxt, 
            TS24501Msg_ModifyDone);

         if (pvalue->data.u.obj_ModifyDone5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_ModifyDone (pvalue->data.u.obj_ModifyDone5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ModifyDone5G");

         ret = NASDec_TS24501Msg_ModifyDone (pctxt, pvalue->data.
            u.obj_ModifyDone5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_ModifyCmdReject5G */
      case ASN1V_ts24501Msg_st_ModifyCmdReject5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ModifyCmdReject5G;

         pvalue->data.u.obj_ModifyCmdReject5G = rtxMemAllocType (pctxt, 
            TS24501Msg_ModifyCmdReject);

         if (pvalue->data.u.obj_ModifyCmdReject5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_ModifyCmdReject (pvalue->data.
            u.obj_ModifyCmdReject5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ModifyCmdReject5G");

         ret = NASDec_TS24501Msg_ModifyCmdReject (pctxt, pvalue->data.
            u.obj_ModifyCmdReject5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_ReleaseRequest5G */
      case ASN1V_ts24501Msg_st_ReleaseRequest5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ReleaseRequest5G;

         pvalue->data.u.obj_ReleaseRequest5G = rtxMemAllocType (pctxt, 
            TS24501Msg_ReleaseRequest);

         if (pvalue->data.u.obj_ReleaseRequest5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_ReleaseRequest (pvalue->data.
            u.obj_ReleaseRequest5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ReleaseRequest5G");

         ret = NASDec_TS24501Msg_ReleaseRequest (pctxt, pvalue->data.
            u.obj_ReleaseRequest5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_ReleaseReject5G */
      case ASN1V_ts24501Msg_st_ReleaseReject5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ReleaseReject5G;

         pvalue->data.u.obj_ReleaseReject5G = rtxMemAllocType (pctxt, 
            TS24501Msg_ReleaseReject);

         if (pvalue->data.u.obj_ReleaseReject5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_ReleaseReject (pvalue->data.u.obj_ReleaseReject5G
            );

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ReleaseReject5G");

         ret = NASDec_TS24501Msg_ReleaseReject (pctxt, pvalue->data.
            u.obj_ReleaseReject5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_ReleaseCmd5G */
      case ASN1V_ts24501Msg_st_ReleaseCmd5G:
         pvalue->data.t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ReleaseCmd5G;

         pvalue->data.u.obj_ReleaseCmd5G = rtxMemAllocType (pctxt, 
            TS24501Msg_ReleaseCmd);

         if (pvalue->data.u.obj_ReleaseCmd5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_ReleaseCmd (pvalue->data.u.obj_ReleaseCmd5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ReleaseCmd5G");

         ret = NASDec_TS24501Msg_ReleaseCmd (pctxt, pvalue->data.
            u.obj_ReleaseCmd5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_ReleaseDone5G */
      case ASN1V_ts24501Msg_st_ReleaseDone5G:
         pvalue->data.
            t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_ReleaseDone5G;

         pvalue->data.u.obj_ReleaseDone5G = rtxMemAllocType (pctxt, 
            TS24501Msg_ReleaseDone);

         if (pvalue->data.u.obj_ReleaseDone5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24501Msg_ReleaseDone (pvalue->data.u.obj_ReleaseDone5G);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_ReleaseDone5G");

         ret = NASDec_TS24501Msg_ReleaseDone (pctxt, pvalue->data.
            u.obj_ReleaseDone5G);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* obj_SMStatus5G */
      case ASN1V_ts24501Msg_st_SMStatus5G:
         pvalue->data.t = T_TS24501Msgs_TS24501_IE_OBJECTSET_obj_SMStatus5G;

         pvalue->data.u.obj_SMStatus5G = rtxMemAllocTypeZ (pctxt, 
            TS24501Msg_SMStatus);

         if (pvalue->data.u.obj_SMStatus5G == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         RTXCTXTPUSHELEMNAME (pctxt, "u.obj_SMStatus5G");

         ret = NASDec_TS24501Msg_SMStatus (pctxt, pvalue->data.u.obj_SMStatus5G
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERRNEW (pctxt,
            rtxErrInvUIntOpt (pctxt, pvalue->msgType));
         break;
   }

   break;

/* obj_EstablishAccept5G */
/* obj_EstablishReject5G */
/* obj_SMAuthCmd5G */
/* obj_SMAuthDone5G */
/* obj_SMAuthResult5G */
/* obj_ModifyRequest5G */
/* obj_ModifyReject5G */
/* obj_ModifyCmd5G */
/* obj_ModifyDone5G */
/* obj_ModifyCmdReject5G */
/* obj_ReleaseRequest5G */
/* obj_ReleaseReject5G */
/* obj_ReleaseCmd5G */
/* obj_ReleaseDone5G */
/* obj_SMStatus5G */
/* obj_ControlPlaneServReq5G */
/* obj_NetSliceAuthCmd5G */
/* obj_NetSliceAuthDone5G */
/* obj_NetSliceAuthResult5G */
default:
   return LOG_RTERRNEW (pctxt,
      rtxErrInvUIntOpt (pctxt, pvalue->protoDiscr));
   break;
}

RTXCTXTPOPELEMNAME (pctxt);

/* decode eom */

/* begin custom source file TS24301MsgDec_PDU_eom.c */

/* start custom code */
/* In case integrity protection check failed and error was not immediately 
   returned. */
ret = rtxErrGetStatus(pctxt);

/* end custom code */

/* end custom source file TS24301MsgDec_PDU_eom.c */

RTXCTXTPOPTYPENAME (pctxt);

return (ret);
}

