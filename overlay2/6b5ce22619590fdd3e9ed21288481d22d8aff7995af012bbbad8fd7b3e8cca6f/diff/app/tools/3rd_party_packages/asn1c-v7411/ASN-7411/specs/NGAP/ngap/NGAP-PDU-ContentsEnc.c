/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.4.1.1, Date: 02-Jun-2020.
 */
#include ".h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PE__RerouteNASRequest_IEs_Value (OSCTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RerouteNASRequest_IEs_Value value = *((_RerouteNASRequest_IEs_Value*)pvalue_);
   RTDIAGSTRM2 (pctxt, "asn1PE__RerouteNASRequest_IEs_Value: start\n");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt, "asn1PE__RerouteNASRequest_IEs_Value: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceSetupRequest_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceSetupRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceSetupRequestIEs_id_RANPagingPriority */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_RANPagingPriority:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_RANPagingPriority");

      stat = asn1PE_RANPagingPriority (pctxt, pvalue->value.u._PDUSessionResourceSetupRequestIEs_id_RANPagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceSetupRequestIEs_id_NAS_PDU */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_NAS_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_NAS_PDU");

      stat = asn1PE_NAS_PDU (pctxt, *pvalue->value.u._PDUSessionResourceSetupRequestIEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq");

      stat = asn1PE_PDUSessionResourceSetupListSUReq (pctxt, pvalue->value.u._PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate");

      stat = asn1PE_UEAggregateMaximumBitRate (pctxt, (UEAggregateMaximumBitRate*)pvalue->value.u._PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceSetupRequest_protocolIEs (OSCTXT* pctxt, PDUSessionResourceSetupRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PDUSessionResourceSetupRequest_protocolIEs_element (pctxt, ((PDUSessionResourceSetupRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceSetupRequest (OSCTXT* pctxt, PDUSessionResourceSetupRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PDUSessionResourceSetupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceSetupResponse_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceSetupResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupResponse_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes");

      stat = asn1PE_PDUSessionResourceSetupListSURes (pctxt, pvalue->value.u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes");

      stat = asn1PE_PDUSessionResourceFailedToSetupListSURes (pctxt, pvalue->value.u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceSetupResponse_protocolIEs (OSCTXT* pctxt, PDUSessionResourceSetupResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupResponse_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PDUSessionResourceSetupResponse_protocolIEs_element (pctxt, ((PDUSessionResourceSetupResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceSetupResponse (OSCTXT* pctxt, PDUSessionResourceSetupResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupResponse");

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PDUSessionResourceSetupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceSetupResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceReleaseCommand_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceReleaseCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseCommand_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority */
   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority");

      stat = asn1PE_RANPagingPriority (pctxt, pvalue->value.u._PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceReleaseCommandIEs_id_NAS_PDU */
   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_NAS_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_NAS_PDU");

      stat = asn1PE_NAS_PDU (pctxt, *pvalue->value.u._PDUSessionResourceReleaseCommandIEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd */
   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd");

      stat = asn1PE_PDUSessionResourceToReleaseListRelCmd (pctxt, pvalue->value.u._PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseCommand_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceReleaseCommand_protocolIEs (OSCTXT* pctxt, PDUSessionResourceReleaseCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseCommand_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PDUSessionResourceReleaseCommand_protocolIEs_element (pctxt, ((PDUSessionResourceReleaseCommand_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseCommand_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceReleaseCommand (OSCTXT* pctxt, PDUSessionResourceReleaseCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleaseCommand");

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseCommand: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PDUSessionResourceReleaseCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseCommand: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceReleaseResponse_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceReleaseResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseResponse_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes */
   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes");

      stat = asn1PE_PDUSessionResourceReleasedListRelRes (pctxt, pvalue->value.u._PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceReleaseResponse_protocolIEs (OSCTXT* pctxt, PDUSessionResourceReleaseResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseResponse_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PDUSessionResourceReleaseResponse_protocolIEs_element (pctxt, ((PDUSessionResourceReleaseResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceReleaseResponse (OSCTXT* pctxt, PDUSessionResourceReleaseResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleaseResponse");

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PDUSessionResourceReleaseResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceReleaseResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyRequest_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyRequestIEs_id_RANPagingPriority */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_RANPagingPriority:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_RANPagingPriority");

      stat = asn1PE_RANPagingPriority (pctxt, pvalue->value.u._PDUSessionResourceModifyRequestIEs_id_RANPagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq");

      stat = asn1PE_PDUSessionResourceModifyListModReq (pctxt, pvalue->value.u._PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyRequest_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PDUSessionResourceModifyRequest_protocolIEs_element (pctxt, ((PDUSessionResourceModifyRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyRequest (OSCTXT* pctxt, PDUSessionResourceModifyRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PDUSessionResourceModifyRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyResponse_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyResponse_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes");

      stat = asn1PE_PDUSessionResourceModifyListModRes (pctxt, pvalue->value.u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes");

      stat = asn1PE_PDUSessionResourceFailedToModifyListModRes (pctxt, pvalue->value.u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyResponseIEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._PDUSessionResourceModifyResponseIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyResponse_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyResponse_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PDUSessionResourceModifyResponse_protocolIEs_element (pctxt, ((PDUSessionResourceModifyResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyResponse (OSCTXT* pctxt, PDUSessionResourceModifyResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyResponse");

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PDUSessionResourceModifyResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceNotify_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceNotify_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceNotify_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList */
   case T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList");

      stat = asn1PE_PDUSessionResourceNotifyList (pctxt, pvalue->value.u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot */
   case T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot");

      stat = asn1PE_PDUSessionResourceReleasedListNot (pctxt, pvalue->value.u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceNotifyIEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._PDUSessionResourceNotifyIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceNotify_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceNotify_protocolIEs (OSCTXT* pctxt, PDUSessionResourceNotify_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceNotify_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PDUSessionResourceNotify_protocolIEs_element (pctxt, ((PDUSessionResourceNotify_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceNotify_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceNotify (OSCTXT* pctxt, PDUSessionResourceNotify* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceNotify");

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceNotify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PDUSessionResourceNotify_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceNotify: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyIndication_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyIndication_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd");

      stat = asn1PE_PDUSessionResourceModifyListModInd (pctxt, pvalue->value.u._PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyIndication_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyIndication_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PDUSessionResourceModifyIndication_protocolIEs_element (pctxt, ((PDUSessionResourceModifyIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyIndication (OSCTXT* pctxt, PDUSessionResourceModifyIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyIndication");

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PDUSessionResourceModifyIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyConfirm_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyConfirm_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyConfirm_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm");

      stat = asn1PE_PDUSessionResourceModifyListModCfm (pctxt, pvalue->value.u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm");

      stat = asn1PE_PDUSessionResourceFailedToModifyListModCfm (pctxt, pvalue->value.u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyConfirm_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyConfirm_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyConfirm_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyConfirm_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PDUSessionResourceModifyConfirm_protocolIEs_element (pctxt, ((PDUSessionResourceModifyConfirm_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyConfirm_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PDUSessionResourceModifyConfirm (OSCTXT* pctxt, PDUSessionResourceModifyConfirm* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyConfirm");

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyConfirm: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PDUSessionResourceModifyConfirm_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PDUSessionResourceModifyConfirm: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_InitialContextSetupRequest_protocolIEs_element (OSCTXT* pctxt, InitialContextSetupRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_OldAMF */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_OldAMF:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_OldAMF");

      stat = asn1PE_AMFName (pctxt, pvalue->value.u._InitialContextSetupRequestIEs_id_OldAMF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate");

      stat = asn1PE_UEAggregateMaximumBitRate (pctxt, (UEAggregateMaximumBitRate*)pvalue->value.u._InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive");

      stat = asn1PE_CoreNetworkAssistanceInformationForInactive (pctxt, (CoreNetworkAssistanceInformationForInactive*)pvalue->value.u._InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_GUAMI */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_GUAMI:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_GUAMI");

      stat = asn1PE_GUAMI (pctxt, (GUAMI*)pvalue->value.u._InitialContextSetupRequestIEs_id_GUAMI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq");

      stat = asn1PE_PDUSessionResourceSetupListCxtReq (pctxt, pvalue->value.u._InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_AllowedNSSAI */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_AllowedNSSAI:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_AllowedNSSAI");

      stat = asn1PE_AllowedNSSAI (pctxt, pvalue->value.u._InitialContextSetupRequestIEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_UESecurityCapabilities */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UESecurityCapabilities:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UESecurityCapabilities");

      stat = asn1PE_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)pvalue->value.u._InitialContextSetupRequestIEs_id_UESecurityCapabilities);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_SecurityKey */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_SecurityKey:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_SecurityKey");

      stat = asn1PE_SecurityKey (pctxt, (SecurityKey*)pvalue->value.u._InitialContextSetupRequestIEs_id_SecurityKey);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_TraceActivation */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_TraceActivation:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_TraceActivation");

      stat = asn1PE_TraceActivation (pctxt, (TraceActivation*)pvalue->value.u._InitialContextSetupRequestIEs_id_TraceActivation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_MobilityRestrictionList */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_MobilityRestrictionList:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_MobilityRestrictionList");

      stat = asn1PE_MobilityRestrictionList (pctxt, (MobilityRestrictionList*)pvalue->value.u._InitialContextSetupRequestIEs_id_MobilityRestrictionList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_UERadioCapability */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UERadioCapability:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UERadioCapability");

      stat = asn1PE_UERadioCapability (pctxt, *pvalue->value.u._InitialContextSetupRequestIEs_id_UERadioCapability);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_IndexToRFSP */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_IndexToRFSP:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_IndexToRFSP");

      stat = asn1PE_IndexToRFSP (pctxt, pvalue->value.u._InitialContextSetupRequestIEs_id_IndexToRFSP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_MaskedIMEISV */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_MaskedIMEISV:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_MaskedIMEISV");

      stat = asn1PE_MaskedIMEISV (pctxt, (MaskedIMEISV*)pvalue->value.u._InitialContextSetupRequestIEs_id_MaskedIMEISV);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_NAS_PDU */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_NAS_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_NAS_PDU");

      stat = asn1PE_NAS_PDU (pctxt, *pvalue->value.u._InitialContextSetupRequestIEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator");

      stat = asn1PE_EmergencyFallbackIndicator (pctxt, (EmergencyFallbackIndicator*)pvalue->value.u._InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest");

      stat = asn1PE_RRCInactiveTransitionReportRequest (pctxt, pvalue->value.u._InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging");

      stat = asn1PE_UERadioCapabilityForPaging (pctxt, (UERadioCapabilityForPaging*)pvalue->value.u._InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_RedirectionVoiceFallback */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_RedirectionVoiceFallback:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_RedirectionVoiceFallback");

      stat = asn1PE_RedirectionVoiceFallback (pctxt, pvalue->value.u._InitialContextSetupRequestIEs_id_RedirectionVoiceFallback);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_LocationReportingRequestType */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_LocationReportingRequestType:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_LocationReportingRequestType");

      stat = asn1PE_LocationReportingRequestType (pctxt, (LocationReportingRequestType*)pvalue->value.u._InitialContextSetupRequestIEs_id_LocationReportingRequestType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupRequestIEs_id_CNAssistedRANTuning */
   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_CNAssistedRANTuning:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_CNAssistedRANTuning");

      stat = asn1PE_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue->value.u._InitialContextSetupRequestIEs_id_CNAssistedRANTuning);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_InitialContextSetupRequest_protocolIEs (OSCTXT* pctxt, InitialContextSetupRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_InitialContextSetupRequest_protocolIEs_element (pctxt, ((InitialContextSetupRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_InitialContextSetupRequest (OSCTXT* pctxt, InitialContextSetupRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialContextSetupRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_InitialContextSetupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_InitialContextSetupResponse_protocolIEs_element (OSCTXT* pctxt, InitialContextSetupResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupResponse_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes */
   case T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes");

      stat = asn1PE_PDUSessionResourceSetupListCxtRes (pctxt, pvalue->value.u._InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes */
   case T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes");

      stat = asn1PE_PDUSessionResourceFailedToSetupListCxtRes (pctxt, pvalue->value.u._InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupResponseIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._InitialContextSetupResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_InitialContextSetupResponse_protocolIEs (OSCTXT* pctxt, InitialContextSetupResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupResponse_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_InitialContextSetupResponse_protocolIEs_element (pctxt, ((InitialContextSetupResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_InitialContextSetupResponse (OSCTXT* pctxt, InitialContextSetupResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialContextSetupResponse");

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_InitialContextSetupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_InitialContextSetupFailure_protocolIEs_element (OSCTXT* pctxt, InitialContextSetupFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupFailure_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail */
   case T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail");

      stat = asn1PE_PDUSessionResourceFailedToSetupListCxtFail (pctxt, pvalue->value.u._InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupFailureIEs_id_Cause */
   case T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._InitialContextSetupFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialContextSetupFailureIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._InitialContextSetupFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_InitialContextSetupFailure_protocolIEs (OSCTXT* pctxt, InitialContextSetupFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupFailure_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_InitialContextSetupFailure_protocolIEs_element (pctxt, ((InitialContextSetupFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_InitialContextSetupFailure (OSCTXT* pctxt, InitialContextSetupFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialContextSetupFailure");

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_InitialContextSetupFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialContextSetupFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UEContextReleaseRequest_protocolIEs_element (OSCTXT* pctxt, UEContextReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq */
   case T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq");

      stat = asn1PE_PDUSessionResourceListCxtRelReq (pctxt, pvalue->value.u._UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextReleaseRequest_IEs_id_Cause */
   case T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._UEContextReleaseRequest_IEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextReleaseRequest_protocolIEs (OSCTXT* pctxt, UEContextReleaseRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UEContextReleaseRequest_protocolIEs_element (pctxt, ((UEContextReleaseRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextReleaseRequest (OSCTXT* pctxt, UEContextReleaseRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextReleaseRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UEContextReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UEContextReleaseCommand_protocolIEs_element (OSCTXT* pctxt, UEContextReleaseCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseCommand_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UEContextReleaseCommand_IEs_id_UE_NGAP_IDs */
   case T_NGAP_PDU_Contents_UEContextReleaseCommand_IEs_id_UE_NGAP_IDs:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseCommand_IEs_id_UE_NGAP_IDs");

      stat = asn1PE_UE_NGAP_IDs (pctxt, (UE_NGAP_IDs*)pvalue->value.u._UEContextReleaseCommand_IEs_id_UE_NGAP_IDs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextReleaseCommand_IEs_id_Cause */
   case T_NGAP_PDU_Contents_UEContextReleaseCommand_IEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseCommand_IEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._UEContextReleaseCommand_IEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UEContextReleaseCommand_IEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseCommand_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextReleaseCommand_protocolIEs (OSCTXT* pctxt, UEContextReleaseCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseCommand_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UEContextReleaseCommand_protocolIEs_element (pctxt, ((UEContextReleaseCommand_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseCommand_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextReleaseCommand (OSCTXT* pctxt, UEContextReleaseCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextReleaseCommand");

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseCommand: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UEContextReleaseCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseCommand: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UEContextReleaseComplete_protocolIEs_element (OSCTXT* pctxt, UEContextReleaseComplete_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseComplete_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextReleaseComplete_IEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._UEContextReleaseComplete_IEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging */
   case T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging");

      stat = asn1PE_InfoOnRecommendedCellsAndRANNodesForPaging (pctxt, (InfoOnRecommendedCellsAndRANNodesForPaging*)pvalue->value.u._UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl */
   case T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl");

      stat = asn1PE_PDUSessionResourceListCxtRelCpl (pctxt, pvalue->value.u._UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextReleaseComplete_IEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._UEContextReleaseComplete_IEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseComplete_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextReleaseComplete_protocolIEs (OSCTXT* pctxt, UEContextReleaseComplete_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseComplete_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UEContextReleaseComplete_protocolIEs_element (pctxt, ((UEContextReleaseComplete_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseComplete_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextReleaseComplete (OSCTXT* pctxt, UEContextReleaseComplete* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextReleaseComplete");

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseComplete: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UEContextReleaseComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextReleaseComplete: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UEContextModificationRequest_protocolIEs_element (OSCTXT* pctxt, UEContextModificationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_RANPagingPriority */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_RANPagingPriority:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_RANPagingPriority");

      stat = asn1PE_RANPagingPriority (pctxt, pvalue->value.u._UEContextModificationRequestIEs_id_RANPagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_SecurityKey */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_SecurityKey:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_SecurityKey");

      stat = asn1PE_SecurityKey (pctxt, (SecurityKey*)pvalue->value.u._UEContextModificationRequestIEs_id_SecurityKey);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_IndexToRFSP */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_IndexToRFSP:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_IndexToRFSP");

      stat = asn1PE_IndexToRFSP (pctxt, pvalue->value.u._UEContextModificationRequestIEs_id_IndexToRFSP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate");

      stat = asn1PE_UEAggregateMaximumBitRate (pctxt, (UEAggregateMaximumBitRate*)pvalue->value.u._UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_UESecurityCapabilities */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_UESecurityCapabilities:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_UESecurityCapabilities");

      stat = asn1PE_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)pvalue->value.u._UEContextModificationRequestIEs_id_UESecurityCapabilities);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive");

      stat = asn1PE_CoreNetworkAssistanceInformationForInactive (pctxt, (CoreNetworkAssistanceInformationForInactive*)pvalue->value.u._UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_EmergencyFallbackIndicator */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_EmergencyFallbackIndicator:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_EmergencyFallbackIndicator");

      stat = asn1PE_EmergencyFallbackIndicator (pctxt, (EmergencyFallbackIndicator*)pvalue->value.u._UEContextModificationRequestIEs_id_EmergencyFallbackIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest");

      stat = asn1PE_RRCInactiveTransitionReportRequest (pctxt, pvalue->value.u._UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_NewGUAMI */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_NewGUAMI:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_NewGUAMI");

      stat = asn1PE_GUAMI (pctxt, (GUAMI*)pvalue->value.u._UEContextModificationRequestIEs_id_NewGUAMI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationRequestIEs_id_CNAssistedRANTuning */
   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_CNAssistedRANTuning:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_CNAssistedRANTuning");

      stat = asn1PE_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue->value.u._UEContextModificationRequestIEs_id_CNAssistedRANTuning);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UEContextModificationRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextModificationRequest_protocolIEs (OSCTXT* pctxt, UEContextModificationRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UEContextModificationRequest_protocolIEs_element (pctxt, ((UEContextModificationRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextModificationRequest (OSCTXT* pctxt, UEContextModificationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextModificationRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UEContextModificationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UEContextModificationResponse_protocolIEs_element (OSCTXT* pctxt, UEContextModificationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationResponse_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationResponseIEs_id_RRCState */
   case T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_RRCState:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_RRCState");

      stat = asn1PE_RRCState (pctxt, pvalue->value.u._UEContextModificationResponseIEs_id_RRCState);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationResponseIEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._UEContextModificationResponseIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationResponseIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._UEContextModificationResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UEContextModificationResponseIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextModificationResponse_protocolIEs (OSCTXT* pctxt, UEContextModificationResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationResponse_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UEContextModificationResponse_protocolIEs_element (pctxt, ((UEContextModificationResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextModificationResponse (OSCTXT* pctxt, UEContextModificationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextModificationResponse");

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UEContextModificationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UEContextModificationFailure_protocolIEs_element (OSCTXT* pctxt, UEContextModificationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationFailure_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationFailureIEs_id_Cause */
   case T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._UEContextModificationFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UEContextModificationFailureIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._UEContextModificationFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UEContextModificationFailureIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextModificationFailure_protocolIEs (OSCTXT* pctxt, UEContextModificationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationFailure_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UEContextModificationFailure_protocolIEs_element (pctxt, ((UEContextModificationFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UEContextModificationFailure (OSCTXT* pctxt, UEContextModificationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextModificationFailure");

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UEContextModificationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UEContextModificationFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RRCInactiveTransitionReport_protocolIEs_element (OSCTXT* pctxt, RRCInactiveTransitionReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RRCInactiveTransitionReport_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RRCInactiveTransitionReportIEs_id_RRCState */
   case T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_RRCState:
      RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_RRCState");

      stat = asn1PE_RRCState (pctxt, pvalue->value.u._RRCInactiveTransitionReportIEs_id_RRCState);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RRCInactiveTransitionReportIEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._RRCInactiveTransitionReportIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_RRCInactiveTransitionReport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_RRCInactiveTransitionReport_protocolIEs (OSCTXT* pctxt, RRCInactiveTransitionReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RRCInactiveTransitionReport_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_RRCInactiveTransitionReport_protocolIEs_element (pctxt, ((RRCInactiveTransitionReport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RRCInactiveTransitionReport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_RRCInactiveTransitionReport (OSCTXT* pctxt, RRCInactiveTransitionReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCInactiveTransitionReport");

   RTDIAGSTRM2 (pctxt, "asn1PE_RRCInactiveTransitionReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_RRCInactiveTransitionReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RRCInactiveTransitionReport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_HandoverRequired_protocolIEs_element (OSCTXT* pctxt, HandoverRequired_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequired_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _HandoverRequiredIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverRequiredIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverRequiredIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequiredIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverRequiredIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverRequiredIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequiredIEs_id_HandoverType */
   case T_NGAP_PDU_Contents_HandoverRequiredIEs_id_HandoverType:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_HandoverType");

      stat = asn1PE_HandoverType (pctxt, pvalue->value.u._HandoverRequiredIEs_id_HandoverType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequiredIEs_id_Cause */
   case T_NGAP_PDU_Contents_HandoverRequiredIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._HandoverRequiredIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequiredIEs_id_TargetID */
   case T_NGAP_PDU_Contents_HandoverRequiredIEs_id_TargetID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_TargetID");

      stat = asn1PE_TargetID (pctxt, (TargetID*)pvalue->value.u._HandoverRequiredIEs_id_TargetID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequiredIEs_id_DirectForwardingPathAvailability */
   case T_NGAP_PDU_Contents_HandoverRequiredIEs_id_DirectForwardingPathAvailability:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_DirectForwardingPathAvailability");

      stat = asn1PE_DirectForwardingPathAvailability (pctxt, pvalue->value.u._HandoverRequiredIEs_id_DirectForwardingPathAvailability);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequiredIEs_id_PDUSessionResourceListHORqd */
   case T_NGAP_PDU_Contents_HandoverRequiredIEs_id_PDUSessionResourceListHORqd:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_PDUSessionResourceListHORqd");

      stat = asn1PE_PDUSessionResourceListHORqd (pctxt, pvalue->value.u._HandoverRequiredIEs_id_PDUSessionResourceListHORqd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequiredIEs_id_SourceToTarget_TransparentContainer */
   case T_NGAP_PDU_Contents_HandoverRequiredIEs_id_SourceToTarget_TransparentContainer:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_SourceToTarget_TransparentContainer");

      stat = asn1PE_SourceToTarget_TransparentContainer (pctxt, *pvalue->value.u._HandoverRequiredIEs_id_SourceToTarget_TransparentContainer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_HandoverRequiredIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequired_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverRequired_protocolIEs (OSCTXT* pctxt, HandoverRequired_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequired_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_HandoverRequired_protocolIEs_element (pctxt, ((HandoverRequired_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequired_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverRequired (OSCTXT* pctxt, HandoverRequired* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequired");

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequired: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_HandoverRequired_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequired: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_HandoverCommand_protocolIEs_element (OSCTXT* pctxt, HandoverCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCommand_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _HandoverCommandIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverCommandIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverCommandIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCommandIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverCommandIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverCommandIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCommandIEs_id_HandoverType */
   case T_NGAP_PDU_Contents_HandoverCommandIEs_id_HandoverType:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_HandoverType");

      stat = asn1PE_HandoverType (pctxt, pvalue->value.u._HandoverCommandIEs_id_HandoverType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCommandIEs_id_NASSecurityParametersFromNGRAN */
   case T_NGAP_PDU_Contents_HandoverCommandIEs_id_NASSecurityParametersFromNGRAN:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_NASSecurityParametersFromNGRAN");

      stat = asn1PE_NASSecurityParametersFromNGRAN (pctxt, *pvalue->value.u._HandoverCommandIEs_id_NASSecurityParametersFromNGRAN);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCommandIEs_id_PDUSessionResourceHandoverList */
   case T_NGAP_PDU_Contents_HandoverCommandIEs_id_PDUSessionResourceHandoverList:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_PDUSessionResourceHandoverList");

      stat = asn1PE_PDUSessionResourceHandoverList (pctxt, pvalue->value.u._HandoverCommandIEs_id_PDUSessionResourceHandoverList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd */
   case T_NGAP_PDU_Contents_HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd");

      stat = asn1PE_PDUSessionResourceToReleaseListHOCmd (pctxt, pvalue->value.u._HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCommandIEs_id_TargetToSource_TransparentContainer */
   case T_NGAP_PDU_Contents_HandoverCommandIEs_id_TargetToSource_TransparentContainer:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_TargetToSource_TransparentContainer");

      stat = asn1PE_TargetToSource_TransparentContainer (pctxt, *pvalue->value.u._HandoverCommandIEs_id_TargetToSource_TransparentContainer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCommandIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_HandoverCommandIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._HandoverCommandIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_HandoverCommandIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCommand_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverCommand_protocolIEs (OSCTXT* pctxt, HandoverCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCommand_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_HandoverCommand_protocolIEs_element (pctxt, ((HandoverCommand_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCommand_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverCommand (OSCTXT* pctxt, HandoverCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCommand");

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCommand: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_HandoverCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCommand: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_HandoverPreparationFailure_protocolIEs_element (OSCTXT* pctxt, HandoverPreparationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverPreparationFailure_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverPreparationFailureIEs_id_Cause */
   case T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._HandoverPreparationFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverPreparationFailureIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._HandoverPreparationFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverPreparationFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverPreparationFailure_protocolIEs (OSCTXT* pctxt, HandoverPreparationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverPreparationFailure_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_HandoverPreparationFailure_protocolIEs_element (pctxt, ((HandoverPreparationFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverPreparationFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverPreparationFailure (OSCTXT* pctxt, HandoverPreparationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverPreparationFailure");

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverPreparationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_HandoverPreparationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverPreparationFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_HandoverRequest_protocolIEs_element (OSCTXT* pctxt, HandoverRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _HandoverRequestIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_HandoverType */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_HandoverType:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_HandoverType");

      stat = asn1PE_HandoverType (pctxt, pvalue->value.u._HandoverRequestIEs_id_HandoverType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_Cause */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._HandoverRequestIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_UEAggregateMaximumBitRate */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_UEAggregateMaximumBitRate:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_UEAggregateMaximumBitRate");

      stat = asn1PE_UEAggregateMaximumBitRate (pctxt, (UEAggregateMaximumBitRate*)pvalue->value.u._HandoverRequestIEs_id_UEAggregateMaximumBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive");

      stat = asn1PE_CoreNetworkAssistanceInformationForInactive (pctxt, (CoreNetworkAssistanceInformationForInactive*)pvalue->value.u._HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_UESecurityCapabilities */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_UESecurityCapabilities:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_UESecurityCapabilities");

      stat = asn1PE_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)pvalue->value.u._HandoverRequestIEs_id_UESecurityCapabilities);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_SecurityContext */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_SecurityContext:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_SecurityContext");

      stat = asn1PE_SecurityContext (pctxt, (SecurityContext*)pvalue->value.u._HandoverRequestIEs_id_SecurityContext);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_NewSecurityContextInd */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_NewSecurityContextInd:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_NewSecurityContextInd");

      stat = asn1PE_NewSecurityContextInd (pctxt, pvalue->value.u._HandoverRequestIEs_id_NewSecurityContextInd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_NASC */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_NASC:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_NASC");

      stat = asn1PE_NAS_PDU (pctxt, *pvalue->value.u._HandoverRequestIEs_id_NASC);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq");

      stat = asn1PE_PDUSessionResourceSetupListHOReq (pctxt, pvalue->value.u._HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_AllowedNSSAI */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_AllowedNSSAI:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_AllowedNSSAI");

      stat = asn1PE_AllowedNSSAI (pctxt, pvalue->value.u._HandoverRequestIEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_TraceActivation */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_TraceActivation:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_TraceActivation");

      stat = asn1PE_TraceActivation (pctxt, (TraceActivation*)pvalue->value.u._HandoverRequestIEs_id_TraceActivation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_MaskedIMEISV */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_MaskedIMEISV:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_MaskedIMEISV");

      stat = asn1PE_MaskedIMEISV (pctxt, (MaskedIMEISV*)pvalue->value.u._HandoverRequestIEs_id_MaskedIMEISV);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_SourceToTarget_TransparentContainer */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_SourceToTarget_TransparentContainer:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_SourceToTarget_TransparentContainer");

      stat = asn1PE_SourceToTarget_TransparentContainer (pctxt, *pvalue->value.u._HandoverRequestIEs_id_SourceToTarget_TransparentContainer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_MobilityRestrictionList */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_MobilityRestrictionList:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_MobilityRestrictionList");

      stat = asn1PE_MobilityRestrictionList (pctxt, (MobilityRestrictionList*)pvalue->value.u._HandoverRequestIEs_id_MobilityRestrictionList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_LocationReportingRequestType */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_LocationReportingRequestType:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_LocationReportingRequestType");

      stat = asn1PE_LocationReportingRequestType (pctxt, (LocationReportingRequestType*)pvalue->value.u._HandoverRequestIEs_id_LocationReportingRequestType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_RRCInactiveTransitionReportRequest */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_RRCInactiveTransitionReportRequest:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_RRCInactiveTransitionReportRequest");

      stat = asn1PE_RRCInactiveTransitionReportRequest (pctxt, pvalue->value.u._HandoverRequestIEs_id_RRCInactiveTransitionReportRequest);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_GUAMI */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_GUAMI:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_GUAMI");

      stat = asn1PE_GUAMI (pctxt, (GUAMI*)pvalue->value.u._HandoverRequestIEs_id_GUAMI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_RedirectionVoiceFallback */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_RedirectionVoiceFallback:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_RedirectionVoiceFallback");

      stat = asn1PE_RedirectionVoiceFallback (pctxt, pvalue->value.u._HandoverRequestIEs_id_RedirectionVoiceFallback);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestIEs_id_CNAssistedRANTuning */
   case T_NGAP_PDU_Contents_HandoverRequestIEs_id_CNAssistedRANTuning:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_CNAssistedRANTuning");

      stat = asn1PE_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue->value.u._HandoverRequestIEs_id_CNAssistedRANTuning);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_HandoverRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverRequest_protocolIEs (OSCTXT* pctxt, HandoverRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_HandoverRequest_protocolIEs_element (pctxt, ((HandoverRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverRequest (OSCTXT* pctxt, HandoverRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_HandoverRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_HandoverRequestAcknowledge_protocolIEs_element (OSCTXT* pctxt, HandoverRequestAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequestAcknowledge_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList */
   case T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList");

      stat = asn1PE_PDUSessionResourceAdmittedList (pctxt, pvalue->value.u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck */
   case T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck");

      stat = asn1PE_PDUSessionResourceFailedToSetupListHOAck (pctxt, pvalue->value.u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer */
   case T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer");

      stat = asn1PE_TargetToSource_TransparentContainer (pctxt, *pvalue->value.u._HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequestAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverRequestAcknowledge_protocolIEs (OSCTXT* pctxt, HandoverRequestAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequestAcknowledge_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_HandoverRequestAcknowledge_protocolIEs_element (pctxt, ((HandoverRequestAcknowledge_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequestAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverRequestAcknowledge (OSCTXT* pctxt, HandoverRequestAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequestAcknowledge");

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequestAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_HandoverRequestAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverRequestAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_HandoverFailure_protocolIEs_element (OSCTXT* pctxt, HandoverFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverFailure_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _HandoverFailureIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverFailureIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverFailureIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverFailureIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverFailureIEs_id_Cause */
   case T_NGAP_PDU_Contents_HandoverFailureIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverFailureIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._HandoverFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverFailureIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_HandoverFailureIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverFailureIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._HandoverFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_HandoverFailureIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverFailure_protocolIEs (OSCTXT* pctxt, HandoverFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverFailure_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_HandoverFailure_protocolIEs_element (pctxt, ((HandoverFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverFailure (OSCTXT* pctxt, HandoverFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFailure");

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_HandoverFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_HandoverNotify_protocolIEs_element (OSCTXT* pctxt, HandoverNotify_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverNotify_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _HandoverNotifyIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverNotifyIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverNotifyIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverNotifyIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverNotifyIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverNotifyIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverNotifyIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverNotifyIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverNotifyIEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_HandoverNotifyIEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverNotifyIEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._HandoverNotifyIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_HandoverNotifyIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverNotify_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverNotify_protocolIEs (OSCTXT* pctxt, HandoverNotify_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverNotify_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_HandoverNotify_protocolIEs_element (pctxt, ((HandoverNotify_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverNotify_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverNotify (OSCTXT* pctxt, HandoverNotify* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverNotify");

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverNotify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_HandoverNotify_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverNotify: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PathSwitchRequest_protocolIEs_element (OSCTXT* pctxt, PathSwitchRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PathSwitchRequestIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PathSwitchRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestIEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._PathSwitchRequestIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestIEs_id_UESecurityCapabilities */
   case T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_UESecurityCapabilities:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_UESecurityCapabilities");

      stat = asn1PE_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)pvalue->value.u._PathSwitchRequestIEs_id_UESecurityCapabilities);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList */
   case T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList");

      stat = asn1PE_PDUSessionResourceToBeSwitchedDLList (pctxt, pvalue->value.u._PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq */
   case T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq");

      stat = asn1PE_PDUSessionResourceFailedToSetupListPSReq (pctxt, pvalue->value.u._PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PathSwitchRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PathSwitchRequest_protocolIEs (OSCTXT* pctxt, PathSwitchRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PathSwitchRequest_protocolIEs_element (pctxt, ((PathSwitchRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PathSwitchRequest (OSCTXT* pctxt, PathSwitchRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PathSwitchRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PathSwitchRequestAcknowledge_protocolIEs_element (OSCTXT* pctxt, PathSwitchRequestAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestAcknowledge_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities");

      stat = asn1PE_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_SecurityContext */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_SecurityContext:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_SecurityContext");

      stat = asn1PE_SecurityContext (pctxt, (SecurityContext*)pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_SecurityContext);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd");

      stat = asn1PE_NewSecurityContextInd (pctxt, pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList");

      stat = asn1PE_PDUSessionResourceSwitchedList (pctxt, pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck");

      stat = asn1PE_PDUSessionResourceReleasedListPSAck (pctxt, pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI");

      stat = asn1PE_AllowedNSSAI (pctxt, pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive");

      stat = asn1PE_CoreNetworkAssistanceInformationForInactive (pctxt, (CoreNetworkAssistanceInformationForInactive*)pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest");

      stat = asn1PE_RRCInactiveTransitionReportRequest (pctxt, pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback");

      stat = asn1PE_RedirectionVoiceFallback (pctxt, pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning */
   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning");

      stat = asn1PE_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PathSwitchRequestAcknowledge_protocolIEs (OSCTXT* pctxt, PathSwitchRequestAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestAcknowledge_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PathSwitchRequestAcknowledge_protocolIEs_element (pctxt, ((PathSwitchRequestAcknowledge_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PathSwitchRequestAcknowledge (OSCTXT* pctxt, PathSwitchRequestAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequestAcknowledge");

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PathSwitchRequestAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PathSwitchRequestFailure_protocolIEs_element (OSCTXT* pctxt, PathSwitchRequestFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestFailure_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail */
   case T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail");

      stat = asn1PE_PDUSessionResourceReleasedListPSFail (pctxt, pvalue->value.u._PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PathSwitchRequestFailureIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._PathSwitchRequestFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PathSwitchRequestFailure_protocolIEs (OSCTXT* pctxt, PathSwitchRequestFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestFailure_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PathSwitchRequestFailure_protocolIEs_element (pctxt, ((PathSwitchRequestFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PathSwitchRequestFailure (OSCTXT* pctxt, PathSwitchRequestFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequestFailure");

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PathSwitchRequestFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PathSwitchRequestFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_HandoverCancel_protocolIEs_element (OSCTXT* pctxt, HandoverCancel_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancel_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _HandoverCancelIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverCancelIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverCancelIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCancelIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverCancelIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverCancelIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCancelIEs_id_Cause */
   case T_NGAP_PDU_Contents_HandoverCancelIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._HandoverCancelIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_HandoverCancelIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancel_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverCancel_protocolIEs (OSCTXT* pctxt, HandoverCancel_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancel_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_HandoverCancel_protocolIEs_element (pctxt, ((HandoverCancel_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancel_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverCancel (OSCTXT* pctxt, HandoverCancel* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCancel");

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancel: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_HandoverCancel_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancel: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_HandoverCancelAcknowledge_protocolIEs_element (OSCTXT* pctxt, HandoverCancelAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancelAcknowledge_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancelAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverCancelAcknowledge_protocolIEs (OSCTXT* pctxt, HandoverCancelAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancelAcknowledge_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_HandoverCancelAcknowledge_protocolIEs_element (pctxt, ((HandoverCancelAcknowledge_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancelAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_HandoverCancelAcknowledge (OSCTXT* pctxt, HandoverCancelAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCancelAcknowledge");

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancelAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_HandoverCancelAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_HandoverCancelAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UplinkRANStatusTransfer_protocolIEs_element (OSCTXT* pctxt, UplinkRANStatusTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANStatusTransfer_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer */
   case T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer");

      stat = asn1PE_RANStatusTransfer_TransparentContainer (pctxt, (RANStatusTransfer_TransparentContainer*)pvalue->value.u._UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANStatusTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UplinkRANStatusTransfer_protocolIEs (OSCTXT* pctxt, UplinkRANStatusTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANStatusTransfer_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UplinkRANStatusTransfer_protocolIEs_element (pctxt, ((UplinkRANStatusTransfer_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANStatusTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UplinkRANStatusTransfer (OSCTXT* pctxt, UplinkRANStatusTransfer* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkRANStatusTransfer");

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANStatusTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UplinkRANStatusTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANStatusTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DownlinkRANStatusTransfer_protocolIEs_element (OSCTXT* pctxt, DownlinkRANStatusTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANStatusTransfer_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer */
   case T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer");

      stat = asn1PE_RANStatusTransfer_TransparentContainer (pctxt, (RANStatusTransfer_TransparentContainer*)pvalue->value.u._DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANStatusTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_DownlinkRANStatusTransfer_protocolIEs (OSCTXT* pctxt, DownlinkRANStatusTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANStatusTransfer_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_DownlinkRANStatusTransfer_protocolIEs_element (pctxt, ((DownlinkRANStatusTransfer_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANStatusTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_DownlinkRANStatusTransfer (OSCTXT* pctxt, DownlinkRANStatusTransfer* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkRANStatusTransfer");

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANStatusTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_DownlinkRANStatusTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANStatusTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_Paging_protocolIEs_element (OSCTXT* pctxt, Paging_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_Paging_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PagingIEs_id_UEPagingIdentity */
   case T_NGAP_PDU_Contents_PagingIEs_id_UEPagingIdentity:
      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_UEPagingIdentity");

      stat = asn1PE_UEPagingIdentity (pctxt, (UEPagingIdentity*)pvalue->value.u._PagingIEs_id_UEPagingIdentity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PagingIEs_id_PagingDRX */
   case T_NGAP_PDU_Contents_PagingIEs_id_PagingDRX:
      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_PagingDRX");

      stat = asn1PE_PagingDRX (pctxt, pvalue->value.u._PagingIEs_id_PagingDRX);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PagingIEs_id_TAIListForPaging */
   case T_NGAP_PDU_Contents_PagingIEs_id_TAIListForPaging:
      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_TAIListForPaging");

      stat = asn1PE_TAIListForPaging (pctxt, pvalue->value.u._PagingIEs_id_TAIListForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PagingIEs_id_PagingPriority */
   case T_NGAP_PDU_Contents_PagingIEs_id_PagingPriority:
      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_PagingPriority");

      stat = asn1PE_PagingPriority (pctxt, pvalue->value.u._PagingIEs_id_PagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PagingIEs_id_UERadioCapabilityForPaging */
   case T_NGAP_PDU_Contents_PagingIEs_id_UERadioCapabilityForPaging:
      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_UERadioCapabilityForPaging");

      stat = asn1PE_UERadioCapabilityForPaging (pctxt, (UERadioCapabilityForPaging*)pvalue->value.u._PagingIEs_id_UERadioCapabilityForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PagingIEs_id_PagingOrigin */
   case T_NGAP_PDU_Contents_PagingIEs_id_PagingOrigin:
      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_PagingOrigin");

      stat = asn1PE_PagingOrigin (pctxt, pvalue->value.u._PagingIEs_id_PagingOrigin);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PagingIEs_id_AssistanceDataForPaging */
   case T_NGAP_PDU_Contents_PagingIEs_id_AssistanceDataForPaging:
      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_AssistanceDataForPaging");

      stat = asn1PE_AssistanceDataForPaging (pctxt, (AssistanceDataForPaging*)pvalue->value.u._PagingIEs_id_AssistanceDataForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PagingIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_Paging_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_Paging_protocolIEs (OSCTXT* pctxt, Paging_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_Paging_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_Paging_protocolIEs_element (pctxt, ((Paging_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Paging_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_Paging (OSCTXT* pctxt, Paging* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Paging");

   RTDIAGSTRM2 (pctxt, "asn1PE_Paging: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_Paging_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_Paging: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_InitialUEMessage_protocolIEs_element (OSCTXT* pctxt, InitialUEMessage_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialUEMessage_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _InitialUEMessage_IEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._InitialUEMessage_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialUEMessage_IEs_id_NAS_PDU */
   case T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_NAS_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_NAS_PDU");

      stat = asn1PE_NAS_PDU (pctxt, *pvalue->value.u._InitialUEMessage_IEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialUEMessage_IEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._InitialUEMessage_IEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialUEMessage_IEs_id_RRCEstablishmentCause */
   case T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_RRCEstablishmentCause:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_RRCEstablishmentCause");

      stat = asn1PE_RRCEstablishmentCause (pctxt, pvalue->value.u._InitialUEMessage_IEs_id_RRCEstablishmentCause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialUEMessage_IEs_id_FiveG_S_TMSI */
   case T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_FiveG_S_TMSI:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_FiveG_S_TMSI");

      stat = asn1PE_FiveG_S_TMSI (pctxt, (FiveG_S_TMSI*)pvalue->value.u._InitialUEMessage_IEs_id_FiveG_S_TMSI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialUEMessage_IEs_id_AMFSetID */
   case T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_AMFSetID:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_AMFSetID");

      stat = asn1PE_AMFSetID (pctxt, *pvalue->value.u._InitialUEMessage_IEs_id_AMFSetID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialUEMessage_IEs_id_UEContextRequest */
   case T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_UEContextRequest:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_UEContextRequest");

      stat = asn1PE_UEContextRequest (pctxt, pvalue->value.u._InitialUEMessage_IEs_id_UEContextRequest);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialUEMessage_IEs_id_AllowedNSSAI */
   case T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_AllowedNSSAI:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_AllowedNSSAI");

      stat = asn1PE_AllowedNSSAI (pctxt, pvalue->value.u._InitialUEMessage_IEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute */
   case T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute:
      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute");

      stat = asn1PE_SourceToTarget_AMFInformationReroute (pctxt, (SourceToTarget_AMFInformationReroute*)pvalue->value.u._InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_InitialUEMessage_IEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialUEMessage_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_InitialUEMessage_protocolIEs (OSCTXT* pctxt, InitialUEMessage_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialUEMessage_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_InitialUEMessage_protocolIEs_element (pctxt, ((InitialUEMessage_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialUEMessage_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_InitialUEMessage (OSCTXT* pctxt, InitialUEMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialUEMessage");

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialUEMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_InitialUEMessage_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_InitialUEMessage: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DownlinkNASTransport_protocolIEs_element (OSCTXT* pctxt, DownlinkNASTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNASTransport_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkNASTransport_IEs_id_OldAMF */
   case T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_OldAMF:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_OldAMF");

      stat = asn1PE_AMFName (pctxt, pvalue->value.u._DownlinkNASTransport_IEs_id_OldAMF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkNASTransport_IEs_id_RANPagingPriority */
   case T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_RANPagingPriority:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_RANPagingPriority");

      stat = asn1PE_RANPagingPriority (pctxt, pvalue->value.u._DownlinkNASTransport_IEs_id_RANPagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkNASTransport_IEs_id_NAS_PDU */
   case T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_NAS_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_NAS_PDU");

      stat = asn1PE_NAS_PDU (pctxt, *pvalue->value.u._DownlinkNASTransport_IEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkNASTransport_IEs_id_MobilityRestrictionList */
   case T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_MobilityRestrictionList:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_MobilityRestrictionList");

      stat = asn1PE_MobilityRestrictionList (pctxt, (MobilityRestrictionList*)pvalue->value.u._DownlinkNASTransport_IEs_id_MobilityRestrictionList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkNASTransport_IEs_id_IndexToRFSP */
   case T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_IndexToRFSP:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_IndexToRFSP");

      stat = asn1PE_IndexToRFSP (pctxt, pvalue->value.u._DownlinkNASTransport_IEs_id_IndexToRFSP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate */
   case T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate");

      stat = asn1PE_UEAggregateMaximumBitRate (pctxt, (UEAggregateMaximumBitRate*)pvalue->value.u._DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkNASTransport_IEs_id_AllowedNSSAI */
   case T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_AllowedNSSAI:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_AllowedNSSAI");

      stat = asn1PE_AllowedNSSAI (pctxt, pvalue->value.u._DownlinkNASTransport_IEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNASTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_DownlinkNASTransport_protocolIEs (OSCTXT* pctxt, DownlinkNASTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNASTransport_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_DownlinkNASTransport_protocolIEs_element (pctxt, ((DownlinkNASTransport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNASTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_DownlinkNASTransport (OSCTXT* pctxt, DownlinkNASTransport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkNASTransport");

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNASTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_DownlinkNASTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNASTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UplinkNASTransport_protocolIEs_element (OSCTXT* pctxt, UplinkNASTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNASTransport_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UplinkNASTransport_IEs_id_NAS_PDU */
   case T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_NAS_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_NAS_PDU");

      stat = asn1PE_NAS_PDU (pctxt, *pvalue->value.u._UplinkNASTransport_IEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UplinkNASTransport_IEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._UplinkNASTransport_IEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UplinkNASTransport_IEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNASTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UplinkNASTransport_protocolIEs (OSCTXT* pctxt, UplinkNASTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNASTransport_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UplinkNASTransport_protocolIEs_element (pctxt, ((UplinkNASTransport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNASTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UplinkNASTransport (OSCTXT* pctxt, UplinkNASTransport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkNASTransport");

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNASTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UplinkNASTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNASTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_NASNonDeliveryIndication_protocolIEs_element (OSCTXT* pctxt, NASNonDeliveryIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NASNonDeliveryIndication_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NASNonDeliveryIndication_IEs_id_NAS_PDU */
   case T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_NAS_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_NAS_PDU");

      stat = asn1PE_NAS_PDU (pctxt, *pvalue->value.u._NASNonDeliveryIndication_IEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NASNonDeliveryIndication_IEs_id_Cause */
   case T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._NASNonDeliveryIndication_IEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_NASNonDeliveryIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_NASNonDeliveryIndication_protocolIEs (OSCTXT* pctxt, NASNonDeliveryIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NASNonDeliveryIndication_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_NASNonDeliveryIndication_protocolIEs_element (pctxt, ((NASNonDeliveryIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NASNonDeliveryIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_NASNonDeliveryIndication (OSCTXT* pctxt, NASNonDeliveryIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NASNonDeliveryIndication");

   RTDIAGSTRM2 (pctxt, "asn1PE_NASNonDeliveryIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_NASNonDeliveryIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NASNonDeliveryIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RerouteNASRequest_protocolIEs_element (OSCTXT* pctxt, RerouteNASRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RerouteNASRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RerouteNASRequest_IEs_id_NGAP_Message */
   case T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_NGAP_Message:
      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_NGAP_Message");

      stat = asn1PE__RerouteNASRequest_IEs_Value (pctxt, pvalue->value.u._RerouteNASRequest_IEs_id_NGAP_Message);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RerouteNASRequest_IEs_id_AMFSetID */
   case T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_AMFSetID:
      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_AMFSetID");

      stat = asn1PE_AMFSetID (pctxt, *pvalue->value.u._RerouteNASRequest_IEs_id_AMFSetID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RerouteNASRequest_IEs_id_AllowedNSSAI */
   case T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_AllowedNSSAI:
      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_AllowedNSSAI");

      stat = asn1PE_AllowedNSSAI (pctxt, pvalue->value.u._RerouteNASRequest_IEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute */
   case T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute:
      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute");

      stat = asn1PE_SourceToTarget_AMFInformationReroute (pctxt, (SourceToTarget_AMFInformationReroute*)pvalue->value.u._RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_RerouteNASRequest_IEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_RerouteNASRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_RerouteNASRequest_protocolIEs (OSCTXT* pctxt, RerouteNASRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RerouteNASRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_RerouteNASRequest_protocolIEs_element (pctxt, ((RerouteNASRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RerouteNASRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_RerouteNASRequest (OSCTXT* pctxt, RerouteNASRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RerouteNASRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_RerouteNASRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_RerouteNASRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RerouteNASRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_NGSetupRequest_protocolIEs_element (OSCTXT* pctxt, NGSetupRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _NGSetupRequestIEs_id_GlobalRANNodeID */
   case T_NGAP_PDU_Contents_NGSetupRequestIEs_id_GlobalRANNodeID:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_GlobalRANNodeID");

      stat = asn1PE_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.u._NGSetupRequestIEs_id_GlobalRANNodeID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupRequestIEs_id_RANNodeName */
   case T_NGAP_PDU_Contents_NGSetupRequestIEs_id_RANNodeName:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_RANNodeName");

      stat = asn1PE_RANNodeName (pctxt, pvalue->value.u._NGSetupRequestIEs_id_RANNodeName);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupRequestIEs_id_SupportedTAList */
   case T_NGAP_PDU_Contents_NGSetupRequestIEs_id_SupportedTAList:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_SupportedTAList");

      stat = asn1PE_SupportedTAList (pctxt, pvalue->value.u._NGSetupRequestIEs_id_SupportedTAList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupRequestIEs_id_DefaultPagingDRX */
   case T_NGAP_PDU_Contents_NGSetupRequestIEs_id_DefaultPagingDRX:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_DefaultPagingDRX");

      stat = asn1PE_PagingDRX (pctxt, pvalue->value.u._NGSetupRequestIEs_id_DefaultPagingDRX);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupRequestIEs_id_UERetentionInformation */
   case T_NGAP_PDU_Contents_NGSetupRequestIEs_id_UERetentionInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_UERetentionInformation");

      stat = asn1PE_UERetentionInformation (pctxt, pvalue->value.u._NGSetupRequestIEs_id_UERetentionInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_NGSetupRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_NGSetupRequest_protocolIEs (OSCTXT* pctxt, NGSetupRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_NGSetupRequest_protocolIEs_element (pctxt, ((NGSetupRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_NGSetupRequest (OSCTXT* pctxt, NGSetupRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGSetupRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_NGSetupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_NGSetupResponse_protocolIEs_element (OSCTXT* pctxt, NGSetupResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupResponse_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _NGSetupResponseIEs_id_AMFName */
   case T_NGAP_PDU_Contents_NGSetupResponseIEs_id_AMFName:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_AMFName");

      stat = asn1PE_AMFName (pctxt, pvalue->value.u._NGSetupResponseIEs_id_AMFName);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupResponseIEs_id_ServedGUAMIList */
   case T_NGAP_PDU_Contents_NGSetupResponseIEs_id_ServedGUAMIList:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_ServedGUAMIList");

      stat = asn1PE_ServedGUAMIList (pctxt, pvalue->value.u._NGSetupResponseIEs_id_ServedGUAMIList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupResponseIEs_id_RelativeAMFCapacity */
   case T_NGAP_PDU_Contents_NGSetupResponseIEs_id_RelativeAMFCapacity:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_RelativeAMFCapacity");

      stat = asn1PE_RelativeAMFCapacity (pctxt, pvalue->value.u._NGSetupResponseIEs_id_RelativeAMFCapacity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupResponseIEs_id_PLMNSupportList */
   case T_NGAP_PDU_Contents_NGSetupResponseIEs_id_PLMNSupportList:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_PLMNSupportList");

      stat = asn1PE_PLMNSupportList (pctxt, pvalue->value.u._NGSetupResponseIEs_id_PLMNSupportList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupResponseIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_NGSetupResponseIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._NGSetupResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupResponseIEs_id_UERetentionInformation */
   case T_NGAP_PDU_Contents_NGSetupResponseIEs_id_UERetentionInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_UERetentionInformation");

      stat = asn1PE_UERetentionInformation (pctxt, pvalue->value.u._NGSetupResponseIEs_id_UERetentionInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_NGSetupResponseIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_NGSetupResponse_protocolIEs (OSCTXT* pctxt, NGSetupResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupResponse_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_NGSetupResponse_protocolIEs_element (pctxt, ((NGSetupResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_NGSetupResponse (OSCTXT* pctxt, NGSetupResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGSetupResponse");

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_NGSetupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_NGSetupFailure_protocolIEs_element (OSCTXT* pctxt, NGSetupFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupFailure_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _NGSetupFailureIEs_id_Cause */
   case T_NGAP_PDU_Contents_NGSetupFailureIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupFailureIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._NGSetupFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupFailureIEs_id_TimeToWait */
   case T_NGAP_PDU_Contents_NGSetupFailureIEs_id_TimeToWait:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupFailureIEs_id_TimeToWait");

      stat = asn1PE_TimeToWait (pctxt, pvalue->value.u._NGSetupFailureIEs_id_TimeToWait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGSetupFailureIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_NGSetupFailureIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupFailureIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._NGSetupFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_NGSetupFailureIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_NGSetupFailure_protocolIEs (OSCTXT* pctxt, NGSetupFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupFailure_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_NGSetupFailure_protocolIEs_element (pctxt, ((NGSetupFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_NGSetupFailure (OSCTXT* pctxt, NGSetupFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGSetupFailure");

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_NGSetupFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NGSetupFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RANConfigurationUpdate_protocolIEs_element (OSCTXT* pctxt, RANConfigurationUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdate_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _RANConfigurationUpdateIEs_id_RANNodeName */
   case T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_RANNodeName:
      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_RANNodeName");

      stat = asn1PE_RANNodeName (pctxt, pvalue->value.u._RANConfigurationUpdateIEs_id_RANNodeName);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RANConfigurationUpdateIEs_id_SupportedTAList */
   case T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_SupportedTAList:
      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_SupportedTAList");

      stat = asn1PE_SupportedTAList (pctxt, pvalue->value.u._RANConfigurationUpdateIEs_id_SupportedTAList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RANConfigurationUpdateIEs_id_DefaultPagingDRX */
   case T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_DefaultPagingDRX:
      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_DefaultPagingDRX");

      stat = asn1PE_PagingDRX (pctxt, pvalue->value.u._RANConfigurationUpdateIEs_id_DefaultPagingDRX);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RANConfigurationUpdateIEs_id_GlobalRANNodeID */
   case T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_GlobalRANNodeID:
      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_GlobalRANNodeID");

      stat = asn1PE_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.u._RANConfigurationUpdateIEs_id_GlobalRANNodeID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList */
   case T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList:
      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList");

      stat = asn1PE_NGRAN_TNLAssociationToRemoveList (pctxt, pvalue->value.u._RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdate_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_RANConfigurationUpdate_protocolIEs (OSCTXT* pctxt, RANConfigurationUpdate_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdate_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_RANConfigurationUpdate_protocolIEs_element (pctxt, ((RANConfigurationUpdate_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdate_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_RANConfigurationUpdate (OSCTXT* pctxt, RANConfigurationUpdate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANConfigurationUpdate");

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_RANConfigurationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RANConfigurationUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, RANConfigurationUpdateAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateAcknowledge_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, pvalue->value.u._RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_RANConfigurationUpdateAcknowledgeIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_RANConfigurationUpdateAcknowledge_protocolIEs (OSCTXT* pctxt, RANConfigurationUpdateAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateAcknowledge_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_RANConfigurationUpdateAcknowledge_protocolIEs_element (pctxt, ((RANConfigurationUpdateAcknowledge_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_RANConfigurationUpdateAcknowledge (OSCTXT* pctxt, RANConfigurationUpdateAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANConfigurationUpdateAcknowledge");

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_RANConfigurationUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_RANConfigurationUpdateFailure_protocolIEs_element (OSCTXT* pctxt, RANConfigurationUpdateFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateFailure_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _RANConfigurationUpdateFailureIEs_id_Cause */
   case T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateFailureIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._RANConfigurationUpdateFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RANConfigurationUpdateFailureIEs_id_TimeToWait */
   case T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_id_TimeToWait:
      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateFailureIEs_id_TimeToWait");

      stat = asn1PE_TimeToWait (pctxt, pvalue->value.u._RANConfigurationUpdateFailureIEs_id_TimeToWait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_RANConfigurationUpdateFailure_protocolIEs (OSCTXT* pctxt, RANConfigurationUpdateFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateFailure_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_RANConfigurationUpdateFailure_protocolIEs_element (pctxt, ((RANConfigurationUpdateFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_RANConfigurationUpdateFailure (OSCTXT* pctxt, RANConfigurationUpdateFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANConfigurationUpdateFailure");

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_RANConfigurationUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_RANConfigurationUpdateFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_AMFConfigurationUpdate_protocolIEs_element (OSCTXT* pctxt, AMFConfigurationUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdate_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _AMFConfigurationUpdateIEs_id_AMFName */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMFName:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMFName");

      stat = asn1PE_AMFName (pctxt, pvalue->value.u._AMFConfigurationUpdateIEs_id_AMFName);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _AMFConfigurationUpdateIEs_id_ServedGUAMIList */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_ServedGUAMIList:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_ServedGUAMIList");

      stat = asn1PE_ServedGUAMIList (pctxt, pvalue->value.u._AMFConfigurationUpdateIEs_id_ServedGUAMIList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _AMFConfigurationUpdateIEs_id_RelativeAMFCapacity */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_RelativeAMFCapacity:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_RelativeAMFCapacity");

      stat = asn1PE_RelativeAMFCapacity (pctxt, pvalue->value.u._AMFConfigurationUpdateIEs_id_RelativeAMFCapacity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _AMFConfigurationUpdateIEs_id_PLMNSupportList */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_PLMNSupportList:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_PLMNSupportList");

      stat = asn1PE_PLMNSupportList (pctxt, pvalue->value.u._AMFConfigurationUpdateIEs_id_PLMNSupportList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList");

      stat = asn1PE_AMF_TNLAssociationToAddList (pctxt, pvalue->value.u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList");

      stat = asn1PE_AMF_TNLAssociationToRemoveList (pctxt, pvalue->value.u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList");

      stat = asn1PE_AMF_TNLAssociationToUpdateList (pctxt, pvalue->value.u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdate_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_AMFConfigurationUpdate_protocolIEs (OSCTXT* pctxt, AMFConfigurationUpdate_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdate_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_AMFConfigurationUpdate_protocolIEs_element (pctxt, ((AMFConfigurationUpdate_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdate_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_AMFConfigurationUpdate (OSCTXT* pctxt, AMFConfigurationUpdate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFConfigurationUpdate");

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_AMFConfigurationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_AMFConfigurationUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, AMFConfigurationUpdateAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateAcknowledge_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList");

      stat = asn1PE_AMF_TNLAssociationSetupList (pctxt, pvalue->value.u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList");

      stat = asn1PE_TNLAssociationList (pctxt, pvalue->value.u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_AMFConfigurationUpdateAcknowledge_protocolIEs (OSCTXT* pctxt, AMFConfigurationUpdateAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateAcknowledge_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_AMFConfigurationUpdateAcknowledge_protocolIEs_element (pctxt, ((AMFConfigurationUpdateAcknowledge_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_AMFConfigurationUpdateAcknowledge (OSCTXT* pctxt, AMFConfigurationUpdateAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFConfigurationUpdateAcknowledge");

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_AMFConfigurationUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_AMFConfigurationUpdateFailure_protocolIEs_element (OSCTXT* pctxt, AMFConfigurationUpdateFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateFailure_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _AMFConfigurationUpdateFailureIEs_id_Cause */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateFailureIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._AMFConfigurationUpdateFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _AMFConfigurationUpdateFailureIEs_id_TimeToWait */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_id_TimeToWait:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateFailureIEs_id_TimeToWait");

      stat = asn1PE_TimeToWait (pctxt, pvalue->value.u._AMFConfigurationUpdateFailureIEs_id_TimeToWait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_AMFConfigurationUpdateFailure_protocolIEs (OSCTXT* pctxt, AMFConfigurationUpdateFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateFailure_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_AMFConfigurationUpdateFailure_protocolIEs_element (pctxt, ((AMFConfigurationUpdateFailure_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_AMFConfigurationUpdateFailure (OSCTXT* pctxt, AMFConfigurationUpdateFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFConfigurationUpdateFailure");

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_AMFConfigurationUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFConfigurationUpdateFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_AMFStatusIndication_protocolIEs_element (OSCTXT* pctxt, AMFStatusIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFStatusIndication_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _AMFStatusIndicationIEs_id_UnavailableGUAMIList */
   case T_NGAP_PDU_Contents_AMFStatusIndicationIEs_id_UnavailableGUAMIList:
      RTXCTXTPUSHELEMNAME (pctxt, "_AMFStatusIndicationIEs_id_UnavailableGUAMIList");

      stat = asn1PE_UnavailableGUAMIList (pctxt, pvalue->value.u._AMFStatusIndicationIEs_id_UnavailableGUAMIList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_AMFStatusIndicationIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFStatusIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_AMFStatusIndication_protocolIEs (OSCTXT* pctxt, AMFStatusIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFStatusIndication_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_AMFStatusIndication_protocolIEs_element (pctxt, ((AMFStatusIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFStatusIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_AMFStatusIndication (OSCTXT* pctxt, AMFStatusIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFStatusIndication");

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFStatusIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_AMFStatusIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_AMFStatusIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_NGReset_protocolIEs_element (OSCTXT* pctxt, NGReset_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NGReset_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _NGResetIEs_id_Cause */
   case T_NGAP_PDU_Contents_NGResetIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGResetIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._NGResetIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGResetIEs_id_ResetType */
   case T_NGAP_PDU_Contents_NGResetIEs_id_ResetType:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGResetIEs_id_ResetType");

      stat = asn1PE_ResetType (pctxt, (ResetType*)pvalue->value.u._NGResetIEs_id_ResetType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_NGResetIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_NGReset_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_NGReset_protocolIEs (OSCTXT* pctxt, NGReset_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NGReset_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_NGReset_protocolIEs_element (pctxt, ((NGReset_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NGReset_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_NGReset (OSCTXT* pctxt, NGReset* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGReset");

   RTDIAGSTRM2 (pctxt, "asn1PE_NGReset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_NGReset_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NGReset: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_NGResetAcknowledge_protocolIEs_element (OSCTXT* pctxt, NGResetAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_NGResetAcknowledge_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList */
   case T_NGAP_PDU_Contents_NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList");

      stat = asn1PE_UE_associatedLogicalNG_connectionList (pctxt, pvalue->value.u._NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _NGResetAcknowledgeIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_NGResetAcknowledgeIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_NGResetAcknowledgeIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._NGResetAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_NGResetAcknowledgeIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_NGResetAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_NGResetAcknowledge_protocolIEs (OSCTXT* pctxt, NGResetAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_NGResetAcknowledge_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_NGResetAcknowledge_protocolIEs_element (pctxt, ((NGResetAcknowledge_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NGResetAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_NGResetAcknowledge (OSCTXT* pctxt, NGResetAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGResetAcknowledge");

   RTDIAGSTRM2 (pctxt, "asn1PE_NGResetAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_NGResetAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_NGResetAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ErrorIndication_protocolIEs_element (OSCTXT* pctxt, ErrorIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_ErrorIndication_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _ErrorIndicationIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_ErrorIndicationIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._ErrorIndicationIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _ErrorIndicationIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_ErrorIndicationIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._ErrorIndicationIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _ErrorIndicationIEs_id_Cause */
   case T_NGAP_PDU_Contents_ErrorIndicationIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._ErrorIndicationIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _ErrorIndicationIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_ErrorIndicationIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._ErrorIndicationIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_ErrorIndicationIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_ErrorIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_ErrorIndication_protocolIEs (OSCTXT* pctxt, ErrorIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_ErrorIndication_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ErrorIndication_protocolIEs_element (pctxt, ((ErrorIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ErrorIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_ErrorIndication (OSCTXT* pctxt, ErrorIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ErrorIndication");

   RTDIAGSTRM2 (pctxt, "asn1PE_ErrorIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_ErrorIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_OverloadStart_protocolIEs_element (OSCTXT* pctxt, OverloadStart_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStart_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _OverloadStartIEs_id_AMFOverloadResponse */
   case T_NGAP_PDU_Contents_OverloadStartIEs_id_AMFOverloadResponse:
      RTXCTXTPUSHELEMNAME (pctxt, "_OverloadStartIEs_id_AMFOverloadResponse");

      stat = asn1PE_OverloadResponse (pctxt, (OverloadResponse*)pvalue->value.u._OverloadStartIEs_id_AMFOverloadResponse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _OverloadStartIEs_id_AMFTrafficLoadReductionIndication */
   case T_NGAP_PDU_Contents_OverloadStartIEs_id_AMFTrafficLoadReductionIndication:
      RTXCTXTPUSHELEMNAME (pctxt, "_OverloadStartIEs_id_AMFTrafficLoadReductionIndication");

      stat = asn1PE_TrafficLoadReductionIndication (pctxt, pvalue->value.u._OverloadStartIEs_id_AMFTrafficLoadReductionIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _OverloadStartIEs_id_OverloadStartNSSAIList */
   case T_NGAP_PDU_Contents_OverloadStartIEs_id_OverloadStartNSSAIList:
      RTXCTXTPUSHELEMNAME (pctxt, "_OverloadStartIEs_id_OverloadStartNSSAIList");

      stat = asn1PE_OverloadStartNSSAIList (pctxt, pvalue->value.u._OverloadStartIEs_id_OverloadStartNSSAIList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_OverloadStartIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStart_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_OverloadStart_protocolIEs (OSCTXT* pctxt, OverloadStart_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStart_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_OverloadStart_protocolIEs_element (pctxt, ((OverloadStart_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStart_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_OverloadStart (OSCTXT* pctxt, OverloadStart* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OverloadStart");

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStart: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_OverloadStart_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStart: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_OverloadStop_protocolIEs_element (OSCTXT* pctxt, OverloadStop_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStop_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pe_OpenType (pctxt, pvalue->value.numocts, pvalue->value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStop_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_OverloadStop_protocolIEs (OSCTXT* pctxt, OverloadStop_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStop_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_OverloadStop_protocolIEs_element (pctxt, ((OverloadStop_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStop_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_OverloadStop (OSCTXT* pctxt, OverloadStop* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OverloadStop");

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStop: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_OverloadStop_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_OverloadStop: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UplinkRANConfigurationTransfer_protocolIEs_element (OSCTXT* pctxt, UplinkRANConfigurationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANConfigurationTransfer_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL */
   case T_NGAP_PDU_Contents_UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL");

      stat = asn1PE_SONConfigurationTransfer (pctxt, (SONConfigurationTransfer*)pvalue->value.u._UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL */
   case T_NGAP_PDU_Contents_UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL");

      stat = asn1PE_EN_DCSONConfigurationTransfer (pctxt, *pvalue->value.u._UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UplinkRANConfigurationTransferIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANConfigurationTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UplinkRANConfigurationTransfer_protocolIEs (OSCTXT* pctxt, UplinkRANConfigurationTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANConfigurationTransfer_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UplinkRANConfigurationTransfer_protocolIEs_element (pctxt, ((UplinkRANConfigurationTransfer_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANConfigurationTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UplinkRANConfigurationTransfer (OSCTXT* pctxt, UplinkRANConfigurationTransfer* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkRANConfigurationTransfer");

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANConfigurationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UplinkRANConfigurationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkRANConfigurationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DownlinkRANConfigurationTransfer_protocolIEs_element (OSCTXT* pctxt, DownlinkRANConfigurationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANConfigurationTransfer_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL */
   case T_NGAP_PDU_Contents_DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL");

      stat = asn1PE_SONConfigurationTransfer (pctxt, (SONConfigurationTransfer*)pvalue->value.u._DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL */
   case T_NGAP_PDU_Contents_DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL");

      stat = asn1PE_EN_DCSONConfigurationTransfer (pctxt, *pvalue->value.u._DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_DownlinkRANConfigurationTransferIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANConfigurationTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_DownlinkRANConfigurationTransfer_protocolIEs (OSCTXT* pctxt, DownlinkRANConfigurationTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANConfigurationTransfer_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_DownlinkRANConfigurationTransfer_protocolIEs_element (pctxt, ((DownlinkRANConfigurationTransfer_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANConfigurationTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_DownlinkRANConfigurationTransfer (OSCTXT* pctxt, DownlinkRANConfigurationTransfer* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkRANConfigurationTransfer");

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANConfigurationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_DownlinkRANConfigurationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkRANConfigurationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_WriteReplaceWarningRequest_protocolIEs_element (OSCTXT* pctxt, WriteReplaceWarningRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _WriteReplaceWarningRequestIEs_id_MessageIdentifier */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_MessageIdentifier:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_MessageIdentifier");

      stat = asn1PE_MessageIdentifier (pctxt, *pvalue->value.u._WriteReplaceWarningRequestIEs_id_MessageIdentifier);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningRequestIEs_id_SerialNumber */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_SerialNumber:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_SerialNumber");

      stat = asn1PE_SerialNumber (pctxt, *pvalue->value.u._WriteReplaceWarningRequestIEs_id_SerialNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningRequestIEs_id_WarningAreaList */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningAreaList:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningAreaList");

      stat = asn1PE_WarningAreaList (pctxt, (WarningAreaList*)pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningAreaList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningRequestIEs_id_RepetitionPeriod */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_RepetitionPeriod:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_RepetitionPeriod");

      stat = asn1PE_RepetitionPeriod (pctxt, pvalue->value.u._WriteReplaceWarningRequestIEs_id_RepetitionPeriod);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested");

      stat = asn1PE_NumberOfBroadcastsRequested (pctxt, pvalue->value.u._WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningRequestIEs_id_WarningType */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningType:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningType");

      stat = asn1PE_WarningType (pctxt, (WarningType*)pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningRequestIEs_id_WarningSecurityInfo */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningSecurityInfo:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningSecurityInfo");

      stat = asn1PE_WarningSecurityInfo (pctxt, (WarningSecurityInfo*)pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningSecurityInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningRequestIEs_id_DataCodingScheme */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_DataCodingScheme:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_DataCodingScheme");

      stat = asn1PE_DataCodingScheme (pctxt, *pvalue->value.u._WriteReplaceWarningRequestIEs_id_DataCodingScheme);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningRequestIEs_id_WarningMessageContents */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningMessageContents:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningMessageContents");

      stat = asn1PE_WarningMessageContents (pctxt, (WarningMessageContents*)pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningMessageContents);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd");

      stat = asn1PE_ConcurrentWarningMessageInd (pctxt, pvalue->value.u._WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates */
   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates");

      stat = asn1PE_WarningAreaCoordinates (pctxt, (WarningAreaCoordinates*)pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_WriteReplaceWarningRequest_protocolIEs (OSCTXT* pctxt, WriteReplaceWarningRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_WriteReplaceWarningRequest_protocolIEs_element (pctxt, ((WriteReplaceWarningRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_WriteReplaceWarningRequest (OSCTXT* pctxt, WriteReplaceWarningRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "WriteReplaceWarningRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_WriteReplaceWarningRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_WriteReplaceWarningResponse_protocolIEs_element (OSCTXT* pctxt, WriteReplaceWarningResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningResponse_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _WriteReplaceWarningResponseIEs_id_MessageIdentifier */
   case T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_MessageIdentifier:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_MessageIdentifier");

      stat = asn1PE_MessageIdentifier (pctxt, *pvalue->value.u._WriteReplaceWarningResponseIEs_id_MessageIdentifier);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningResponseIEs_id_SerialNumber */
   case T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_SerialNumber:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_SerialNumber");

      stat = asn1PE_SerialNumber (pctxt, *pvalue->value.u._WriteReplaceWarningResponseIEs_id_SerialNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList */
   case T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList");

      stat = asn1PE_BroadcastCompletedAreaList (pctxt, (BroadcastCompletedAreaList*)pvalue->value.u._WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_WriteReplaceWarningResponse_protocolIEs (OSCTXT* pctxt, WriteReplaceWarningResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningResponse_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_WriteReplaceWarningResponse_protocolIEs_element (pctxt, ((WriteReplaceWarningResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_WriteReplaceWarningResponse (OSCTXT* pctxt, WriteReplaceWarningResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "WriteReplaceWarningResponse");

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_WriteReplaceWarningResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_WriteReplaceWarningResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PWSCancelRequest_protocolIEs_element (OSCTXT* pctxt, PWSCancelRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PWSCancelRequestIEs_id_MessageIdentifier */
   case T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_MessageIdentifier:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_MessageIdentifier");

      stat = asn1PE_MessageIdentifier (pctxt, *pvalue->value.u._PWSCancelRequestIEs_id_MessageIdentifier);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PWSCancelRequestIEs_id_SerialNumber */
   case T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_SerialNumber:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_SerialNumber");

      stat = asn1PE_SerialNumber (pctxt, *pvalue->value.u._PWSCancelRequestIEs_id_SerialNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PWSCancelRequestIEs_id_WarningAreaList */
   case T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_WarningAreaList:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_WarningAreaList");

      stat = asn1PE_WarningAreaList (pctxt, (WarningAreaList*)pvalue->value.u._PWSCancelRequestIEs_id_WarningAreaList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PWSCancelRequestIEs_id_CancelAllWarningMessages */
   case T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_CancelAllWarningMessages:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_CancelAllWarningMessages");

      stat = asn1PE_CancelAllWarningMessages (pctxt, pvalue->value.u._PWSCancelRequestIEs_id_CancelAllWarningMessages);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PWSCancelRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PWSCancelRequest_protocolIEs (OSCTXT* pctxt, PWSCancelRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PWSCancelRequest_protocolIEs_element (pctxt, ((PWSCancelRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PWSCancelRequest (OSCTXT* pctxt, PWSCancelRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSCancelRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PWSCancelRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PWSCancelResponse_protocolIEs_element (OSCTXT* pctxt, PWSCancelResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelResponse_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PWSCancelResponseIEs_id_MessageIdentifier */
   case T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_MessageIdentifier:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_MessageIdentifier");

      stat = asn1PE_MessageIdentifier (pctxt, *pvalue->value.u._PWSCancelResponseIEs_id_MessageIdentifier);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PWSCancelResponseIEs_id_SerialNumber */
   case T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_SerialNumber:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_SerialNumber");

      stat = asn1PE_SerialNumber (pctxt, *pvalue->value.u._PWSCancelResponseIEs_id_SerialNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PWSCancelResponseIEs_id_BroadcastCancelledAreaList */
   case T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_BroadcastCancelledAreaList:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_BroadcastCancelledAreaList");

      stat = asn1PE_BroadcastCancelledAreaList (pctxt, (BroadcastCancelledAreaList*)pvalue->value.u._PWSCancelResponseIEs_id_BroadcastCancelledAreaList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PWSCancelResponseIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._PWSCancelResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PWSCancelResponseIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PWSCancelResponse_protocolIEs (OSCTXT* pctxt, PWSCancelResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelResponse_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PWSCancelResponse_protocolIEs_element (pctxt, ((PWSCancelResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PWSCancelResponse (OSCTXT* pctxt, PWSCancelResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSCancelResponse");

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PWSCancelResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSCancelResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PWSRestartIndication_protocolIEs_element (OSCTXT* pctxt, PWSRestartIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSRestartIndication_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PWSRestartIndicationIEs_id_CellIDListForRestart */
   case T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_CellIDListForRestart:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_CellIDListForRestart");

      stat = asn1PE_CellIDListForRestart (pctxt, (CellIDListForRestart*)pvalue->value.u._PWSRestartIndicationIEs_id_CellIDListForRestart);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PWSRestartIndicationIEs_id_GlobalRANNodeID */
   case T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_GlobalRANNodeID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_GlobalRANNodeID");

      stat = asn1PE_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.u._PWSRestartIndicationIEs_id_GlobalRANNodeID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PWSRestartIndicationIEs_id_TAIListForRestart */
   case T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_TAIListForRestart:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_TAIListForRestart");

      stat = asn1PE_TAIListForRestart (pctxt, pvalue->value.u._PWSRestartIndicationIEs_id_TAIListForRestart);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart */
   case T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart");

      stat = asn1PE_EmergencyAreaIDListForRestart (pctxt, (EmergencyAreaIDListForRestart*)pvalue->value.u._PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PWSRestartIndicationIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSRestartIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PWSRestartIndication_protocolIEs (OSCTXT* pctxt, PWSRestartIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSRestartIndication_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PWSRestartIndication_protocolIEs_element (pctxt, ((PWSRestartIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSRestartIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PWSRestartIndication (OSCTXT* pctxt, PWSRestartIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSRestartIndication");

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSRestartIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PWSRestartIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSRestartIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PWSFailureIndication_protocolIEs_element (OSCTXT* pctxt, PWSFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSFailureIndication_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _PWSFailureIndicationIEs_id_PWSFailedCellIDList */
   case T_NGAP_PDU_Contents_PWSFailureIndicationIEs_id_PWSFailedCellIDList:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSFailureIndicationIEs_id_PWSFailedCellIDList");

      stat = asn1PE_PWSFailedCellIDList (pctxt, (PWSFailedCellIDList*)pvalue->value.u._PWSFailureIndicationIEs_id_PWSFailedCellIDList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _PWSFailureIndicationIEs_id_GlobalRANNodeID */
   case T_NGAP_PDU_Contents_PWSFailureIndicationIEs_id_GlobalRANNodeID:
      RTXCTXTPUSHELEMNAME (pctxt, "_PWSFailureIndicationIEs_id_GlobalRANNodeID");

      stat = asn1PE_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.u._PWSFailureIndicationIEs_id_GlobalRANNodeID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_PWSFailureIndicationIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSFailureIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PWSFailureIndication_protocolIEs (OSCTXT* pctxt, PWSFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSFailureIndication_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PWSFailureIndication_protocolIEs_element (pctxt, ((PWSFailureIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSFailureIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PWSFailureIndication (OSCTXT* pctxt, PWSFailureIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSFailureIndication");

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_PWSFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PWSFailureIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, DownlinkUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID */
   case T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID");

      stat = asn1PE_RoutingID (pctxt, *pvalue->value.u._DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
   case T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

      stat = asn1PE_NRPPa_PDU (pctxt, *pvalue->value.u._DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_DownlinkUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, DownlinkUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, ((DownlinkUEAssociatedNRPPaTransport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_DownlinkUEAssociatedNRPPaTransport (OSCTXT* pctxt, DownlinkUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_DownlinkUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UplinkUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, UplinkUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID */
   case T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID");

      stat = asn1PE_RoutingID (pctxt, *pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
   case T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

      stat = asn1PE_NRPPa_PDU (pctxt, *pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UplinkUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, UplinkUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UplinkUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, ((UplinkUEAssociatedNRPPaTransport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UplinkUEAssociatedNRPPaTransport (OSCTXT* pctxt, UplinkUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UplinkUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID */
   case T_NGAP_PDU_Contents_DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID");

      stat = asn1PE_RoutingID (pctxt, *pvalue->value.u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
   case T_NGAP_PDU_Contents_DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

      stat = asn1PE_NRPPa_PDU (pctxt, *pvalue->value.u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_DownlinkNonUEAssociatedNRPPaTransportIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, DownlinkNonUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, ((DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_DownlinkNonUEAssociatedNRPPaTransport (OSCTXT* pctxt, DownlinkNonUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkNonUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNonUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DownlinkNonUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID */
   case T_NGAP_PDU_Contents_UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID");

      stat = asn1PE_RoutingID (pctxt, *pvalue->value.u._UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
   case T_NGAP_PDU_Contents_UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU:
      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

      stat = asn1PE_NRPPa_PDU (pctxt, *pvalue->value.u._UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UplinkNonUEAssociatedNRPPaTransportIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UplinkNonUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, UplinkNonUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNonUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, ((UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNonUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UplinkNonUEAssociatedNRPPaTransport (OSCTXT* pctxt, UplinkNonUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkNonUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNonUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UplinkNonUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UplinkNonUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_TraceStart_protocolIEs_element (OSCTXT* pctxt, TraceStart_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceStart_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _TraceStartIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_TraceStartIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_TraceStartIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._TraceStartIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _TraceStartIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_TraceStartIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_TraceStartIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._TraceStartIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _TraceStartIEs_id_TraceActivation */
   case T_NGAP_PDU_Contents_TraceStartIEs_id_TraceActivation:
      RTXCTXTPUSHELEMNAME (pctxt, "_TraceStartIEs_id_TraceActivation");

      stat = asn1PE_TraceActivation (pctxt, (TraceActivation*)pvalue->value.u._TraceStartIEs_id_TraceActivation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_TraceStartIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceStart_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_TraceStart_protocolIEs (OSCTXT* pctxt, TraceStart_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceStart_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_TraceStart_protocolIEs_element (pctxt, ((TraceStart_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceStart_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_TraceStart (OSCTXT* pctxt, TraceStart* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceStart");

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceStart: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_TraceStart_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceStart: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_TraceFailureIndication_protocolIEs_element (OSCTXT* pctxt, TraceFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceFailureIndication_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _TraceFailureIndicationIEs_id_NGRANTraceID */
   case T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_NGRANTraceID:
      RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_NGRANTraceID");

      stat = asn1PE_NGRANTraceID (pctxt, (NGRANTraceID*)pvalue->value.u._TraceFailureIndicationIEs_id_NGRANTraceID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _TraceFailureIndicationIEs_id_Cause */
   case T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._TraceFailureIndicationIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_TraceFailureIndicationIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceFailureIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_TraceFailureIndication_protocolIEs (OSCTXT* pctxt, TraceFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceFailureIndication_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_TraceFailureIndication_protocolIEs_element (pctxt, ((TraceFailureIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceFailureIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_TraceFailureIndication (OSCTXT* pctxt, TraceFailureIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceFailureIndication");

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_TraceFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_TraceFailureIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_DeactivateTrace_protocolIEs_element (OSCTXT* pctxt, DeactivateTrace_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_DeactivateTrace_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _DeactivateTraceIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_DeactivateTraceIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DeactivateTraceIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._DeactivateTraceIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DeactivateTraceIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_DeactivateTraceIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DeactivateTraceIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._DeactivateTraceIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _DeactivateTraceIEs_id_NGRANTraceID */
   case T_NGAP_PDU_Contents_DeactivateTraceIEs_id_NGRANTraceID:
      RTXCTXTPUSHELEMNAME (pctxt, "_DeactivateTraceIEs_id_NGRANTraceID");

      stat = asn1PE_NGRANTraceID (pctxt, (NGRANTraceID*)pvalue->value.u._DeactivateTraceIEs_id_NGRANTraceID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_DeactivateTraceIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_DeactivateTrace_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_DeactivateTrace_protocolIEs (OSCTXT* pctxt, DeactivateTrace_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_DeactivateTrace_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_DeactivateTrace_protocolIEs_element (pctxt, ((DeactivateTrace_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DeactivateTrace_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_DeactivateTrace (OSCTXT* pctxt, DeactivateTrace* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DeactivateTrace");

   RTDIAGSTRM2 (pctxt, "asn1PE_DeactivateTrace: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_DeactivateTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_DeactivateTrace: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_CellTrafficTrace_protocolIEs_element (OSCTXT* pctxt, CellTrafficTrace_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellTrafficTrace_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _CellTrafficTraceIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._CellTrafficTraceIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _CellTrafficTraceIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._CellTrafficTraceIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _CellTrafficTraceIEs_id_NGRANTraceID */
   case T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_NGRANTraceID:
      RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_NGRANTraceID");

      stat = asn1PE_NGRANTraceID (pctxt, (NGRANTraceID*)pvalue->value.u._CellTrafficTraceIEs_id_NGRANTraceID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _CellTrafficTraceIEs_id_NGRAN_CGI */
   case T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_NGRAN_CGI:
      RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_NGRAN_CGI");

      stat = asn1PE_NGRAN_CGI (pctxt, (NGRAN_CGI*)pvalue->value.u._CellTrafficTraceIEs_id_NGRAN_CGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress */
   case T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress:
      RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress");

      stat = asn1PE_TransportLayerAddress (pctxt, *pvalue->value.u._CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_CellTrafficTraceIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_CellTrafficTrace_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_CellTrafficTrace_protocolIEs (OSCTXT* pctxt, CellTrafficTrace_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_CellTrafficTrace_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_CellTrafficTrace_protocolIEs_element (pctxt, ((CellTrafficTrace_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CellTrafficTrace_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_CellTrafficTrace (OSCTXT* pctxt, CellTrafficTrace* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CellTrafficTrace");

   RTDIAGSTRM2 (pctxt, "asn1PE_CellTrafficTrace: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_CellTrafficTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_CellTrafficTrace: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_LocationReportingControl_protocolIEs_element (OSCTXT* pctxt, LocationReportingControl_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingControl_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _LocationReportingControlIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_LocationReportingControlIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingControlIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._LocationReportingControlIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _LocationReportingControlIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_LocationReportingControlIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingControlIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._LocationReportingControlIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _LocationReportingControlIEs_id_LocationReportingRequestType */
   case T_NGAP_PDU_Contents_LocationReportingControlIEs_id_LocationReportingRequestType:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingControlIEs_id_LocationReportingRequestType");

      stat = asn1PE_LocationReportingRequestType (pctxt, (LocationReportingRequestType*)pvalue->value.u._LocationReportingControlIEs_id_LocationReportingRequestType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_LocationReportingControlIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingControl_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_LocationReportingControl_protocolIEs (OSCTXT* pctxt, LocationReportingControl_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingControl_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_LocationReportingControl_protocolIEs_element (pctxt, ((LocationReportingControl_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingControl_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_LocationReportingControl (OSCTXT* pctxt, LocationReportingControl* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingControl");

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingControl: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_LocationReportingControl_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingControl: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_LocationReportingFailureIndication_protocolIEs_element (OSCTXT* pctxt, LocationReportingFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingFailureIndication_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _LocationReportingFailureIndicationIEs_id_Cause */
   case T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_id_Cause:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingFailureIndicationIEs_id_Cause");

      stat = asn1PE_Cause (pctxt, (Cause*)pvalue->value.u._LocationReportingFailureIndicationIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingFailureIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_LocationReportingFailureIndication_protocolIEs (OSCTXT* pctxt, LocationReportingFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingFailureIndication_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_LocationReportingFailureIndication_protocolIEs_element (pctxt, ((LocationReportingFailureIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingFailureIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_LocationReportingFailureIndication (OSCTXT* pctxt, LocationReportingFailureIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingFailureIndication");

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_LocationReportingFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReportingFailureIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_LocationReport_protocolIEs_element (OSCTXT* pctxt, LocationReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReport_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _LocationReportIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_LocationReportIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._LocationReportIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _LocationReportIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_LocationReportIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._LocationReportIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _LocationReportIEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_LocationReportIEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._LocationReportIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _LocationReportIEs_id_UEPresenceInAreaOfInterestList */
   case T_NGAP_PDU_Contents_LocationReportIEs_id_UEPresenceInAreaOfInterestList:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_UEPresenceInAreaOfInterestList");

      stat = asn1PE_UEPresenceInAreaOfInterestList (pctxt, pvalue->value.u._LocationReportIEs_id_UEPresenceInAreaOfInterestList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _LocationReportIEs_id_LocationReportingRequestType */
   case T_NGAP_PDU_Contents_LocationReportIEs_id_LocationReportingRequestType:
      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_LocationReportingRequestType");

      stat = asn1PE_LocationReportingRequestType (pctxt, (LocationReportingRequestType*)pvalue->value.u._LocationReportIEs_id_LocationReportingRequestType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_LocationReportIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_LocationReport_protocolIEs (OSCTXT* pctxt, LocationReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReport_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_LocationReport_protocolIEs_element (pctxt, ((LocationReport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_LocationReport (OSCTXT* pctxt, LocationReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReport");

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_LocationReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_LocationReport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UETNLABindingReleaseRequest_protocolIEs_element (OSCTXT* pctxt, UETNLABindingReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UETNLABindingReleaseRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UETNLABindingReleaseRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UETNLABindingReleaseRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UETNLABindingReleaseRequest_protocolIEs (OSCTXT* pctxt, UETNLABindingReleaseRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UETNLABindingReleaseRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UETNLABindingReleaseRequest_protocolIEs_element (pctxt, ((UETNLABindingReleaseRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UETNLABindingReleaseRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UETNLABindingReleaseRequest (OSCTXT* pctxt, UETNLABindingReleaseRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UETNLABindingReleaseRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_UETNLABindingReleaseRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UETNLABindingReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UETNLABindingReleaseRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UERadioCapabilityInfoIndication_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityInfoIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityInfoIndication_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UERadioCapabilityInfoIndicationIEs_id_UERadioCapability */
   case T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_UERadioCapability:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_UERadioCapability");

      stat = asn1PE_UERadioCapability (pctxt, *pvalue->value.u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging */
   case T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging");

      stat = asn1PE_UERadioCapabilityForPaging (pctxt, (UERadioCapabilityForPaging*)pvalue->value.u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityInfoIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UERadioCapabilityInfoIndication_protocolIEs (OSCTXT* pctxt, UERadioCapabilityInfoIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityInfoIndication_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UERadioCapabilityInfoIndication_protocolIEs_element (pctxt, ((UERadioCapabilityInfoIndication_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityInfoIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UERadioCapabilityInfoIndication (OSCTXT* pctxt, UERadioCapabilityInfoIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityInfoIndication");

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityInfoIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UERadioCapabilityInfoIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityInfoIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UERadioCapabilityCheckRequest_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityCheckRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckRequest_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UERadioCapabilityCheckRequestIEs_id_UERadioCapability */
   case T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_id_UERadioCapability:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckRequestIEs_id_UERadioCapability");

      stat = asn1PE_UERadioCapability (pctxt, *pvalue->value.u._UERadioCapabilityCheckRequestIEs_id_UERadioCapability);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UERadioCapabilityCheckRequest_protocolIEs (OSCTXT* pctxt, UERadioCapabilityCheckRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckRequest_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UERadioCapabilityCheckRequest_protocolIEs_element (pctxt, ((UERadioCapabilityCheckRequest_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UERadioCapabilityCheckRequest (OSCTXT* pctxt, UERadioCapabilityCheckRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityCheckRequest");

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UERadioCapabilityCheckRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_UERadioCapabilityCheckResponse_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityCheckResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckResponse_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator */
   case T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator");

      stat = asn1PE_IMSVoiceSupportIndicator (pctxt, pvalue->value.u._UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics */
   case T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics:
      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics");

      stat = asn1PE_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)pvalue->value.u._UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_UERadioCapabilityCheckResponse_protocolIEs (OSCTXT* pctxt, UERadioCapabilityCheckResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckResponse_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_UERadioCapabilityCheckResponse_protocolIEs_element (pctxt, ((UERadioCapabilityCheckResponse_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_UERadioCapabilityCheckResponse (OSCTXT* pctxt, UERadioCapabilityCheckResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityCheckResponse");

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_UERadioCapabilityCheckResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_UERadioCapabilityCheckResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_PrivateMessage_privateIEs_element (OSCTXT* pctxt, PrivateMessage_privateIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrivateMessage_privateIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_PrivateIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pe_OpenType (pctxt, pvalue->value.numocts, pvalue->value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_PrivateMessage_privateIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_PrivateMessage_privateIEs (OSCTXT* pctxt, PrivateMessage_privateIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_PrivateMessage_privateIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_PrivateMessage_privateIEs_element (pctxt, ((PrivateMessage_privateIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PrivateMessage_privateIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_PrivateMessage (OSCTXT* pctxt, PrivateMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateMessage");

   RTDIAGSTRM2 (pctxt, "asn1PE_PrivateMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode privateIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "privateIEs");

   stat = asn1PE_PrivateMessage_privateIEs (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_PrivateMessage: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_SecondaryRATDataUsageReport_protocolIEs_element (OSCTXT* pctxt, SecondaryRATDataUsageReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt, "asn1PE_SecondaryRATDataUsageReport_protocolIEs_element: start\n");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSCTXT lctxt;
   OSOCTET* pDynamicEncodeBuffer;
   ASN1OpenType openType;
   OSBOOL encoded = TRUE;
   OSRTDiagBitFieldList* pFieldList;
   OSINT16 savedBitOffset = pctxt->buffer.bitOffset;

   openType.numocts = 0;
   openType.data = 0;

   rtxCopyContext (&lctxt, pctxt);
   pctxt->pStream = 0;

   pFieldList = pctxt->pBitFldList;
   if (0 != pFieldList) {
      pu_initRtxDiagBitFieldList (pctxt, savedBitOffset);
   }
   stat = rtxInitContextBuffer (pctxt, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (pvalue->value.t) {
   /* _SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PE_AMF_UE_NGAP_ID (pctxt, pvalue->value.u._SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID */
   case T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID:
      RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PE_RAN_UE_NGAP_ID (pctxt, pvalue->value.u._SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList */
   case T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList:
      RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList");

      stat = asn1PE_PDUSessionResourceSecondaryRATUsageList (pctxt, pvalue->value.u._SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _SecondaryRATDataUsageReportIEs_id_HandoverFlag */
   case T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_HandoverFlag:
      RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_HandoverFlag");

      stat = asn1PE_HandoverFlag (pctxt, pvalue->value.u._SecondaryRATDataUsageReportIEs_id_HandoverFlag);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   /* _SecondaryRATDataUsageReportIEs_id_UserLocationInformation */
   case T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_UserLocationInformation:
      RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_UserLocationInformation");

      stat = asn1PE_UserLocationInformation (pctxt, (UserLocationInformation*)pvalue->value.u._SecondaryRATDataUsageReportIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
      break;

   case T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_UNDEF_:
      if (0 != pvalue->value.u.extElem1) {
         openType.numocts = pvalue->value.u.extElem1->numocts;
         openType.data = pvalue->value.u.extElem1->data;
      }
      encoded = FALSE;
      break;

   default:
      encoded = FALSE;
      stat = RTERR_INVOPT;
   }

   if (encoded) {
      openType.numocts = (OSUINT32) pe_GetMsgLen (pctxt);
      openType.data = pDynamicEncodeBuffer = pctxt->buffer.data;
   }

   rtxCopyContext (pctxt, &lctxt);

   if (0 == stat) {
      OSRTDiagBitFieldList* pOTFieldList = pctxt->pBitFldList;
      pctxt->pBitFldList = pFieldList;

      stat = pe_OpenType (pctxt, openType.numocts, openType.data);

      PU_SETOPENTYPEFLDLIST (pctxt->pBitFldList, pOTFieldList);
   }

   /* Free dynamic encode buffer */
   if (encoded) {
      rtxMemFreePtr (pctxt, pDynamicEncodeBuffer);
   }}

   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt, "asn1PE_SecondaryRATDataUsageReport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PE_SecondaryRATDataUsageReport_protocolIEs (OSCTXT* pctxt, SecondaryRATDataUsageReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTDIAGSTRM2 (pctxt, "asn1PE_SecondaryRATDataUsageReport_protocolIEs: start\n");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_SecondaryRATDataUsageReport_protocolIEs_element (pctxt, ((SecondaryRATDataUsageReport_protocolIEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SecondaryRATDataUsageReport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PE_SecondaryRATDataUsageReport (OSCTXT* pctxt, SecondaryRATDataUsageReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SecondaryRATDataUsageReport");

   RTDIAGSTRM2 (pctxt, "asn1PE_SecondaryRATDataUsageReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_SecondaryRATDataUsageReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode optional bits */

      PU_NEWFIELD (pctxt, "unknown opt bits");

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTDIAGSTRM2 (pctxt, "asn1PE_SecondaryRATDataUsageReport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

