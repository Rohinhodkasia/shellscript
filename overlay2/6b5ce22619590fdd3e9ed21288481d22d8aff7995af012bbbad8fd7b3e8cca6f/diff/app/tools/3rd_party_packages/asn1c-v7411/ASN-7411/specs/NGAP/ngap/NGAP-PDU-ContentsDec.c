/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.4.1.1, Date: 02-Jun-2020.
 */
#include ".h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PD__RerouteNASRequest_IEs_Value (OSCTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   _RerouteNASRequest_IEs_Value *pvalue = (_RerouteNASRequest_IEs_Value*) pvalue_;
   RTDIAGSTRM2 (pctxt,"asn1PD__RerouteNASRequest_IEs_Value: start\n");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTDIAGSTRM2 (pctxt,"asn1PD__RerouteNASRequest_IEs_Value: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupRequest_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceSetupRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestIEs_id_RANPagingPriority */
   case ASN1V_id_RANPagingPriority:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_RANPagingPriority;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_RANPagingPriority");

      stat = asn1PD_RANPagingPriority (pctxt, &pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_RANPagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestIEs_id_NAS_PDU */
   case ASN1V_id_NAS_PDU:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_NAS_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_NAS_PDU");

      pvalue->value.u._PDUSessionResourceSetupRequestIEs_id_NAS_PDU
          = rtxMemAllocType (pctxt, NAS_PDU);

      if (pvalue->value.u._PDUSessionResourceSetupRequestIEs_id_NAS_PDU
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NAS_PDU (pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_NAS_PDU);

      stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq */
   case ASN1V_id_PDUSessionResourceSetupListSUReq:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq");

      pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq
          = rtxMemAllocType (pctxt, PDUSessionResourceSetupListSUReq);

      if (pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupListSUReq (pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq
         );

      stat = asn1PD_PDUSessionResourceSetupListSUReq (pctxt, pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_PDUSessionResourceSetupListSUReq
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate */
   case ASN1V_id_UEAggregateMaximumBitRate:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate");

      pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate
          = rtxMemAllocType (pctxt, UEAggregateMaximumBitRate);

      if (pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEAggregateMaximumBitRate ((UEAggregateMaximumBitRate*)pvalue->
         value.
         u._PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate);

      stat = asn1PD_UEAggregateMaximumBitRate (pctxt, 
         (UEAggregateMaximumBitRate*)pvalue->value.
         u._PDUSessionResourceSetupRequestIEs_id_UEAggregateMaximumBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceSetupRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupRequest_protocolIEs (OSCTXT* pctxt, PDUSessionResourceSetupRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupRequest (OSCTXT* pctxt, PDUSessionResourceSetupRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceSetupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupResponse_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceSetupResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes */
   case ASN1V_id_PDUSessionResourceSetupListSURes:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes");

      pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes
          = rtxMemAllocType (pctxt, PDUSessionResourceSetupListSURes);

      if (pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupListSURes (pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes
         );

      stat = asn1PD_PDUSessionResourceSetupListSURes (pctxt, pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceSetupListSURes
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes */
   case ASN1V_id_PDUSessionResourceFailedToSetupListSURes:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes");

      pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes
          = rtxMemAllocType (pctxt, PDUSessionResourceFailedToSetupListSURes);

      if (pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupListSURes (pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes
         );

      stat = asn1PD_PDUSessionResourceFailedToSetupListSURes (pctxt, pvalue->
         value.
         u._PDUSessionResourceSetupResponseIEs_id_PDUSessionResourceFailedToSetupListSURes
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._PDUSessionResourceSetupResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceSetupResponseIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupResponse_protocolIEs (OSCTXT* pctxt, PDUSessionResourceSetupResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceSetupResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceSetupResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceSetupResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceSetupResponse (OSCTXT* pctxt, PDUSessionResourceSetupResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceSetupResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceSetupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceSetupResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseCommand_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceReleaseCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceReleaseCommandIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceReleaseCommandIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority */
   case ASN1V_id_RANPagingPriority:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority");

      stat = asn1PD_RANPagingPriority (pctxt, &pvalue->value.
         u._PDUSessionResourceReleaseCommandIEs_id_RANPagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceReleaseCommandIEs_id_NAS_PDU */
   case ASN1V_id_NAS_PDU:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_NAS_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_NAS_PDU");

      pvalue->value.u._PDUSessionResourceReleaseCommandIEs_id_NAS_PDU
          = rtxMemAllocType (pctxt, NAS_PDU);

      if (pvalue->value.u._PDUSessionResourceReleaseCommandIEs_id_NAS_PDU
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NAS_PDU (pvalue->value.
         u._PDUSessionResourceReleaseCommandIEs_id_NAS_PDU);

      stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
         u._PDUSessionResourceReleaseCommandIEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd */
   case ASN1V_id_PDUSessionResourceToReleaseListRelCmd:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd");

      pvalue->value.
         u._PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd
          = rtxMemAllocType (pctxt, PDUSessionResourceToReleaseListRelCmd);

      if (pvalue->value.
         u._PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceToReleaseListRelCmd (pvalue->value.
         u._PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd
         );

      stat = asn1PD_PDUSessionResourceToReleaseListRelCmd (pctxt, pvalue->value
         .
         u._PDUSessionResourceReleaseCommandIEs_id_PDUSessionResourceToReleaseListRelCmd
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseCommandIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseCommand_protocolIEs (OSCTXT* pctxt, PDUSessionResourceReleaseCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleaseCommand_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleaseCommand_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleaseCommand_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleaseCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseCommand (OSCTXT* pctxt, PDUSessionResourceReleaseCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleaseCommand");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceReleaseCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseCommand: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseResponse_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceReleaseResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes */
   case ASN1V_id_PDUSessionResourceReleasedListRelRes:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes");

      pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes
          = rtxMemAllocType (pctxt, PDUSessionResourceReleasedListRelRes);

      if (pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedListRelRes (pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes
         );

      stat = asn1PD_PDUSessionResourceReleasedListRelRes (pctxt, pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_PDUSessionResourceReleasedListRelRes
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation");

      pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._PDUSessionResourceReleaseResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceReleaseResponseIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseResponse_protocolIEs (OSCTXT* pctxt, PDUSessionResourceReleaseResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceReleaseResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceReleaseResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleaseResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceReleaseResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceReleaseResponse (OSCTXT* pctxt, PDUSessionResourceReleaseResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceReleaseResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceReleaseResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceReleaseResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyRequest_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceModifyRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceModifyRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyRequestIEs_id_RANPagingPriority */
   case ASN1V_id_RANPagingPriority:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_RANPagingPriority;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_RANPagingPriority");

      stat = asn1PD_RANPagingPriority (pctxt, &pvalue->value.
         u._PDUSessionResourceModifyRequestIEs_id_RANPagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq */
   case ASN1V_id_PDUSessionResourceModifyListModReq:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq");

      pvalue->value.
         u._PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq
          = rtxMemAllocType (pctxt, PDUSessionResourceModifyListModReq);

      if (pvalue->value.
         u._PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyListModReq (pvalue->value.
         u._PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq
         );

      stat = asn1PD_PDUSessionResourceModifyListModReq (pctxt, pvalue->value.
         u._PDUSessionResourceModifyRequestIEs_id_PDUSessionResourceModifyListModReq
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceModifyRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyRequest_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyRequest (OSCTXT* pctxt, PDUSessionResourceModifyRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceModifyRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyResponse_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes */
   case ASN1V_id_PDUSessionResourceModifyListModRes:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes");

      pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes
          = rtxMemAllocType (pctxt, PDUSessionResourceModifyListModRes);

      if (pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyListModRes (pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes
         );

      stat = asn1PD_PDUSessionResourceModifyListModRes (pctxt, pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceModifyListModRes
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes */
   case ASN1V_id_PDUSessionResourceFailedToModifyListModRes:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes");

      pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes
          = rtxMemAllocType (pctxt, 
         PDUSessionResourceFailedToModifyListModRes);

      if (pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToModifyListModRes (pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes
         );

      stat = asn1PD_PDUSessionResourceFailedToModifyListModRes (pctxt, pvalue->
         value.
         u._PDUSessionResourceModifyResponseIEs_id_PDUSessionResourceFailedToModifyListModRes
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyResponseIEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_UserLocationInformation");

      pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_UserLocationInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._PDUSessionResourceModifyResponseIEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._PDUSessionResourceModifyResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceModifyResponseIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyResponse_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyResponse (OSCTXT* pctxt, PDUSessionResourceModifyResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceModifyResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotify_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceNotify_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList */
   case ASN1V_id_PDUSessionResourceNotifyList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList");

      pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList
          = rtxMemAllocType (pctxt, PDUSessionResourceNotifyList);

      if (pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceNotifyList (pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList);

      stat = asn1PD_PDUSessionResourceNotifyList (pctxt, pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceNotifyList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot */
   case ASN1V_id_PDUSessionResourceReleasedListNot:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot");

      pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot
          = rtxMemAllocType (pctxt, PDUSessionResourceReleasedListNot);

      if (pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedListNot (pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot);

      stat = asn1PD_PDUSessionResourceReleasedListNot (pctxt, pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_PDUSessionResourceReleasedListNot);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceNotifyIEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceNotifyIEs_id_UserLocationInformation");

      pvalue->value.u._PDUSessionResourceNotifyIEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_UserLocationInformation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._PDUSessionResourceNotifyIEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.
         u._PDUSessionResourceNotifyIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceNotifyIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotify_protocolIEs (OSCTXT* pctxt, PDUSessionResourceNotify_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceNotify_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceNotify_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceNotify_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceNotify_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceNotify (OSCTXT* pctxt, PDUSessionResourceNotify* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceNotify");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceNotify_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceNotify: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndication_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceModifyIndicationIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceModifyIndicationIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd */
   case ASN1V_id_PDUSessionResourceModifyListModInd:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd");

      pvalue->value.
         u._PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd
          = rtxMemAllocType (pctxt, PDUSessionResourceModifyListModInd);

      if (pvalue->value.
         u._PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyListModInd (pvalue->value.
         u._PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd
         );

      stat = asn1PD_PDUSessionResourceModifyListModInd (pctxt, pvalue->value.
         u._PDUSessionResourceModifyIndicationIEs_id_PDUSessionResourceModifyListModInd
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceModifyIndicationIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndication_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyIndication (OSCTXT* pctxt, PDUSessionResourceModifyIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceModifyIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyConfirm_protocolIEs_element (OSCTXT* pctxt, PDUSessionResourceModifyConfirm_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm */
   case ASN1V_id_PDUSessionResourceModifyListModCfm:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm");

      pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm
          = rtxMemAllocType (pctxt, PDUSessionResourceModifyListModCfm);

      if (pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyListModCfm (pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm
         );

      stat = asn1PD_PDUSessionResourceModifyListModCfm (pctxt, pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceModifyListModCfm
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm */
   case ASN1V_id_PDUSessionResourceFailedToModifyListModCfm:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm");

      pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm
          = rtxMemAllocType (pctxt, 
         PDUSessionResourceFailedToModifyListModCfm);

      if (pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToModifyListModCfm (pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm
         );

      stat = asn1PD_PDUSessionResourceFailedToModifyListModCfm (pctxt, pvalue->
         value.
         u._PDUSessionResourceModifyConfirmIEs_id_PDUSessionResourceFailedToModifyListModCfm
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._PDUSessionResourceModifyConfirmIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PDUSessionResourceModifyConfirmIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyConfirm_protocolIEs (OSCTXT* pctxt, PDUSessionResourceModifyConfirm_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PDUSessionResourceModifyConfirm_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PDUSessionResourceModifyConfirm_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceModifyConfirm_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PDUSessionResourceModifyConfirm_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PDUSessionResourceModifyConfirm (OSCTXT* pctxt, PDUSessionResourceModifyConfirm* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUSessionResourceModifyConfirm");

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PDUSessionResourceModifyConfirm_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PDUSessionResourceModifyConfirm: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupRequest_protocolIEs_element (OSCTXT* pctxt, InitialContextSetupRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._InitialContextSetupRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._InitialContextSetupRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_OldAMF */
   case ASN1V_id_OldAMF:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_OldAMF;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_OldAMF");

      stat = asn1PD_AMFName (pctxt, &pvalue->value.
         u._InitialContextSetupRequestIEs_id_OldAMF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate */
   case ASN1V_id_UEAggregateMaximumBitRate:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate");

      pvalue->value.
         u._InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate
          = rtxMemAllocType (pctxt, UEAggregateMaximumBitRate);

      if (pvalue->value.
         u._InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEAggregateMaximumBitRate ((UEAggregateMaximumBitRate*)pvalue->
         value.u._InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate);

      stat = asn1PD_UEAggregateMaximumBitRate (pctxt, 
         (UEAggregateMaximumBitRate*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_UEAggregateMaximumBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive */
   case ASN1V_id_CoreNetworkAssistanceInformationForInactive:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive");

      pvalue->value.
         u._InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive
          = rtxMemAllocType (pctxt, 
         CoreNetworkAssistanceInformationForInactive);

      if (pvalue->value.
         u._InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CoreNetworkAssistanceInformationForInactive (
         (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive
         );

      stat = asn1PD_CoreNetworkAssistanceInformationForInactive (pctxt, 
         (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_CoreNetworkAssistanceInformationForInactive
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_GUAMI */
   case ASN1V_id_GUAMI:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_GUAMI;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_GUAMI");

      pvalue->value.u._InitialContextSetupRequestIEs_id_GUAMI
          = rtxMemAllocType (pctxt, GUAMI);

      if (pvalue->value.u._InitialContextSetupRequestIEs_id_GUAMI == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GUAMI ((GUAMI*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_GUAMI);

      stat = asn1PD_GUAMI (pctxt, (GUAMI*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_GUAMI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq */
   case ASN1V_id_PDUSessionResourceSetupListCxtReq:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq");

      pvalue->value.
         u._InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq
          = rtxMemAllocType (pctxt, PDUSessionResourceSetupListCxtReq);

      if (pvalue->value.
         u._InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupListCxtReq (pvalue->value.
         u._InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq
         );

      stat = asn1PD_PDUSessionResourceSetupListCxtReq (pctxt, pvalue->value.
         u._InitialContextSetupRequestIEs_id_PDUSessionResourceSetupListCxtReq
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_AllowedNSSAI */
   case ASN1V_id_AllowedNSSAI:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_AllowedNSSAI;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_AllowedNSSAI");

      pvalue->value.u._InitialContextSetupRequestIEs_id_AllowedNSSAI
          = rtxMemAllocType (pctxt, AllowedNSSAI);

      if (pvalue->value.u._InitialContextSetupRequestIEs_id_AllowedNSSAI
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AllowedNSSAI (pvalue->value.
         u._InitialContextSetupRequestIEs_id_AllowedNSSAI);

      stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
         u._InitialContextSetupRequestIEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_UESecurityCapabilities */
   case ASN1V_id_UESecurityCapabilities:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UESecurityCapabilities;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UESecurityCapabilities");

      pvalue->value.u._InitialContextSetupRequestIEs_id_UESecurityCapabilities
          = rtxMemAllocType (pctxt, UESecurityCapabilities);

      if (pvalue->value.
         u._InitialContextSetupRequestIEs_id_UESecurityCapabilities == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UESecurityCapabilities ((UESecurityCapabilities*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_UESecurityCapabilities);

      stat = asn1PD_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)
         pvalue->value.
         u._InitialContextSetupRequestIEs_id_UESecurityCapabilities);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_SecurityKey */
   case ASN1V_id_SecurityKey:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_SecurityKey;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_SecurityKey");

      pvalue->value.u._InitialContextSetupRequestIEs_id_SecurityKey
          = rtxMemAllocTypeZ (pctxt, SecurityKey);

      if (pvalue->value.u._InitialContextSetupRequestIEs_id_SecurityKey
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_SecurityKey (pctxt, (SecurityKey*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_SecurityKey);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_TraceActivation */
   case ASN1V_id_TraceActivation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_TraceActivation;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_TraceActivation");

      pvalue->value.u._InitialContextSetupRequestIEs_id_TraceActivation
          = rtxMemAllocType (pctxt, TraceActivation);

      if (pvalue->value.u._InitialContextSetupRequestIEs_id_TraceActivation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TraceActivation ((TraceActivation*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_TraceActivation);

      stat = asn1PD_TraceActivation (pctxt, (TraceActivation*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_TraceActivation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_MobilityRestrictionList */
   case ASN1V_id_MobilityRestrictionList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_MobilityRestrictionList;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_MobilityRestrictionList");

      pvalue->value.u._InitialContextSetupRequestIEs_id_MobilityRestrictionList
          = rtxMemAllocType (pctxt, MobilityRestrictionList);

      if (pvalue->value.
         u._InitialContextSetupRequestIEs_id_MobilityRestrictionList == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MobilityRestrictionList ((MobilityRestrictionList*)pvalue->value
         .u._InitialContextSetupRequestIEs_id_MobilityRestrictionList);

      stat = asn1PD_MobilityRestrictionList (pctxt, (MobilityRestrictionList*)
         pvalue->value.
         u._InitialContextSetupRequestIEs_id_MobilityRestrictionList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_UERadioCapability */
   case ASN1V_id_UERadioCapability:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UERadioCapability;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UERadioCapability");

      pvalue->value.u._InitialContextSetupRequestIEs_id_UERadioCapability
          = rtxMemAllocType (pctxt, UERadioCapability);

      if (pvalue->value.u._InitialContextSetupRequestIEs_id_UERadioCapability
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapability (pvalue->value.
         u._InitialContextSetupRequestIEs_id_UERadioCapability);

      stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
         u._InitialContextSetupRequestIEs_id_UERadioCapability);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_IndexToRFSP */
   case ASN1V_id_IndexToRFSP:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_IndexToRFSP;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_IndexToRFSP");

      stat = asn1PD_IndexToRFSP (pctxt, &pvalue->value.
         u._InitialContextSetupRequestIEs_id_IndexToRFSP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_MaskedIMEISV */
   case ASN1V_id_MaskedIMEISV:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_MaskedIMEISV;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_MaskedIMEISV");

      pvalue->value.u._InitialContextSetupRequestIEs_id_MaskedIMEISV
          = rtxMemAllocTypeZ (pctxt, MaskedIMEISV);

      if (pvalue->value.u._InitialContextSetupRequestIEs_id_MaskedIMEISV
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_MaskedIMEISV (pctxt, (MaskedIMEISV*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_MaskedIMEISV);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_NAS_PDU */
   case ASN1V_id_NAS_PDU:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_NAS_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_NAS_PDU");

      pvalue->value.u._InitialContextSetupRequestIEs_id_NAS_PDU
          = rtxMemAllocType (pctxt, NAS_PDU);

      if (pvalue->value.u._InitialContextSetupRequestIEs_id_NAS_PDU == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NAS_PDU (pvalue->value.
         u._InitialContextSetupRequestIEs_id_NAS_PDU);

      stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
         u._InitialContextSetupRequestIEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator */
   case ASN1V_id_EmergencyFallbackIndicator:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator");

      pvalue->value.
         u._InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator
          = rtxMemAllocType (pctxt, EmergencyFallbackIndicator);

      if (pvalue->value.
         u._InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyFallbackIndicator ((EmergencyFallbackIndicator*)pvalue
         ->value.u._InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator
         );

      stat = asn1PD_EmergencyFallbackIndicator (pctxt, 
         (EmergencyFallbackIndicator*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_EmergencyFallbackIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest */
   case ASN1V_id_RRCInactiveTransitionReportRequest:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest");

      stat = asn1PD_RRCInactiveTransitionReportRequest (pctxt, &pvalue->value.
         u._InitialContextSetupRequestIEs_id_RRCInactiveTransitionReportRequest
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging */
   case ASN1V_id_UERadioCapabilityForPaging:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging");

      pvalue->value.
         u._InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging
          = rtxMemAllocType (pctxt, UERadioCapabilityForPaging);

      if (pvalue->value.
         u._InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityForPaging ((UERadioCapabilityForPaging*)pvalue
         ->value.u._InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging
         );

      stat = asn1PD_UERadioCapabilityForPaging (pctxt, 
         (UERadioCapabilityForPaging*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_UERadioCapabilityForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_RedirectionVoiceFallback */
   case ASN1V_id_RedirectionVoiceFallback:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_RedirectionVoiceFallback;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_RedirectionVoiceFallback");

      stat = asn1PD_RedirectionVoiceFallback (pctxt, &pvalue->value.
         u._InitialContextSetupRequestIEs_id_RedirectionVoiceFallback);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_LocationReportingRequestType */
   case ASN1V_id_LocationReportingRequestType:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_LocationReportingRequestType;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_LocationReportingRequestType");

      pvalue->value.
         u._InitialContextSetupRequestIEs_id_LocationReportingRequestType
          = rtxMemAllocType (pctxt, LocationReportingRequestType);

      if (pvalue->value.
         u._InitialContextSetupRequestIEs_id_LocationReportingRequestType
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReportingRequestType ((LocationReportingRequestType*)
         pvalue->value.
         u._InitialContextSetupRequestIEs_id_LocationReportingRequestType);

      stat = asn1PD_LocationReportingRequestType (pctxt, 
         (LocationReportingRequestType*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_LocationReportingRequestType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupRequestIEs_id_CNAssistedRANTuning */
   case ASN1V_id_CNAssistedRANTuning:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_id_CNAssistedRANTuning;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupRequestIEs_id_CNAssistedRANTuning");

      pvalue->value.u._InitialContextSetupRequestIEs_id_CNAssistedRANTuning
          = rtxMemAllocType (pctxt, CNAssistedRANTuning);

      if (pvalue->value.u._InitialContextSetupRequestIEs_id_CNAssistedRANTuning
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CNAssistedRANTuning ((CNAssistedRANTuning*)pvalue->value.
         u._InitialContextSetupRequestIEs_id_CNAssistedRANTuning);

      stat = asn1PD_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue->
         value.u._InitialContextSetupRequestIEs_id_CNAssistedRANTuning);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_InitialContextSetupRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupRequest_protocolIEs (OSCTXT* pctxt, InitialContextSetupRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InitialContextSetupRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, InitialContextSetupRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InitialContextSetupRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_InitialContextSetupRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupRequest (OSCTXT* pctxt, InitialContextSetupRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialContextSetupRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_InitialContextSetupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupResponse_protocolIEs_element (OSCTXT* pctxt, InitialContextSetupResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._InitialContextSetupResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._InitialContextSetupResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes */
   case ASN1V_id_PDUSessionResourceSetupListCxtRes:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes");

      pvalue->value.
         u._InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes
          = rtxMemAllocType (pctxt, PDUSessionResourceSetupListCxtRes);

      if (pvalue->value.
         u._InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupListCxtRes (pvalue->value.
         u._InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes
         );

      stat = asn1PD_PDUSessionResourceSetupListCxtRes (pctxt, pvalue->value.
         u._InitialContextSetupResponseIEs_id_PDUSessionResourceSetupListCxtRes
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes */
   case ASN1V_id_PDUSessionResourceFailedToSetupListCxtRes:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes");

      pvalue->value.
         u._InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes
          = rtxMemAllocType (pctxt, 
         PDUSessionResourceFailedToSetupListCxtRes);

      if (pvalue->value.
         u._InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupListCxtRes (pvalue->value.
         u._InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes
         );

      stat = asn1PD_PDUSessionResourceFailedToSetupListCxtRes (pctxt, pvalue->
         value.
         u._InitialContextSetupResponseIEs_id_PDUSessionResourceFailedToSetupListCxtRes
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupResponseIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupResponseIEs_id_CriticalityDiagnostics");

      pvalue->value.u._InitialContextSetupResponseIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._InitialContextSetupResponseIEs_id_CriticalityDiagnostics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._InitialContextSetupResponseIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._InitialContextSetupResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_InitialContextSetupResponseIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupResponse_protocolIEs (OSCTXT* pctxt, InitialContextSetupResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InitialContextSetupResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, InitialContextSetupResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InitialContextSetupResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_InitialContextSetupResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupResponse (OSCTXT* pctxt, InitialContextSetupResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialContextSetupResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_InitialContextSetupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupFailure_protocolIEs_element (OSCTXT* pctxt, InitialContextSetupFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._InitialContextSetupFailureIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._InitialContextSetupFailureIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail */
   case ASN1V_id_PDUSessionResourceFailedToSetupListCxtFail:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail");

      pvalue->value.
         u._InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail
          = rtxMemAllocType (pctxt, 
         PDUSessionResourceFailedToSetupListCxtFail);

      if (pvalue->value.
         u._InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupListCxtFail (pvalue->value.
         u._InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail
         );

      stat = asn1PD_PDUSessionResourceFailedToSetupListCxtFail (pctxt, pvalue->
         value.
         u._InitialContextSetupFailureIEs_id_PDUSessionResourceFailedToSetupListCxtFail
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupFailureIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_Cause");

      pvalue->value.u._InitialContextSetupFailureIEs_id_Cause
          = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._InitialContextSetupFailureIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.
         u._InitialContextSetupFailureIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._InitialContextSetupFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialContextSetupFailureIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialContextSetupFailureIEs_id_CriticalityDiagnostics");

      pvalue->value.u._InitialContextSetupFailureIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._InitialContextSetupFailureIEs_id_CriticalityDiagnostics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._InitialContextSetupFailureIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._InitialContextSetupFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_InitialContextSetupFailureIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupFailure_protocolIEs (OSCTXT* pctxt, InitialContextSetupFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InitialContextSetupFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, InitialContextSetupFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InitialContextSetupFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_InitialContextSetupFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialContextSetupFailure (OSCTXT* pctxt, InitialContextSetupFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialContextSetupFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_InitialContextSetupFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialContextSetupFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseRequest_protocolIEs_element (OSCTXT* pctxt, UEContextReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextReleaseRequest_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextReleaseRequest_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq */
   case ASN1V_id_PDUSessionResourceListCxtRelReq:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq");

      pvalue->value.
         u._UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq
          = rtxMemAllocType (pctxt, PDUSessionResourceListCxtRelReq);

      if (pvalue->value.
         u._UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceListCxtRelReq (pvalue->value.
         u._UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq);

      stat = asn1PD_PDUSessionResourceListCxtRelReq (pctxt, pvalue->value.
         u._UEContextReleaseRequest_IEs_id_PDUSessionResourceListCxtRelReq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextReleaseRequest_IEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseRequest_IEs_id_Cause");

      pvalue->value.u._UEContextReleaseRequest_IEs_id_Cause
          = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._UEContextReleaseRequest_IEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.
         u._UEContextReleaseRequest_IEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._UEContextReleaseRequest_IEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UEContextReleaseRequest_IEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseRequest_protocolIEs (OSCTXT* pctxt, UEContextReleaseRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextReleaseRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextReleaseRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextReleaseRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextReleaseRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseRequest (OSCTXT* pctxt, UEContextReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextReleaseRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseCommand_protocolIEs_element (OSCTXT* pctxt, UEContextReleaseCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UEContextReleaseCommand_IEs_id_UE_NGAP_IDs */
   case ASN1V_id_UE_NGAP_IDs:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseCommand_IEs_id_UE_NGAP_IDs;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseCommand_IEs_id_UE_NGAP_IDs");

      pvalue->value.u._UEContextReleaseCommand_IEs_id_UE_NGAP_IDs
          = rtxMemAllocType (pctxt, UE_NGAP_IDs);

      if (pvalue->value.u._UEContextReleaseCommand_IEs_id_UE_NGAP_IDs == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UE_NGAP_IDs ((UE_NGAP_IDs*)pvalue->value.
         u._UEContextReleaseCommand_IEs_id_UE_NGAP_IDs);

      stat = asn1PD_UE_NGAP_IDs (pctxt, (UE_NGAP_IDs*)pvalue->value.
         u._UEContextReleaseCommand_IEs_id_UE_NGAP_IDs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextReleaseCommand_IEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseCommand_IEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseCommand_IEs_id_Cause");

      pvalue->value.u._UEContextReleaseCommand_IEs_id_Cause
          = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._UEContextReleaseCommand_IEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.
         u._UEContextReleaseCommand_IEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._UEContextReleaseCommand_IEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UEContextReleaseCommand_IEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseCommand_protocolIEs (OSCTXT* pctxt, UEContextReleaseCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextReleaseCommand_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextReleaseCommand_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextReleaseCommand_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextReleaseCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseCommand (OSCTXT* pctxt, UEContextReleaseCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextReleaseCommand");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextReleaseCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseCommand: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseComplete_protocolIEs_element (OSCTXT* pctxt, UEContextReleaseComplete_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextReleaseComplete_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextReleaseComplete_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextReleaseComplete_IEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_UserLocationInformation");

      pvalue->value.u._UEContextReleaseComplete_IEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.
         u._UEContextReleaseComplete_IEs_id_UserLocationInformation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._UEContextReleaseComplete_IEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.
         u._UEContextReleaseComplete_IEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging */
   case ASN1V_id_InfoOnRecommendedCellsAndRANNodesForPaging:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging");

      pvalue->value.
         u._UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
          = rtxMemAllocType (pctxt, 
         InfoOnRecommendedCellsAndRANNodesForPaging);

      if (pvalue->value.
         u._UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InfoOnRecommendedCellsAndRANNodesForPaging (
         (InfoOnRecommendedCellsAndRANNodesForPaging*)pvalue->value.
         u._UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
         );

      stat = asn1PD_InfoOnRecommendedCellsAndRANNodesForPaging (pctxt, 
         (InfoOnRecommendedCellsAndRANNodesForPaging*)pvalue->value.
         u._UEContextReleaseComplete_IEs_id_InfoOnRecommendedCellsAndRANNodesForPaging
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl */
   case ASN1V_id_PDUSessionResourceListCxtRelCpl:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl");

      pvalue->value.
         u._UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl
          = rtxMemAllocType (pctxt, PDUSessionResourceListCxtRelCpl);

      if (pvalue->value.
         u._UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceListCxtRelCpl (pvalue->value.
         u._UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl);

      stat = asn1PD_PDUSessionResourceListCxtRelCpl (pctxt, pvalue->value.
         u._UEContextReleaseComplete_IEs_id_PDUSessionResourceListCxtRelCpl);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextReleaseComplete_IEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextReleaseComplete_IEs_id_CriticalityDiagnostics");

      pvalue->value.u._UEContextReleaseComplete_IEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._UEContextReleaseComplete_IEs_id_CriticalityDiagnostics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._UEContextReleaseComplete_IEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._UEContextReleaseComplete_IEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UEContextReleaseComplete_IEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseComplete_protocolIEs (OSCTXT* pctxt, UEContextReleaseComplete_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextReleaseComplete_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextReleaseComplete_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextReleaseComplete_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextReleaseComplete_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextReleaseComplete (OSCTXT* pctxt, UEContextReleaseComplete* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextReleaseComplete");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextReleaseComplete_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextReleaseComplete: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextModificationRequest_protocolIEs_element (OSCTXT* pctxt, UEContextModificationRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextModificationRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextModificationRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_RANPagingPriority */
   case ASN1V_id_RANPagingPriority:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_RANPagingPriority;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_RANPagingPriority");

      stat = asn1PD_RANPagingPriority (pctxt, &pvalue->value.
         u._UEContextModificationRequestIEs_id_RANPagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_SecurityKey */
   case ASN1V_id_SecurityKey:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_SecurityKey;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_SecurityKey");

      pvalue->value.u._UEContextModificationRequestIEs_id_SecurityKey
          = rtxMemAllocTypeZ (pctxt, SecurityKey);

      if (pvalue->value.u._UEContextModificationRequestIEs_id_SecurityKey
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_SecurityKey (pctxt, (SecurityKey*)pvalue->value.
         u._UEContextModificationRequestIEs_id_SecurityKey);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_IndexToRFSP */
   case ASN1V_id_IndexToRFSP:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_IndexToRFSP;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_IndexToRFSP");

      stat = asn1PD_IndexToRFSP (pctxt, &pvalue->value.
         u._UEContextModificationRequestIEs_id_IndexToRFSP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate */
   case ASN1V_id_UEAggregateMaximumBitRate:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate");

      pvalue->value.
         u._UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate
          = rtxMemAllocType (pctxt, UEAggregateMaximumBitRate);

      if (pvalue->value.
         u._UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEAggregateMaximumBitRate ((UEAggregateMaximumBitRate*)pvalue->
         value.u._UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate
         );

      stat = asn1PD_UEAggregateMaximumBitRate (pctxt, 
         (UEAggregateMaximumBitRate*)pvalue->value.
         u._UEContextModificationRequestIEs_id_UEAggregateMaximumBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_UESecurityCapabilities */
   case ASN1V_id_UESecurityCapabilities:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_UESecurityCapabilities;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_UESecurityCapabilities");

      pvalue->value.
         u._UEContextModificationRequestIEs_id_UESecurityCapabilities
          = rtxMemAllocType (pctxt, UESecurityCapabilities);

      if (pvalue->value.
         u._UEContextModificationRequestIEs_id_UESecurityCapabilities == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UESecurityCapabilities ((UESecurityCapabilities*)pvalue->value.
         u._UEContextModificationRequestIEs_id_UESecurityCapabilities);

      stat = asn1PD_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)
         pvalue->value.
         u._UEContextModificationRequestIEs_id_UESecurityCapabilities);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive */
   case ASN1V_id_CoreNetworkAssistanceInformationForInactive:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive");

      pvalue->value.
         u._UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive
          = rtxMemAllocType (pctxt, 
         CoreNetworkAssistanceInformationForInactive);

      if (pvalue->value.
         u._UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CoreNetworkAssistanceInformationForInactive (
         (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
         u._UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive
         );

      stat = asn1PD_CoreNetworkAssistanceInformationForInactive (pctxt, 
         (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
         u._UEContextModificationRequestIEs_id_CoreNetworkAssistanceInformationForInactive
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_EmergencyFallbackIndicator */
   case ASN1V_id_EmergencyFallbackIndicator:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_EmergencyFallbackIndicator;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_EmergencyFallbackIndicator");

      pvalue->value.
         u._UEContextModificationRequestIEs_id_EmergencyFallbackIndicator
          = rtxMemAllocType (pctxt, EmergencyFallbackIndicator);

      if (pvalue->value.
         u._UEContextModificationRequestIEs_id_EmergencyFallbackIndicator
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyFallbackIndicator ((EmergencyFallbackIndicator*)pvalue
         ->value.
         u._UEContextModificationRequestIEs_id_EmergencyFallbackIndicator);

      stat = asn1PD_EmergencyFallbackIndicator (pctxt, 
         (EmergencyFallbackIndicator*)pvalue->value.
         u._UEContextModificationRequestIEs_id_EmergencyFallbackIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID */
   case ASN1V_id_NewAMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextModificationRequestIEs_id_NewAMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest */
   case ASN1V_id_RRCInactiveTransitionReportRequest:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest");

      stat = asn1PD_RRCInactiveTransitionReportRequest (pctxt, &pvalue->value.
         u._UEContextModificationRequestIEs_id_RRCInactiveTransitionReportRequest
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_NewGUAMI */
   case ASN1V_id_NewGUAMI:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_NewGUAMI;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_NewGUAMI");

      pvalue->value.u._UEContextModificationRequestIEs_id_NewGUAMI
          = rtxMemAllocType (pctxt, GUAMI);

      if (pvalue->value.u._UEContextModificationRequestIEs_id_NewGUAMI
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GUAMI ((GUAMI*)pvalue->value.
         u._UEContextModificationRequestIEs_id_NewGUAMI);

      stat = asn1PD_GUAMI (pctxt, (GUAMI*)pvalue->value.
         u._UEContextModificationRequestIEs_id_NewGUAMI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationRequestIEs_id_CNAssistedRANTuning */
   case ASN1V_id_CNAssistedRANTuning:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_id_CNAssistedRANTuning;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationRequestIEs_id_CNAssistedRANTuning");

      pvalue->value.u._UEContextModificationRequestIEs_id_CNAssistedRANTuning
          = rtxMemAllocType (pctxt, CNAssistedRANTuning);

      if (pvalue->value.
         u._UEContextModificationRequestIEs_id_CNAssistedRANTuning == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CNAssistedRANTuning ((CNAssistedRANTuning*)pvalue->value.
         u._UEContextModificationRequestIEs_id_CNAssistedRANTuning);

      stat = asn1PD_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue->
         value.u._UEContextModificationRequestIEs_id_CNAssistedRANTuning);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UEContextModificationRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationRequest_protocolIEs (OSCTXT* pctxt, UEContextModificationRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextModificationRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextModificationRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextModificationRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextModificationRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationRequest (OSCTXT* pctxt, UEContextModificationRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextModificationRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextModificationRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextModificationResponse_protocolIEs_element (OSCTXT* pctxt, UEContextModificationResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextModificationResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextModificationResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationResponseIEs_id_RRCState */
   case ASN1V_id_RRCState:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_RRCState;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_RRCState");

      stat = asn1PD_RRCState (pctxt, &pvalue->value.
         u._UEContextModificationResponseIEs_id_RRCState);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationResponseIEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_UserLocationInformation");

      pvalue->value.
         u._UEContextModificationResponseIEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.
         u._UEContextModificationResponseIEs_id_UserLocationInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._UEContextModificationResponseIEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.
         u._UEContextModificationResponseIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationResponseIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationResponseIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._UEContextModificationResponseIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._UEContextModificationResponseIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._UEContextModificationResponseIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._UEContextModificationResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UEContextModificationResponseIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationResponse_protocolIEs (OSCTXT* pctxt, UEContextModificationResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextModificationResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextModificationResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextModificationResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextModificationResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationResponse (OSCTXT* pctxt, UEContextModificationResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextModificationResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextModificationResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UEContextModificationFailure_protocolIEs_element (OSCTXT* pctxt, UEContextModificationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextModificationFailureIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UEContextModificationFailureIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationFailureIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_Cause");

      pvalue->value.u._UEContextModificationFailureIEs_id_Cause
          = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._UEContextModificationFailureIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.
         u._UEContextModificationFailureIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._UEContextModificationFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UEContextModificationFailureIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UEContextModificationFailureIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_UEContextModificationFailureIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._UEContextModificationFailureIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._UEContextModificationFailureIEs_id_CriticalityDiagnostics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._UEContextModificationFailureIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._UEContextModificationFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UEContextModificationFailureIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationFailure_protocolIEs (OSCTXT* pctxt, UEContextModificationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UEContextModificationFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UEContextModificationFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEContextModificationFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UEContextModificationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UEContextModificationFailure (OSCTXT* pctxt, UEContextModificationFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UEContextModificationFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UEContextModificationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UEContextModificationFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RRCInactiveTransitionReport_protocolIEs_element (OSCTXT* pctxt, RRCInactiveTransitionReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._RRCInactiveTransitionReportIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._RRCInactiveTransitionReportIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RRCInactiveTransitionReportIEs_id_RRCState */
   case ASN1V_id_RRCState:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_RRCState;

      RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_RRCState");

      stat = asn1PD_RRCState (pctxt, &pvalue->value.
         u._RRCInactiveTransitionReportIEs_id_RRCState);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RRCInactiveTransitionReportIEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_RRCInactiveTransitionReportIEs_id_UserLocationInformation");

      pvalue->value.
         u._RRCInactiveTransitionReportIEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.
         u._RRCInactiveTransitionReportIEs_id_UserLocationInformation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._RRCInactiveTransitionReportIEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.
         u._RRCInactiveTransitionReportIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_RRCInactiveTransitionReportIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RRCInactiveTransitionReport_protocolIEs (OSCTXT* pctxt, RRCInactiveTransitionReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RRCInactiveTransitionReport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RRCInactiveTransitionReport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RRCInactiveTransitionReport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RRCInactiveTransitionReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RRCInactiveTransitionReport (OSCTXT* pctxt, RRCInactiveTransitionReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RRCInactiveTransitionReport");

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RRCInactiveTransitionReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RRCInactiveTransitionReport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverRequired_protocolIEs_element (OSCTXT* pctxt, HandoverRequired_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverRequiredIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverRequiredIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequiredIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverRequiredIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequiredIEs_id_HandoverType */
   case ASN1V_id_HandoverType:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_HandoverType;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_HandoverType");

      stat = asn1PD_HandoverType (pctxt, &pvalue->value.
         u._HandoverRequiredIEs_id_HandoverType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequiredIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_Cause");

      pvalue->value.u._HandoverRequiredIEs_id_Cause = rtxMemAllocType (pctxt, 
         Cause);

      if (pvalue->value.u._HandoverRequiredIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.u._HandoverRequiredIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._HandoverRequiredIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequiredIEs_id_TargetID */
   case ASN1V_id_TargetID:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_TargetID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_TargetID");

      pvalue->value.u._HandoverRequiredIEs_id_TargetID
          = rtxMemAllocType (pctxt, TargetID);

      if (pvalue->value.u._HandoverRequiredIEs_id_TargetID == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TargetID ((TargetID*)pvalue->value.
         u._HandoverRequiredIEs_id_TargetID);

      stat = asn1PD_TargetID (pctxt, (TargetID*)pvalue->value.
         u._HandoverRequiredIEs_id_TargetID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequiredIEs_id_DirectForwardingPathAvailability */
   case ASN1V_id_DirectForwardingPathAvailability:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_DirectForwardingPathAvailability;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_DirectForwardingPathAvailability");

      stat = asn1PD_DirectForwardingPathAvailability (pctxt, &pvalue->value.
         u._HandoverRequiredIEs_id_DirectForwardingPathAvailability);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequiredIEs_id_PDUSessionResourceListHORqd */
   case ASN1V_id_PDUSessionResourceListHORqd:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_PDUSessionResourceListHORqd;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_PDUSessionResourceListHORqd");

      pvalue->value.u._HandoverRequiredIEs_id_PDUSessionResourceListHORqd
          = rtxMemAllocType (pctxt, PDUSessionResourceListHORqd);

      if (pvalue->value.u._HandoverRequiredIEs_id_PDUSessionResourceListHORqd
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceListHORqd (pvalue->value.
         u._HandoverRequiredIEs_id_PDUSessionResourceListHORqd);

      stat = asn1PD_PDUSessionResourceListHORqd (pctxt, pvalue->value.
         u._HandoverRequiredIEs_id_PDUSessionResourceListHORqd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequiredIEs_id_SourceToTarget_TransparentContainer */
   case ASN1V_id_SourceToTarget_TransparentContainer:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequiredIEs_id_SourceToTarget_TransparentContainer;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequiredIEs_id_SourceToTarget_TransparentContainer");

      pvalue->value.
         u._HandoverRequiredIEs_id_SourceToTarget_TransparentContainer
          = rtxMemAllocType (pctxt, SourceToTarget_TransparentContainer);

      if (pvalue->value.
         u._HandoverRequiredIEs_id_SourceToTarget_TransparentContainer
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SourceToTarget_TransparentContainer (pvalue->value.
         u._HandoverRequiredIEs_id_SourceToTarget_TransparentContainer);

      stat = asn1PD_SourceToTarget_TransparentContainer (pctxt, pvalue->value.
         u._HandoverRequiredIEs_id_SourceToTarget_TransparentContainer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequiredIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequired_protocolIEs (OSCTXT* pctxt, HandoverRequired_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverRequired_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverRequired_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverRequired_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverRequired_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequired (OSCTXT* pctxt, HandoverRequired* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequired");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverRequired_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequired: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCommand_protocolIEs_element (OSCTXT* pctxt, HandoverCommand_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverCommandIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverCommandIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCommandIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverCommandIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCommandIEs_id_HandoverType */
   case ASN1V_id_HandoverType:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_HandoverType;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_HandoverType");

      stat = asn1PD_HandoverType (pctxt, &pvalue->value.
         u._HandoverCommandIEs_id_HandoverType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCommandIEs_id_NASSecurityParametersFromNGRAN */
   case ASN1V_id_NASSecurityParametersFromNGRAN:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_NASSecurityParametersFromNGRAN;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_NASSecurityParametersFromNGRAN");

      pvalue->value.u._HandoverCommandIEs_id_NASSecurityParametersFromNGRAN
          = rtxMemAllocType (pctxt, NASSecurityParametersFromNGRAN);

      if (pvalue->value.u._HandoverCommandIEs_id_NASSecurityParametersFromNGRAN
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NASSecurityParametersFromNGRAN (pvalue->value.
         u._HandoverCommandIEs_id_NASSecurityParametersFromNGRAN);

      stat = asn1PD_NASSecurityParametersFromNGRAN (pctxt, pvalue->value.
         u._HandoverCommandIEs_id_NASSecurityParametersFromNGRAN);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCommandIEs_id_PDUSessionResourceHandoverList */
   case ASN1V_id_PDUSessionResourceHandoverList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_PDUSessionResourceHandoverList;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_PDUSessionResourceHandoverList");

      pvalue->value.u._HandoverCommandIEs_id_PDUSessionResourceHandoverList
          = rtxMemAllocType (pctxt, PDUSessionResourceHandoverList);

      if (pvalue->value.u._HandoverCommandIEs_id_PDUSessionResourceHandoverList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceHandoverList (pvalue->value.
         u._HandoverCommandIEs_id_PDUSessionResourceHandoverList);

      stat = asn1PD_PDUSessionResourceHandoverList (pctxt, pvalue->value.
         u._HandoverCommandIEs_id_PDUSessionResourceHandoverList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd */
   case ASN1V_id_PDUSessionResourceToReleaseListHOCmd:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd");

      pvalue->value.
         u._HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd
          = rtxMemAllocType (pctxt, PDUSessionResourceToReleaseListHOCmd);

      if (pvalue->value.
         u._HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceToReleaseListHOCmd (pvalue->value.
         u._HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd);

      stat = asn1PD_PDUSessionResourceToReleaseListHOCmd (pctxt, pvalue->value.
         u._HandoverCommandIEs_id_PDUSessionResourceToReleaseListHOCmd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCommandIEs_id_TargetToSource_TransparentContainer */
   case ASN1V_id_TargetToSource_TransparentContainer:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_TargetToSource_TransparentContainer;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_TargetToSource_TransparentContainer");

      pvalue->value.
         u._HandoverCommandIEs_id_TargetToSource_TransparentContainer
          = rtxMemAllocType (pctxt, TargetToSource_TransparentContainer);

      if (pvalue->value.
         u._HandoverCommandIEs_id_TargetToSource_TransparentContainer == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TargetToSource_TransparentContainer (pvalue->value.
         u._HandoverCommandIEs_id_TargetToSource_TransparentContainer);

      stat = asn1PD_TargetToSource_TransparentContainer (pctxt, pvalue->value.
         u._HandoverCommandIEs_id_TargetToSource_TransparentContainer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCommandIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCommandIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCommandIEs_id_CriticalityDiagnostics");

      pvalue->value.u._HandoverCommandIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.u._HandoverCommandIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._HandoverCommandIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.u._HandoverCommandIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverCommandIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCommand_protocolIEs (OSCTXT* pctxt, HandoverCommand_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverCommand_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverCommand_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverCommand_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverCommand_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCommand (OSCTXT* pctxt, HandoverCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCommand");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverCommand_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCommand: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationFailure_protocolIEs_element (OSCTXT* pctxt, HandoverPreparationFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverPreparationFailureIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverPreparationFailureIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverPreparationFailureIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_Cause");

      pvalue->value.u._HandoverPreparationFailureIEs_id_Cause
          = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._HandoverPreparationFailureIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.
         u._HandoverPreparationFailureIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._HandoverPreparationFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverPreparationFailureIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverPreparationFailureIEs_id_CriticalityDiagnostics");

      pvalue->value.u._HandoverPreparationFailureIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._HandoverPreparationFailureIEs_id_CriticalityDiagnostics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._HandoverPreparationFailureIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._HandoverPreparationFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverPreparationFailureIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationFailure_protocolIEs (OSCTXT* pctxt, HandoverPreparationFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverPreparationFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverPreparationFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverPreparationFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverPreparationFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverPreparationFailure (OSCTXT* pctxt, HandoverPreparationFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverPreparationFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverPreparationFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverPreparationFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverRequest_protocolIEs_element (OSCTXT* pctxt, HandoverRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverRequestIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_HandoverType */
   case ASN1V_id_HandoverType:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_HandoverType;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_HandoverType");

      stat = asn1PD_HandoverType (pctxt, &pvalue->value.
         u._HandoverRequestIEs_id_HandoverType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_Cause");

      pvalue->value.u._HandoverRequestIEs_id_Cause = rtxMemAllocType (pctxt, 
         Cause);

      if (pvalue->value.u._HandoverRequestIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.u._HandoverRequestIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._HandoverRequestIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_UEAggregateMaximumBitRate */
   case ASN1V_id_UEAggregateMaximumBitRate:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_UEAggregateMaximumBitRate;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_UEAggregateMaximumBitRate");

      pvalue->value.u._HandoverRequestIEs_id_UEAggregateMaximumBitRate
          = rtxMemAllocType (pctxt, UEAggregateMaximumBitRate);

      if (pvalue->value.u._HandoverRequestIEs_id_UEAggregateMaximumBitRate
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEAggregateMaximumBitRate ((UEAggregateMaximumBitRate*)pvalue->
         value.u._HandoverRequestIEs_id_UEAggregateMaximumBitRate);

      stat = asn1PD_UEAggregateMaximumBitRate (pctxt, 
         (UEAggregateMaximumBitRate*)pvalue->value.
         u._HandoverRequestIEs_id_UEAggregateMaximumBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive */
   case ASN1V_id_CoreNetworkAssistanceInformationForInactive:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive");

      pvalue->value.
         u._HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive
          = rtxMemAllocType (pctxt, 
         CoreNetworkAssistanceInformationForInactive);

      if (pvalue->value.
         u._HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CoreNetworkAssistanceInformationForInactive (
         (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
         u._HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive
         );

      stat = asn1PD_CoreNetworkAssistanceInformationForInactive (pctxt, 
         (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
         u._HandoverRequestIEs_id_CoreNetworkAssistanceInformationForInactive
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_UESecurityCapabilities */
   case ASN1V_id_UESecurityCapabilities:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_UESecurityCapabilities;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_UESecurityCapabilities");

      pvalue->value.u._HandoverRequestIEs_id_UESecurityCapabilities
          = rtxMemAllocType (pctxt, UESecurityCapabilities);

      if (pvalue->value.u._HandoverRequestIEs_id_UESecurityCapabilities
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UESecurityCapabilities ((UESecurityCapabilities*)pvalue->value.
         u._HandoverRequestIEs_id_UESecurityCapabilities);

      stat = asn1PD_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)
         pvalue->value.u._HandoverRequestIEs_id_UESecurityCapabilities);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_SecurityContext */
   case ASN1V_id_SecurityContext:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_SecurityContext;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_SecurityContext");

      pvalue->value.u._HandoverRequestIEs_id_SecurityContext
          = rtxMemAllocType (pctxt, SecurityContext);

      if (pvalue->value.u._HandoverRequestIEs_id_SecurityContext == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecurityContext ((SecurityContext*)pvalue->value.
         u._HandoverRequestIEs_id_SecurityContext);

      stat = asn1PD_SecurityContext (pctxt, (SecurityContext*)pvalue->value.
         u._HandoverRequestIEs_id_SecurityContext);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_NewSecurityContextInd */
   case ASN1V_id_NewSecurityContextInd:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_NewSecurityContextInd;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_NewSecurityContextInd");

      stat = asn1PD_NewSecurityContextInd (pctxt, &pvalue->value.
         u._HandoverRequestIEs_id_NewSecurityContextInd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_NASC */
   case ASN1V_id_NASC:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_NASC;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_NASC");

      pvalue->value.u._HandoverRequestIEs_id_NASC = rtxMemAllocType (pctxt, 
         NAS_PDU);

      if (pvalue->value.u._HandoverRequestIEs_id_NASC == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NAS_PDU (pvalue->value.u._HandoverRequestIEs_id_NASC);

      stat = asn1PD_NAS_PDU (pctxt, pvalue->value.u._HandoverRequestIEs_id_NASC
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq */
   case ASN1V_id_PDUSessionResourceSetupListHOReq:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq");

      pvalue->value.u._HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq
          = rtxMemAllocType (pctxt, PDUSessionResourceSetupListHOReq);

      if (pvalue->value.
         u._HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSetupListHOReq (pvalue->value.
         u._HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq);

      stat = asn1PD_PDUSessionResourceSetupListHOReq (pctxt, pvalue->value.
         u._HandoverRequestIEs_id_PDUSessionResourceSetupListHOReq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_AllowedNSSAI */
   case ASN1V_id_AllowedNSSAI:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_AllowedNSSAI;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_AllowedNSSAI");

      pvalue->value.u._HandoverRequestIEs_id_AllowedNSSAI
          = rtxMemAllocType (pctxt, AllowedNSSAI);

      if (pvalue->value.u._HandoverRequestIEs_id_AllowedNSSAI == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AllowedNSSAI (pvalue->value.
         u._HandoverRequestIEs_id_AllowedNSSAI);

      stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
         u._HandoverRequestIEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_TraceActivation */
   case ASN1V_id_TraceActivation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_TraceActivation;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_TraceActivation");

      pvalue->value.u._HandoverRequestIEs_id_TraceActivation
          = rtxMemAllocType (pctxt, TraceActivation);

      if (pvalue->value.u._HandoverRequestIEs_id_TraceActivation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TraceActivation ((TraceActivation*)pvalue->value.
         u._HandoverRequestIEs_id_TraceActivation);

      stat = asn1PD_TraceActivation (pctxt, (TraceActivation*)pvalue->value.
         u._HandoverRequestIEs_id_TraceActivation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_MaskedIMEISV */
   case ASN1V_id_MaskedIMEISV:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_MaskedIMEISV;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_MaskedIMEISV");

      pvalue->value.u._HandoverRequestIEs_id_MaskedIMEISV
          = rtxMemAllocTypeZ (pctxt, MaskedIMEISV);

      if (pvalue->value.u._HandoverRequestIEs_id_MaskedIMEISV == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_MaskedIMEISV (pctxt, (MaskedIMEISV*)pvalue->value.
         u._HandoverRequestIEs_id_MaskedIMEISV);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_SourceToTarget_TransparentContainer */
   case ASN1V_id_SourceToTarget_TransparentContainer:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_SourceToTarget_TransparentContainer;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_SourceToTarget_TransparentContainer");

      pvalue->value.
         u._HandoverRequestIEs_id_SourceToTarget_TransparentContainer
          = rtxMemAllocType (pctxt, SourceToTarget_TransparentContainer);

      if (pvalue->value.
         u._HandoverRequestIEs_id_SourceToTarget_TransparentContainer == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SourceToTarget_TransparentContainer (pvalue->value.
         u._HandoverRequestIEs_id_SourceToTarget_TransparentContainer);

      stat = asn1PD_SourceToTarget_TransparentContainer (pctxt, pvalue->value.
         u._HandoverRequestIEs_id_SourceToTarget_TransparentContainer);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_MobilityRestrictionList */
   case ASN1V_id_MobilityRestrictionList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_MobilityRestrictionList;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_MobilityRestrictionList");

      pvalue->value.u._HandoverRequestIEs_id_MobilityRestrictionList
          = rtxMemAllocType (pctxt, MobilityRestrictionList);

      if (pvalue->value.u._HandoverRequestIEs_id_MobilityRestrictionList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MobilityRestrictionList ((MobilityRestrictionList*)pvalue->value
         .u._HandoverRequestIEs_id_MobilityRestrictionList);

      stat = asn1PD_MobilityRestrictionList (pctxt, (MobilityRestrictionList*)
         pvalue->value.u._HandoverRequestIEs_id_MobilityRestrictionList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_LocationReportingRequestType */
   case ASN1V_id_LocationReportingRequestType:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_LocationReportingRequestType;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_LocationReportingRequestType");

      pvalue->value.u._HandoverRequestIEs_id_LocationReportingRequestType
          = rtxMemAllocType (pctxt, LocationReportingRequestType);

      if (pvalue->value.u._HandoverRequestIEs_id_LocationReportingRequestType
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReportingRequestType ((LocationReportingRequestType*)
         pvalue->value.u._HandoverRequestIEs_id_LocationReportingRequestType);

      stat = asn1PD_LocationReportingRequestType (pctxt, 
         (LocationReportingRequestType*)pvalue->value.
         u._HandoverRequestIEs_id_LocationReportingRequestType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_RRCInactiveTransitionReportRequest */
   case ASN1V_id_RRCInactiveTransitionReportRequest:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_RRCInactiveTransitionReportRequest;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_RRCInactiveTransitionReportRequest");

      stat = asn1PD_RRCInactiveTransitionReportRequest (pctxt, &pvalue->value.
         u._HandoverRequestIEs_id_RRCInactiveTransitionReportRequest);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_GUAMI */
   case ASN1V_id_GUAMI:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_GUAMI;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_GUAMI");

      pvalue->value.u._HandoverRequestIEs_id_GUAMI = rtxMemAllocType (pctxt, 
         GUAMI);

      if (pvalue->value.u._HandoverRequestIEs_id_GUAMI == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GUAMI ((GUAMI*)pvalue->value.u._HandoverRequestIEs_id_GUAMI);

      stat = asn1PD_GUAMI (pctxt, (GUAMI*)pvalue->value.
         u._HandoverRequestIEs_id_GUAMI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_RedirectionVoiceFallback */
   case ASN1V_id_RedirectionVoiceFallback:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_RedirectionVoiceFallback;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_RedirectionVoiceFallback");

      stat = asn1PD_RedirectionVoiceFallback (pctxt, &pvalue->value.
         u._HandoverRequestIEs_id_RedirectionVoiceFallback);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestIEs_id_CNAssistedRANTuning */
   case ASN1V_id_CNAssistedRANTuning:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestIEs_id_CNAssistedRANTuning;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestIEs_id_CNAssistedRANTuning");

      pvalue->value.u._HandoverRequestIEs_id_CNAssistedRANTuning
          = rtxMemAllocType (pctxt, CNAssistedRANTuning);

      if (pvalue->value.u._HandoverRequestIEs_id_CNAssistedRANTuning == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CNAssistedRANTuning ((CNAssistedRANTuning*)pvalue->value.
         u._HandoverRequestIEs_id_CNAssistedRANTuning);

      stat = asn1PD_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue->
         value.u._HandoverRequestIEs_id_CNAssistedRANTuning);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequest_protocolIEs (OSCTXT* pctxt, HandoverRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequest (OSCTXT* pctxt, HandoverRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverRequestAcknowledge_protocolIEs_element (OSCTXT* pctxt, HandoverRequestAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList */
   case ASN1V_id_PDUSessionResourceAdmittedList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList");

      pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList
          = rtxMemAllocType (pctxt, PDUSessionResourceAdmittedList);

      if (pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceAdmittedList (pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList);

      stat = asn1PD_PDUSessionResourceAdmittedList (pctxt, pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceAdmittedList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck */
   case ASN1V_id_PDUSessionResourceFailedToSetupListHOAck:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck");

      pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck
          = rtxMemAllocType (pctxt, PDUSessionResourceFailedToSetupListHOAck);

      if (pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupListHOAck (pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck
         );

      stat = asn1PD_PDUSessionResourceFailedToSetupListHOAck (pctxt, pvalue->
         value.
         u._HandoverRequestAcknowledgeIEs_id_PDUSessionResourceFailedToSetupListHOAck
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer */
   case ASN1V_id_TargetToSource_TransparentContainer:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer");

      pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer
          = rtxMemAllocType (pctxt, TargetToSource_TransparentContainer);

      if (pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TargetToSource_TransparentContainer (pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer
         );

      stat = asn1PD_TargetToSource_TransparentContainer (pctxt, pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_TargetToSource_TransparentContainer
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics");

      pvalue->value.u._HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._HandoverRequestAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverRequestAcknowledgeIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequestAcknowledge_protocolIEs (OSCTXT* pctxt, HandoverRequestAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverRequestAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverRequestAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverRequestAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverRequestAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverRequestAcknowledge (OSCTXT* pctxt, HandoverRequestAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverRequestAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverRequestAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverRequestAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverFailure_protocolIEs_element (OSCTXT* pctxt, HandoverFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverFailureIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverFailureIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverFailureIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverFailureIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverFailureIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverFailureIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverFailureIEs_id_Cause");

      pvalue->value.u._HandoverFailureIEs_id_Cause = rtxMemAllocType (pctxt, 
         Cause);

      if (pvalue->value.u._HandoverFailureIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.u._HandoverFailureIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._HandoverFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverFailureIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverFailureIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverFailureIEs_id_CriticalityDiagnostics");

      pvalue->value.u._HandoverFailureIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.u._HandoverFailureIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._HandoverFailureIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.u._HandoverFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverFailureIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverFailure_protocolIEs (OSCTXT* pctxt, HandoverFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverFailure (OSCTXT* pctxt, HandoverFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverNotify_protocolIEs_element (OSCTXT* pctxt, HandoverNotify_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverNotifyIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverNotifyIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverNotifyIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverNotifyIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverNotifyIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverNotifyIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverNotifyIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverNotifyIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverNotifyIEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverNotifyIEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverNotifyIEs_id_UserLocationInformation");

      pvalue->value.u._HandoverNotifyIEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.u._HandoverNotifyIEs_id_UserLocationInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._HandoverNotifyIEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.u._HandoverNotifyIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverNotifyIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverNotify_protocolIEs (OSCTXT* pctxt, HandoverNotify_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverNotify_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverNotify_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverNotify_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverNotify_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverNotify (OSCTXT* pctxt, HandoverNotify* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverNotify");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverNotify_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverNotify: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequest_protocolIEs_element (OSCTXT* pctxt, PathSwitchRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PathSwitchRequestIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PathSwitchRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID */
   case ASN1V_id_SourceAMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PathSwitchRequestIEs_id_SourceAMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestIEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_UserLocationInformation");

      pvalue->value.u._PathSwitchRequestIEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.u._PathSwitchRequestIEs_id_UserLocationInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._PathSwitchRequestIEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.u._PathSwitchRequestIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestIEs_id_UESecurityCapabilities */
   case ASN1V_id_UESecurityCapabilities:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_UESecurityCapabilities;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_UESecurityCapabilities");

      pvalue->value.u._PathSwitchRequestIEs_id_UESecurityCapabilities
          = rtxMemAllocType (pctxt, UESecurityCapabilities);

      if (pvalue->value.u._PathSwitchRequestIEs_id_UESecurityCapabilities
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UESecurityCapabilities ((UESecurityCapabilities*)pvalue->value.
         u._PathSwitchRequestIEs_id_UESecurityCapabilities);

      stat = asn1PD_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)
         pvalue->value.u._PathSwitchRequestIEs_id_UESecurityCapabilities);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList */
   case ASN1V_id_PDUSessionResourceToBeSwitchedDLList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList");

      pvalue->value.
         u._PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList
          = rtxMemAllocType (pctxt, PDUSessionResourceToBeSwitchedDLList);

      if (pvalue->value.
         u._PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceToBeSwitchedDLList (pvalue->value.
         u._PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList);

      stat = asn1PD_PDUSessionResourceToBeSwitchedDLList (pctxt, pvalue->value.
         u._PathSwitchRequestIEs_id_PDUSessionResourceToBeSwitchedDLList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq */
   case ASN1V_id_PDUSessionResourceFailedToSetupListPSReq:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq");

      pvalue->value.
         u._PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq
          = rtxMemAllocType (pctxt, PDUSessionResourceFailedToSetupListPSReq);

      if (pvalue->value.
         u._PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceFailedToSetupListPSReq (pvalue->value.
         u._PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq);

      stat = asn1PD_PDUSessionResourceFailedToSetupListPSReq (pctxt, pvalue->
         value.
         u._PathSwitchRequestIEs_id_PDUSessionResourceFailedToSetupListPSReq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PathSwitchRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequest_protocolIEs (OSCTXT* pctxt, PathSwitchRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathSwitchRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PathSwitchRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PathSwitchRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathSwitchRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequest (OSCTXT* pctxt, PathSwitchRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PathSwitchRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestAcknowledge_protocolIEs_element (OSCTXT* pctxt, PathSwitchRequestAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities */
   case ASN1V_id_UESecurityCapabilities:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities");

      pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities
          = rtxMemAllocType (pctxt, UESecurityCapabilities);

      if (pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UESecurityCapabilities ((UESecurityCapabilities*)pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities);

      stat = asn1PD_UESecurityCapabilities (pctxt, (UESecurityCapabilities*)
         pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_UESecurityCapabilities);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_SecurityContext */
   case ASN1V_id_SecurityContext:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_SecurityContext;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_SecurityContext");

      pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_SecurityContext
          = rtxMemAllocType (pctxt, SecurityContext);

      if (pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_SecurityContext
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecurityContext ((SecurityContext*)pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_SecurityContext);

      stat = asn1PD_SecurityContext (pctxt, (SecurityContext*)pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_SecurityContext);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd */
   case ASN1V_id_NewSecurityContextInd:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd");

      stat = asn1PD_NewSecurityContextInd (pctxt, &pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_NewSecurityContextInd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList */
   case ASN1V_id_PDUSessionResourceSwitchedList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList");

      pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList
          = rtxMemAllocType (pctxt, PDUSessionResourceSwitchedList);

      if (pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSwitchedList (pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList
         );

      stat = asn1PD_PDUSessionResourceSwitchedList (pctxt, pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceSwitchedList
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck */
   case ASN1V_id_PDUSessionResourceReleasedListPSAck:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck");

      pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck
          = rtxMemAllocType (pctxt, PDUSessionResourceReleasedListPSAck);

      if (pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedListPSAck (pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck
         );

      stat = asn1PD_PDUSessionResourceReleasedListPSAck (pctxt, pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_PDUSessionResourceReleasedListPSAck
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI */
   case ASN1V_id_AllowedNSSAI:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI");

      pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI
          = rtxMemAllocType (pctxt, AllowedNSSAI);

      if (pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AllowedNSSAI (pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI);

      stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive */
   case ASN1V_id_CoreNetworkAssistanceInformationForInactive:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive");

      pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive
          = rtxMemAllocType (pctxt, 
         CoreNetworkAssistanceInformationForInactive);

      if (pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CoreNetworkAssistanceInformationForInactive (
         (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive
         );

      stat = asn1PD_CoreNetworkAssistanceInformationForInactive (pctxt, 
         (CoreNetworkAssistanceInformationForInactive*)pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_CoreNetworkAssistanceInformationForInactive
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest */
   case ASN1V_id_RRCInactiveTransitionReportRequest:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest");

      stat = asn1PD_RRCInactiveTransitionReportRequest (pctxt, &pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_RRCInactiveTransitionReportRequest
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback */
   case ASN1V_id_RedirectionVoiceFallback:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback");

      stat = asn1PD_RedirectionVoiceFallback (pctxt, &pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_RedirectionVoiceFallback);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning */
   case ASN1V_id_CNAssistedRANTuning:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning");

      pvalue->value.u._PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning
          = rtxMemAllocType (pctxt, CNAssistedRANTuning);

      if (pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CNAssistedRANTuning ((CNAssistedRANTuning*)pvalue->value.
         u._PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning);

      stat = asn1PD_CNAssistedRANTuning (pctxt, (CNAssistedRANTuning*)pvalue->
         value.u._PathSwitchRequestAcknowledgeIEs_id_CNAssistedRANTuning);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PathSwitchRequestAcknowledgeIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestAcknowledge_protocolIEs (OSCTXT* pctxt, PathSwitchRequestAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathSwitchRequestAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PathSwitchRequestAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PathSwitchRequestAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathSwitchRequestAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestAcknowledge (OSCTXT* pctxt, PathSwitchRequestAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequestAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PathSwitchRequestAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestFailure_protocolIEs_element (OSCTXT* pctxt, PathSwitchRequestFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PathSwitchRequestFailureIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._PathSwitchRequestFailureIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail */
   case ASN1V_id_PDUSessionResourceReleasedListPSFail:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail");

      pvalue->value.
         u._PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail
          = rtxMemAllocType (pctxt, PDUSessionResourceReleasedListPSFail);

      if (pvalue->value.
         u._PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceReleasedListPSFail (pvalue->value.
         u._PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail
         );

      stat = asn1PD_PDUSessionResourceReleasedListPSFail (pctxt, pvalue->value.
         u._PathSwitchRequestFailureIEs_id_PDUSessionResourceReleasedListPSFail
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PathSwitchRequestFailureIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_PathSwitchRequestFailureIEs_id_CriticalityDiagnostics");

      pvalue->value.u._PathSwitchRequestFailureIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._PathSwitchRequestFailureIEs_id_CriticalityDiagnostics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._PathSwitchRequestFailureIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.u._PathSwitchRequestFailureIEs_id_CriticalityDiagnostics
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PathSwitchRequestFailureIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestFailure_protocolIEs (OSCTXT* pctxt, PathSwitchRequestFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PathSwitchRequestFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PathSwitchRequestFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PathSwitchRequestFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PathSwitchRequestFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PathSwitchRequestFailure (OSCTXT* pctxt, PathSwitchRequestFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PathSwitchRequestFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PathSwitchRequestFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PathSwitchRequestFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCancel_protocolIEs_element (OSCTXT* pctxt, HandoverCancel_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverCancelIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCancelIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverCancelIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCancelIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCancelIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverCancelIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCancelIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverCancelIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelIEs_id_Cause");

      pvalue->value.u._HandoverCancelIEs_id_Cause = rtxMemAllocType (pctxt, 
         Cause);

      if (pvalue->value.u._HandoverCancelIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.u._HandoverCancelIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._HandoverCancelIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverCancelIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCancel_protocolIEs (OSCTXT* pctxt, HandoverCancel_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverCancel_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverCancel_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverCancel_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverCancel_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCancel (OSCTXT* pctxt, HandoverCancel* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCancel");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverCancel_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancel: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_HandoverCancelAcknowledge_protocolIEs_element (OSCTXT* pctxt, HandoverCancelAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverCancelAcknowledgeIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._HandoverCancelAcknowledgeIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics");

      pvalue->value.u._HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._HandoverCancelAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_HandoverCancelAcknowledgeIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCancelAcknowledge_protocolIEs (OSCTXT* pctxt, HandoverCancelAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      HandoverCancelAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, HandoverCancelAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HandoverCancelAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_HandoverCancelAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_HandoverCancelAcknowledge (OSCTXT* pctxt, HandoverCancelAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HandoverCancelAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_HandoverCancelAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_HandoverCancelAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkRANStatusTransfer_protocolIEs_element (OSCTXT* pctxt, UplinkRANStatusTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UplinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UplinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer */
   case ASN1V_id_RANStatusTransfer_TransparentContainer:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer");

      pvalue->value.
         u._UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
          = rtxMemAllocType (pctxt, RANStatusTransfer_TransparentContainer);

      if (pvalue->value.
         u._UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RANStatusTransfer_TransparentContainer (
         (RANStatusTransfer_TransparentContainer*)pvalue->value.
         u._UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
         );

      stat = asn1PD_RANStatusTransfer_TransparentContainer (pctxt, 
         (RANStatusTransfer_TransparentContainer*)pvalue->value.
         u._UplinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UplinkRANStatusTransferIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRANStatusTransfer_protocolIEs (OSCTXT* pctxt, UplinkRANStatusTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkRANStatusTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkRANStatusTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkRANStatusTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkRANStatusTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRANStatusTransfer (OSCTXT* pctxt, UplinkRANStatusTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkRANStatusTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkRANStatusTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANStatusTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkRANStatusTransfer_protocolIEs_element (OSCTXT* pctxt, DownlinkRANStatusTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._DownlinkRANStatusTransferIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._DownlinkRANStatusTransferIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer */
   case ASN1V_id_RANStatusTransfer_TransparentContainer:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer");

      pvalue->value.
         u._DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
          = rtxMemAllocType (pctxt, RANStatusTransfer_TransparentContainer);

      if (pvalue->value.
         u._DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RANStatusTransfer_TransparentContainer (
         (RANStatusTransfer_TransparentContainer*)pvalue->value.
         u._DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
         );

      stat = asn1PD_RANStatusTransfer_TransparentContainer (pctxt, 
         (RANStatusTransfer_TransparentContainer*)pvalue->value.
         u._DownlinkRANStatusTransferIEs_id_RANStatusTransfer_TransparentContainer
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_DownlinkRANStatusTransferIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRANStatusTransfer_protocolIEs (OSCTXT* pctxt, DownlinkRANStatusTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkRANStatusTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkRANStatusTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkRANStatusTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkRANStatusTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRANStatusTransfer (OSCTXT* pctxt, DownlinkRANStatusTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkRANStatusTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkRANStatusTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANStatusTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_Paging_protocolIEs_element (OSCTXT* pctxt, Paging_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PagingIEs_id_UEPagingIdentity */
   case ASN1V_id_UEPagingIdentity:
      pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_UEPagingIdentity;

      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_UEPagingIdentity");

      pvalue->value.u._PagingIEs_id_UEPagingIdentity = rtxMemAllocType (pctxt, 
         UEPagingIdentity);

      if (pvalue->value.u._PagingIEs_id_UEPagingIdentity == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEPagingIdentity ((UEPagingIdentity*)pvalue->value.
         u._PagingIEs_id_UEPagingIdentity);

      stat = asn1PD_UEPagingIdentity (pctxt, (UEPagingIdentity*)pvalue->value.
         u._PagingIEs_id_UEPagingIdentity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PagingIEs_id_PagingDRX */
   case ASN1V_id_PagingDRX:
      pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_PagingDRX;

      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_PagingDRX");

      stat = asn1PD_PagingDRX (pctxt, &pvalue->value.u._PagingIEs_id_PagingDRX
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PagingIEs_id_TAIListForPaging */
   case ASN1V_id_TAIListForPaging:
      pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_TAIListForPaging;

      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_TAIListForPaging");

      pvalue->value.u._PagingIEs_id_TAIListForPaging = rtxMemAllocType (pctxt, 
         TAIListForPaging);

      if (pvalue->value.u._PagingIEs_id_TAIListForPaging == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAIListForPaging (pvalue->value.u._PagingIEs_id_TAIListForPaging
         );

      stat = asn1PD_TAIListForPaging (pctxt, pvalue->value.
         u._PagingIEs_id_TAIListForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PagingIEs_id_PagingPriority */
   case ASN1V_id_PagingPriority:
      pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_PagingPriority;

      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_PagingPriority");

      stat = asn1PD_PagingPriority (pctxt, &pvalue->value.
         u._PagingIEs_id_PagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PagingIEs_id_UERadioCapabilityForPaging */
   case ASN1V_id_UERadioCapabilityForPaging:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PagingIEs_id_UERadioCapabilityForPaging;

      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_UERadioCapabilityForPaging");

      pvalue->value.u._PagingIEs_id_UERadioCapabilityForPaging
          = rtxMemAllocType (pctxt, UERadioCapabilityForPaging);

      if (pvalue->value.u._PagingIEs_id_UERadioCapabilityForPaging == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityForPaging ((UERadioCapabilityForPaging*)pvalue
         ->value.u._PagingIEs_id_UERadioCapabilityForPaging);

      stat = asn1PD_UERadioCapabilityForPaging (pctxt, 
         (UERadioCapabilityForPaging*)pvalue->value.
         u._PagingIEs_id_UERadioCapabilityForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PagingIEs_id_PagingOrigin */
   case ASN1V_id_PagingOrigin:
      pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_id_PagingOrigin;

      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_PagingOrigin");

      stat = asn1PD_PagingOrigin (pctxt, &pvalue->value.
         u._PagingIEs_id_PagingOrigin);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PagingIEs_id_AssistanceDataForPaging */
   case ASN1V_id_AssistanceDataForPaging:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PagingIEs_id_AssistanceDataForPaging;

      RTXCTXTPUSHELEMNAME (pctxt, "_PagingIEs_id_AssistanceDataForPaging");

      pvalue->value.u._PagingIEs_id_AssistanceDataForPaging
          = rtxMemAllocType (pctxt, AssistanceDataForPaging);

      if (pvalue->value.u._PagingIEs_id_AssistanceDataForPaging == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AssistanceDataForPaging ((AssistanceDataForPaging*)pvalue->value
         .u._PagingIEs_id_AssistanceDataForPaging);

      stat = asn1PD_AssistanceDataForPaging (pctxt, (AssistanceDataForPaging*)
         pvalue->value.u._PagingIEs_id_AssistanceDataForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PagingIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_Paging_protocolIEs (OSCTXT* pctxt, Paging_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      Paging_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, Paging_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Paging_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_Paging_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_Paging (OSCTXT* pctxt, Paging* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Paging");

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_Paging_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_Paging: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_InitialUEMessage_protocolIEs_element (OSCTXT* pctxt, InitialUEMessage_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _InitialUEMessage_IEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._InitialUEMessage_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialUEMessage_IEs_id_NAS_PDU */
   case ASN1V_id_NAS_PDU:
      pvalue->value.t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_NAS_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_NAS_PDU");

      pvalue->value.u._InitialUEMessage_IEs_id_NAS_PDU
          = rtxMemAllocType (pctxt, NAS_PDU);

      if (pvalue->value.u._InitialUEMessage_IEs_id_NAS_PDU == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NAS_PDU (pvalue->value.u._InitialUEMessage_IEs_id_NAS_PDU);

      stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
         u._InitialUEMessage_IEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialUEMessage_IEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_UserLocationInformation");

      pvalue->value.u._InitialUEMessage_IEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.u._InitialUEMessage_IEs_id_UserLocationInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._InitialUEMessage_IEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.u._InitialUEMessage_IEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialUEMessage_IEs_id_RRCEstablishmentCause */
   case ASN1V_id_RRCEstablishmentCause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_RRCEstablishmentCause;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_RRCEstablishmentCause");

      stat = asn1PD_RRCEstablishmentCause (pctxt, &pvalue->value.
         u._InitialUEMessage_IEs_id_RRCEstablishmentCause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialUEMessage_IEs_id_FiveG_S_TMSI */
   case ASN1V_id_FiveG_S_TMSI:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_FiveG_S_TMSI;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_FiveG_S_TMSI");

      pvalue->value.u._InitialUEMessage_IEs_id_FiveG_S_TMSI
          = rtxMemAllocType (pctxt, FiveG_S_TMSI);

      if (pvalue->value.u._InitialUEMessage_IEs_id_FiveG_S_TMSI == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FiveG_S_TMSI ((FiveG_S_TMSI*)pvalue->value.
         u._InitialUEMessage_IEs_id_FiveG_S_TMSI);

      stat = asn1PD_FiveG_S_TMSI (pctxt, (FiveG_S_TMSI*)pvalue->value.
         u._InitialUEMessage_IEs_id_FiveG_S_TMSI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialUEMessage_IEs_id_AMFSetID */
   case ASN1V_id_AMFSetID:
      pvalue->value.t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_AMFSetID;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_AMFSetID");

      pvalue->value.u._InitialUEMessage_IEs_id_AMFSetID
          = rtxMemAllocTypeZ (pctxt, AMFSetID);

      if (pvalue->value.u._InitialUEMessage_IEs_id_AMFSetID == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_AMFSetID (pctxt, pvalue->value.
         u._InitialUEMessage_IEs_id_AMFSetID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialUEMessage_IEs_id_UEContextRequest */
   case ASN1V_id_UEContextRequest:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_UEContextRequest;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_UEContextRequest");

      stat = asn1PD_UEContextRequest (pctxt, &pvalue->value.
         u._InitialUEMessage_IEs_id_UEContextRequest);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialUEMessage_IEs_id_AllowedNSSAI */
   case ASN1V_id_AllowedNSSAI:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_AllowedNSSAI;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_AllowedNSSAI");

      pvalue->value.u._InitialUEMessage_IEs_id_AllowedNSSAI
          = rtxMemAllocType (pctxt, AllowedNSSAI);

      if (pvalue->value.u._InitialUEMessage_IEs_id_AllowedNSSAI == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AllowedNSSAI (pvalue->value.
         u._InitialUEMessage_IEs_id_AllowedNSSAI);

      stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
         u._InitialUEMessage_IEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute */
   case ASN1V_id_SourceToTarget_AMFInformationReroute:
      pvalue->value.
         t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute;

      RTXCTXTPUSHELEMNAME (pctxt, "_InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute");

      pvalue->value.
         u._InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute
          = rtxMemAllocType (pctxt, SourceToTarget_AMFInformationReroute);

      if (pvalue->value.
         u._InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SourceToTarget_AMFInformationReroute (
         (SourceToTarget_AMFInformationReroute*)pvalue->value.
         u._InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute);

      stat = asn1PD_SourceToTarget_AMFInformationReroute (pctxt, 
         (SourceToTarget_AMFInformationReroute*)pvalue->value.
         u._InitialUEMessage_IEs_id_SourceToTarget_AMFInformationReroute);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_InitialUEMessage_IEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialUEMessage_protocolIEs (OSCTXT* pctxt, InitialUEMessage_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      InitialUEMessage_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, InitialUEMessage_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InitialUEMessage_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_InitialUEMessage_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_InitialUEMessage (OSCTXT* pctxt, InitialUEMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialUEMessage");

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_InitialUEMessage_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_InitialUEMessage: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkNASTransport_protocolIEs_element (OSCTXT* pctxt, DownlinkNASTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._DownlinkNASTransport_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._DownlinkNASTransport_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkNASTransport_IEs_id_OldAMF */
   case ASN1V_id_OldAMF:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_OldAMF;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_OldAMF");

      stat = asn1PD_AMFName (pctxt, &pvalue->value.
         u._DownlinkNASTransport_IEs_id_OldAMF);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkNASTransport_IEs_id_RANPagingPriority */
   case ASN1V_id_RANPagingPriority:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_RANPagingPriority;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_RANPagingPriority");

      stat = asn1PD_RANPagingPriority (pctxt, &pvalue->value.
         u._DownlinkNASTransport_IEs_id_RANPagingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkNASTransport_IEs_id_NAS_PDU */
   case ASN1V_id_NAS_PDU:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_NAS_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_NAS_PDU");

      pvalue->value.u._DownlinkNASTransport_IEs_id_NAS_PDU
          = rtxMemAllocType (pctxt, NAS_PDU);

      if (pvalue->value.u._DownlinkNASTransport_IEs_id_NAS_PDU == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NAS_PDU (pvalue->value.u._DownlinkNASTransport_IEs_id_NAS_PDU);

      stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
         u._DownlinkNASTransport_IEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkNASTransport_IEs_id_MobilityRestrictionList */
   case ASN1V_id_MobilityRestrictionList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_MobilityRestrictionList;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_MobilityRestrictionList");

      pvalue->value.u._DownlinkNASTransport_IEs_id_MobilityRestrictionList
          = rtxMemAllocType (pctxt, MobilityRestrictionList);

      if (pvalue->value.u._DownlinkNASTransport_IEs_id_MobilityRestrictionList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MobilityRestrictionList ((MobilityRestrictionList*)pvalue->value
         .u._DownlinkNASTransport_IEs_id_MobilityRestrictionList);

      stat = asn1PD_MobilityRestrictionList (pctxt, (MobilityRestrictionList*)
         pvalue->value.u._DownlinkNASTransport_IEs_id_MobilityRestrictionList
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkNASTransport_IEs_id_IndexToRFSP */
   case ASN1V_id_IndexToRFSP:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_IndexToRFSP;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_IndexToRFSP");

      stat = asn1PD_IndexToRFSP (pctxt, &pvalue->value.
         u._DownlinkNASTransport_IEs_id_IndexToRFSP);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate */
   case ASN1V_id_UEAggregateMaximumBitRate:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate");

      pvalue->value.u._DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate
          = rtxMemAllocType (pctxt, UEAggregateMaximumBitRate);

      if (pvalue->value.
         u._DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEAggregateMaximumBitRate ((UEAggregateMaximumBitRate*)pvalue->
         value.u._DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate);

      stat = asn1PD_UEAggregateMaximumBitRate (pctxt, 
         (UEAggregateMaximumBitRate*)pvalue->value.
         u._DownlinkNASTransport_IEs_id_UEAggregateMaximumBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkNASTransport_IEs_id_AllowedNSSAI */
   case ASN1V_id_AllowedNSSAI:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_id_AllowedNSSAI;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNASTransport_IEs_id_AllowedNSSAI");

      pvalue->value.u._DownlinkNASTransport_IEs_id_AllowedNSSAI
          = rtxMemAllocType (pctxt, AllowedNSSAI);

      if (pvalue->value.u._DownlinkNASTransport_IEs_id_AllowedNSSAI == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AllowedNSSAI (pvalue->value.
         u._DownlinkNASTransport_IEs_id_AllowedNSSAI);

      stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
         u._DownlinkNASTransport_IEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_DownlinkNASTransport_IEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkNASTransport_protocolIEs (OSCTXT* pctxt, DownlinkNASTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkNASTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkNASTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkNASTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkNASTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkNASTransport (OSCTXT* pctxt, DownlinkNASTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkNASTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkNASTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNASTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkNASTransport_protocolIEs_element (OSCTXT* pctxt, UplinkNASTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UplinkNASTransport_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UplinkNASTransport_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UplinkNASTransport_IEs_id_NAS_PDU */
   case ASN1V_id_NAS_PDU:
      pvalue->value.t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_NAS_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_NAS_PDU");

      pvalue->value.u._UplinkNASTransport_IEs_id_NAS_PDU
          = rtxMemAllocType (pctxt, NAS_PDU);

      if (pvalue->value.u._UplinkNASTransport_IEs_id_NAS_PDU == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NAS_PDU (pvalue->value.u._UplinkNASTransport_IEs_id_NAS_PDU);

      stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
         u._UplinkNASTransport_IEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UplinkNASTransport_IEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNASTransport_IEs_id_UserLocationInformation");

      pvalue->value.u._UplinkNASTransport_IEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.u._UplinkNASTransport_IEs_id_UserLocationInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._UplinkNASTransport_IEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.u._UplinkNASTransport_IEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UplinkNASTransport_IEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkNASTransport_protocolIEs (OSCTXT* pctxt, UplinkNASTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkNASTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkNASTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkNASTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkNASTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkNASTransport (OSCTXT* pctxt, UplinkNASTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkNASTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkNASTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNASTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NASNonDeliveryIndication_protocolIEs_element (OSCTXT* pctxt, NASNonDeliveryIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._NASNonDeliveryIndication_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._NASNonDeliveryIndication_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NASNonDeliveryIndication_IEs_id_NAS_PDU */
   case ASN1V_id_NAS_PDU:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_NAS_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_NAS_PDU");

      pvalue->value.u._NASNonDeliveryIndication_IEs_id_NAS_PDU
          = rtxMemAllocType (pctxt, NAS_PDU);

      if (pvalue->value.u._NASNonDeliveryIndication_IEs_id_NAS_PDU == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NAS_PDU (pvalue->value.
         u._NASNonDeliveryIndication_IEs_id_NAS_PDU);

      stat = asn1PD_NAS_PDU (pctxt, pvalue->value.
         u._NASNonDeliveryIndication_IEs_id_NAS_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NASNonDeliveryIndication_IEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_NASNonDeliveryIndication_IEs_id_Cause");

      pvalue->value.u._NASNonDeliveryIndication_IEs_id_Cause
          = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._NASNonDeliveryIndication_IEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.
         u._NASNonDeliveryIndication_IEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._NASNonDeliveryIndication_IEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_NASNonDeliveryIndication_IEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NASNonDeliveryIndication_protocolIEs (OSCTXT* pctxt, NASNonDeliveryIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NASNonDeliveryIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NASNonDeliveryIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NASNonDeliveryIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NASNonDeliveryIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NASNonDeliveryIndication (OSCTXT* pctxt, NASNonDeliveryIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NASNonDeliveryIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NASNonDeliveryIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NASNonDeliveryIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RerouteNASRequest_protocolIEs_element (OSCTXT* pctxt, RerouteNASRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._RerouteNASRequest_IEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._RerouteNASRequest_IEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RerouteNASRequest_IEs_id_NGAP_Message */
   case ASN1V_id_NGAP_Message:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_NGAP_Message;

      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_NGAP_Message");

      pvalue->value.u._RerouteNASRequest_IEs_id_NGAP_Message
          = rtxMemAllocType (pctxt, _RerouteNASRequest_IEs_Value);

      if (pvalue->value.u._RerouteNASRequest_IEs_id_NGAP_Message == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init__RerouteNASRequest_IEs_Value (pvalue->value.
         u._RerouteNASRequest_IEs_id_NGAP_Message);

      stat = asn1PD__RerouteNASRequest_IEs_Value (pctxt, pvalue->value.
         u._RerouteNASRequest_IEs_id_NGAP_Message);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RerouteNASRequest_IEs_id_AMFSetID */
   case ASN1V_id_AMFSetID:
      pvalue->value.t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_AMFSetID;

      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_AMFSetID");

      pvalue->value.u._RerouteNASRequest_IEs_id_AMFSetID
          = rtxMemAllocTypeZ (pctxt, AMFSetID);

      if (pvalue->value.u._RerouteNASRequest_IEs_id_AMFSetID == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_AMFSetID (pctxt, pvalue->value.
         u._RerouteNASRequest_IEs_id_AMFSetID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RerouteNASRequest_IEs_id_AllowedNSSAI */
   case ASN1V_id_AllowedNSSAI:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_AllowedNSSAI;

      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_AllowedNSSAI");

      pvalue->value.u._RerouteNASRequest_IEs_id_AllowedNSSAI
          = rtxMemAllocType (pctxt, AllowedNSSAI);

      if (pvalue->value.u._RerouteNASRequest_IEs_id_AllowedNSSAI == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AllowedNSSAI (pvalue->value.
         u._RerouteNASRequest_IEs_id_AllowedNSSAI);

      stat = asn1PD_AllowedNSSAI (pctxt, pvalue->value.
         u._RerouteNASRequest_IEs_id_AllowedNSSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute */
   case ASN1V_id_SourceToTarget_AMFInformationReroute:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute;

      RTXCTXTPUSHELEMNAME (pctxt, "_RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute");

      pvalue->value.
         u._RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute
          = rtxMemAllocType (pctxt, SourceToTarget_AMFInformationReroute);

      if (pvalue->value.
         u._RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SourceToTarget_AMFInformationReroute (
         (SourceToTarget_AMFInformationReroute*)pvalue->value.
         u._RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute);

      stat = asn1PD_SourceToTarget_AMFInformationReroute (pctxt, 
         (SourceToTarget_AMFInformationReroute*)pvalue->value.
         u._RerouteNASRequest_IEs_id_SourceToTarget_AMFInformationReroute);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_RerouteNASRequest_IEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RerouteNASRequest_protocolIEs (OSCTXT* pctxt, RerouteNASRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RerouteNASRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RerouteNASRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RerouteNASRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RerouteNASRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RerouteNASRequest (OSCTXT* pctxt, RerouteNASRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RerouteNASRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RerouteNASRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RerouteNASRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGSetupRequest_protocolIEs_element (OSCTXT* pctxt, NGSetupRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _NGSetupRequestIEs_id_GlobalRANNodeID */
   case ASN1V_id_GlobalRANNodeID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_GlobalRANNodeID;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_GlobalRANNodeID");

      pvalue->value.u._NGSetupRequestIEs_id_GlobalRANNodeID
          = rtxMemAllocType (pctxt, GlobalRANNodeID);

      if (pvalue->value.u._NGSetupRequestIEs_id_GlobalRANNodeID == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GlobalRANNodeID ((GlobalRANNodeID*)pvalue->value.
         u._NGSetupRequestIEs_id_GlobalRANNodeID);

      stat = asn1PD_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.
         u._NGSetupRequestIEs_id_GlobalRANNodeID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupRequestIEs_id_RANNodeName */
   case ASN1V_id_RANNodeName:
      pvalue->value.t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_RANNodeName;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_RANNodeName");

      stat = asn1PD_RANNodeName (pctxt, &pvalue->value.
         u._NGSetupRequestIEs_id_RANNodeName);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupRequestIEs_id_SupportedTAList */
   case ASN1V_id_SupportedTAList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_SupportedTAList;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_SupportedTAList");

      pvalue->value.u._NGSetupRequestIEs_id_SupportedTAList
          = rtxMemAllocType (pctxt, SupportedTAList);

      if (pvalue->value.u._NGSetupRequestIEs_id_SupportedTAList == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SupportedTAList (pvalue->value.
         u._NGSetupRequestIEs_id_SupportedTAList);

      stat = asn1PD_SupportedTAList (pctxt, pvalue->value.
         u._NGSetupRequestIEs_id_SupportedTAList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupRequestIEs_id_DefaultPagingDRX */
   case ASN1V_id_DefaultPagingDRX:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_DefaultPagingDRX;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_DefaultPagingDRX");

      stat = asn1PD_PagingDRX (pctxt, &pvalue->value.
         u._NGSetupRequestIEs_id_DefaultPagingDRX);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupRequestIEs_id_UERetentionInformation */
   case ASN1V_id_UERetentionInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGSetupRequestIEs_id_UERetentionInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupRequestIEs_id_UERetentionInformation");

      stat = asn1PD_UERetentionInformation (pctxt, &pvalue->value.
         u._NGSetupRequestIEs_id_UERetentionInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_NGSetupRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupRequest_protocolIEs (OSCTXT* pctxt, NGSetupRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGSetupRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGSetupRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGSetupRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGSetupRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupRequest (OSCTXT* pctxt, NGSetupRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGSetupRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NGSetupRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGSetupResponse_protocolIEs_element (OSCTXT* pctxt, NGSetupResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _NGSetupResponseIEs_id_AMFName */
   case ASN1V_id_AMFName:
      pvalue->value.t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_AMFName;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_AMFName");

      stat = asn1PD_AMFName (pctxt, &pvalue->value.
         u._NGSetupResponseIEs_id_AMFName);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupResponseIEs_id_ServedGUAMIList */
   case ASN1V_id_ServedGUAMIList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_ServedGUAMIList;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_ServedGUAMIList");

      pvalue->value.u._NGSetupResponseIEs_id_ServedGUAMIList
          = rtxMemAllocType (pctxt, ServedGUAMIList);

      if (pvalue->value.u._NGSetupResponseIEs_id_ServedGUAMIList == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ServedGUAMIList (pvalue->value.
         u._NGSetupResponseIEs_id_ServedGUAMIList);

      stat = asn1PD_ServedGUAMIList (pctxt, pvalue->value.
         u._NGSetupResponseIEs_id_ServedGUAMIList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupResponseIEs_id_RelativeAMFCapacity */
   case ASN1V_id_RelativeAMFCapacity:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_RelativeAMFCapacity;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_RelativeAMFCapacity");

      stat = asn1PD_RelativeAMFCapacity (pctxt, &pvalue->value.
         u._NGSetupResponseIEs_id_RelativeAMFCapacity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupResponseIEs_id_PLMNSupportList */
   case ASN1V_id_PLMNSupportList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_PLMNSupportList;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_PLMNSupportList");

      pvalue->value.u._NGSetupResponseIEs_id_PLMNSupportList
          = rtxMemAllocType (pctxt, PLMNSupportList);

      if (pvalue->value.u._NGSetupResponseIEs_id_PLMNSupportList == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PLMNSupportList (pvalue->value.
         u._NGSetupResponseIEs_id_PLMNSupportList);

      stat = asn1PD_PLMNSupportList (pctxt, pvalue->value.
         u._NGSetupResponseIEs_id_PLMNSupportList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupResponseIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_CriticalityDiagnostics");

      pvalue->value.u._NGSetupResponseIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.u._NGSetupResponseIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._NGSetupResponseIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.u._NGSetupResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupResponseIEs_id_UERetentionInformation */
   case ASN1V_id_UERetentionInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGSetupResponseIEs_id_UERetentionInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupResponseIEs_id_UERetentionInformation");

      stat = asn1PD_UERetentionInformation (pctxt, &pvalue->value.
         u._NGSetupResponseIEs_id_UERetentionInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_NGSetupResponseIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupResponse_protocolIEs (OSCTXT* pctxt, NGSetupResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGSetupResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGSetupResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGSetupResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGSetupResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupResponse (OSCTXT* pctxt, NGSetupResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGSetupResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NGSetupResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGSetupFailure_protocolIEs_element (OSCTXT* pctxt, NGSetupFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _NGSetupFailureIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.t = T_NGAP_PDU_Contents_NGSetupFailureIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupFailureIEs_id_Cause");

      pvalue->value.u._NGSetupFailureIEs_id_Cause = rtxMemAllocType (pctxt, 
         Cause);

      if (pvalue->value.u._NGSetupFailureIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.u._NGSetupFailureIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._NGSetupFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupFailureIEs_id_TimeToWait */
   case ASN1V_id_TimeToWait:
      pvalue->value.t = T_NGAP_PDU_Contents_NGSetupFailureIEs_id_TimeToWait;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupFailureIEs_id_TimeToWait");

      stat = asn1PD_TimeToWait (pctxt, &pvalue->value.
         u._NGSetupFailureIEs_id_TimeToWait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGSetupFailureIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGSetupFailureIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGSetupFailureIEs_id_CriticalityDiagnostics");

      pvalue->value.u._NGSetupFailureIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.u._NGSetupFailureIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._NGSetupFailureIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.u._NGSetupFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_NGSetupFailureIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupFailure_protocolIEs (OSCTXT* pctxt, NGSetupFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGSetupFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGSetupFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGSetupFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGSetupFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NGSetupFailure (OSCTXT* pctxt, NGSetupFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGSetupFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NGSetupFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGSetupFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdate_protocolIEs_element (OSCTXT* pctxt, RANConfigurationUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _RANConfigurationUpdateIEs_id_RANNodeName */
   case ASN1V_id_RANNodeName:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_RANNodeName;

      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_RANNodeName");

      stat = asn1PD_RANNodeName (pctxt, &pvalue->value.
         u._RANConfigurationUpdateIEs_id_RANNodeName);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RANConfigurationUpdateIEs_id_SupportedTAList */
   case ASN1V_id_SupportedTAList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_SupportedTAList;

      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_SupportedTAList");

      pvalue->value.u._RANConfigurationUpdateIEs_id_SupportedTAList
          = rtxMemAllocType (pctxt, SupportedTAList);

      if (pvalue->value.u._RANConfigurationUpdateIEs_id_SupportedTAList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SupportedTAList (pvalue->value.
         u._RANConfigurationUpdateIEs_id_SupportedTAList);

      stat = asn1PD_SupportedTAList (pctxt, pvalue->value.
         u._RANConfigurationUpdateIEs_id_SupportedTAList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RANConfigurationUpdateIEs_id_DefaultPagingDRX */
   case ASN1V_id_DefaultPagingDRX:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_DefaultPagingDRX;

      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_DefaultPagingDRX");

      stat = asn1PD_PagingDRX (pctxt, &pvalue->value.
         u._RANConfigurationUpdateIEs_id_DefaultPagingDRX);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RANConfigurationUpdateIEs_id_GlobalRANNodeID */
   case ASN1V_id_GlobalRANNodeID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_GlobalRANNodeID;

      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_GlobalRANNodeID");

      pvalue->value.u._RANConfigurationUpdateIEs_id_GlobalRANNodeID
          = rtxMemAllocType (pctxt, GlobalRANNodeID);

      if (pvalue->value.u._RANConfigurationUpdateIEs_id_GlobalRANNodeID
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GlobalRANNodeID ((GlobalRANNodeID*)pvalue->value.
         u._RANConfigurationUpdateIEs_id_GlobalRANNodeID);

      stat = asn1PD_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.
         u._RANConfigurationUpdateIEs_id_GlobalRANNodeID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList */
   case ASN1V_id_NGRAN_TNLAssociationToRemoveList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList;

      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList");

      pvalue->value.
         u._RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList
          = rtxMemAllocType (pctxt, NGRAN_TNLAssociationToRemoveList);

      if (pvalue->value.
         u._RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGRAN_TNLAssociationToRemoveList (pvalue->value.
         u._RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList);

      stat = asn1PD_NGRAN_TNLAssociationToRemoveList (pctxt, pvalue->value.
         u._RANConfigurationUpdateIEs_id_NGRAN_TNLAssociationToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_RANConfigurationUpdateIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdate_protocolIEs (OSCTXT* pctxt, RANConfigurationUpdate_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RANConfigurationUpdate_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RANConfigurationUpdate_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RANConfigurationUpdate_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RANConfigurationUpdate_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdate (OSCTXT* pctxt, RANConfigurationUpdate* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANConfigurationUpdate");

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RANConfigurationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, RANConfigurationUpdateAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics (pvalue->value.
         u._RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, pvalue->value.
         u._RANConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_RANConfigurationUpdateAcknowledgeIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs (OSCTXT* pctxt, RANConfigurationUpdateAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RANConfigurationUpdateAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RANConfigurationUpdateAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RANConfigurationUpdateAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateAcknowledge (OSCTXT* pctxt, RANConfigurationUpdateAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANConfigurationUpdateAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RANConfigurationUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateFailure_protocolIEs_element (OSCTXT* pctxt, RANConfigurationUpdateFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _RANConfigurationUpdateFailureIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateFailureIEs_id_Cause");

      pvalue->value.u._RANConfigurationUpdateFailureIEs_id_Cause
          = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._RANConfigurationUpdateFailureIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.
         u._RANConfigurationUpdateFailureIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._RANConfigurationUpdateFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RANConfigurationUpdateFailureIEs_id_TimeToWait */
   case ASN1V_id_TimeToWait:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_id_TimeToWait;

      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateFailureIEs_id_TimeToWait");

      stat = asn1PD_TimeToWait (pctxt, &pvalue->value.
         u._RANConfigurationUpdateFailureIEs_id_TimeToWait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._RANConfigurationUpdateFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_RANConfigurationUpdateFailureIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateFailure_protocolIEs (OSCTXT* pctxt, RANConfigurationUpdateFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      RANConfigurationUpdateFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, RANConfigurationUpdateFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RANConfigurationUpdateFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_RANConfigurationUpdateFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_RANConfigurationUpdateFailure (OSCTXT* pctxt, RANConfigurationUpdateFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANConfigurationUpdateFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_RANConfigurationUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_RANConfigurationUpdateFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdate_protocolIEs_element (OSCTXT* pctxt, AMFConfigurationUpdate_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _AMFConfigurationUpdateIEs_id_AMFName */
   case ASN1V_id_AMFName:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMFName;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMFName");

      stat = asn1PD_AMFName (pctxt, &pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMFName);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _AMFConfigurationUpdateIEs_id_ServedGUAMIList */
   case ASN1V_id_ServedGUAMIList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_ServedGUAMIList;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_ServedGUAMIList");

      pvalue->value.u._AMFConfigurationUpdateIEs_id_ServedGUAMIList
          = rtxMemAllocType (pctxt, ServedGUAMIList);

      if (pvalue->value.u._AMFConfigurationUpdateIEs_id_ServedGUAMIList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ServedGUAMIList (pvalue->value.
         u._AMFConfigurationUpdateIEs_id_ServedGUAMIList);

      stat = asn1PD_ServedGUAMIList (pctxt, pvalue->value.
         u._AMFConfigurationUpdateIEs_id_ServedGUAMIList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _AMFConfigurationUpdateIEs_id_RelativeAMFCapacity */
   case ASN1V_id_RelativeAMFCapacity:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_RelativeAMFCapacity;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_RelativeAMFCapacity");

      stat = asn1PD_RelativeAMFCapacity (pctxt, &pvalue->value.
         u._AMFConfigurationUpdateIEs_id_RelativeAMFCapacity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _AMFConfigurationUpdateIEs_id_PLMNSupportList */
   case ASN1V_id_PLMNSupportList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_PLMNSupportList;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_PLMNSupportList");

      pvalue->value.u._AMFConfigurationUpdateIEs_id_PLMNSupportList
          = rtxMemAllocType (pctxt, PLMNSupportList);

      if (pvalue->value.u._AMFConfigurationUpdateIEs_id_PLMNSupportList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PLMNSupportList (pvalue->value.
         u._AMFConfigurationUpdateIEs_id_PLMNSupportList);

      stat = asn1PD_PLMNSupportList (pctxt, pvalue->value.
         u._AMFConfigurationUpdateIEs_id_PLMNSupportList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList */
   case ASN1V_id_AMF_TNLAssociationToAddList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList");

      pvalue->value.u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList
          = rtxMemAllocType (pctxt, AMF_TNLAssociationToAddList);

      if (pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationToAddList (pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList);

      stat = asn1PD_AMF_TNLAssociationToAddList (pctxt, pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToAddList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList */
   case ASN1V_id_AMF_TNLAssociationToRemoveList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList");

      pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList
          = rtxMemAllocType (pctxt, AMF_TNLAssociationToRemoveList);

      if (pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationToRemoveList (pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList);

      stat = asn1PD_AMF_TNLAssociationToRemoveList (pctxt, pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToRemoveList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList */
   case ASN1V_id_AMF_TNLAssociationToUpdateList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList");

      pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList
          = rtxMemAllocType (pctxt, AMF_TNLAssociationToUpdateList);

      if (pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationToUpdateList (pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList);

      stat = asn1PD_AMF_TNLAssociationToUpdateList (pctxt, pvalue->value.
         u._AMFConfigurationUpdateIEs_id_AMF_TNLAssociationToUpdateList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_AMFConfigurationUpdateIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdate_protocolIEs (OSCTXT* pctxt, AMFConfigurationUpdate_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMFConfigurationUpdate_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMFConfigurationUpdate_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMFConfigurationUpdate_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMFConfigurationUpdate_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdate (OSCTXT* pctxt, AMFConfigurationUpdate* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFConfigurationUpdate");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_AMFConfigurationUpdate_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdate: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs_element (OSCTXT* pctxt, AMFConfigurationUpdateAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList */
   case ASN1V_id_AMF_TNLAssociationSetupList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList");

      pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList
          = rtxMemAllocType (pctxt, AMF_TNLAssociationSetupList);

      if (pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMF_TNLAssociationSetupList (pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList
         );

      stat = asn1PD_AMF_TNLAssociationSetupList (pctxt, pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationSetupList
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList */
   case ASN1V_id_AMF_TNLAssociationFailedToSetupList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList");

      pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList
          = rtxMemAllocType (pctxt, TNLAssociationList);

      if (pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TNLAssociationList (pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList
         );

      stat = asn1PD_TNLAssociationList (pctxt, pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_AMF_TNLAssociationFailedToSetupList
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._AMFConfigurationUpdateAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_AMFConfigurationUpdateAcknowledgeIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs (OSCTXT* pctxt, AMFConfigurationUpdateAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMFConfigurationUpdateAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMFConfigurationUpdateAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMFConfigurationUpdateAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateAcknowledge (OSCTXT* pctxt, AMFConfigurationUpdateAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFConfigurationUpdateAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_AMFConfigurationUpdateAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateFailure_protocolIEs_element (OSCTXT* pctxt, AMFConfigurationUpdateFailure_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _AMFConfigurationUpdateFailureIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateFailureIEs_id_Cause");

      pvalue->value.u._AMFConfigurationUpdateFailureIEs_id_Cause
          = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._AMFConfigurationUpdateFailureIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.
         u._AMFConfigurationUpdateFailureIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._AMFConfigurationUpdateFailureIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _AMFConfigurationUpdateFailureIEs_id_TimeToWait */
   case ASN1V_id_TimeToWait:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_id_TimeToWait;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateFailureIEs_id_TimeToWait");

      stat = asn1PD_TimeToWait (pctxt, &pvalue->value.
         u._AMFConfigurationUpdateFailureIEs_id_TimeToWait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._AMFConfigurationUpdateFailureIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_AMFConfigurationUpdateFailureIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateFailure_protocolIEs (OSCTXT* pctxt, AMFConfigurationUpdateFailure_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMFConfigurationUpdateFailure_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMFConfigurationUpdateFailure_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMFConfigurationUpdateFailure_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMFConfigurationUpdateFailure_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFConfigurationUpdateFailure (OSCTXT* pctxt, AMFConfigurationUpdateFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFConfigurationUpdateFailure");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_AMFConfigurationUpdateFailure_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFConfigurationUpdateFailure: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_AMFStatusIndication_protocolIEs_element (OSCTXT* pctxt, AMFStatusIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _AMFStatusIndicationIEs_id_UnavailableGUAMIList */
   case ASN1V_id_UnavailableGUAMIList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_AMFStatusIndicationIEs_id_UnavailableGUAMIList;

      RTXCTXTPUSHELEMNAME (pctxt, "_AMFStatusIndicationIEs_id_UnavailableGUAMIList");

      pvalue->value.u._AMFStatusIndicationIEs_id_UnavailableGUAMIList
          = rtxMemAllocType (pctxt, UnavailableGUAMIList);

      if (pvalue->value.u._AMFStatusIndicationIEs_id_UnavailableGUAMIList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnavailableGUAMIList (pvalue->value.
         u._AMFStatusIndicationIEs_id_UnavailableGUAMIList);

      stat = asn1PD_UnavailableGUAMIList (pctxt, pvalue->value.
         u._AMFStatusIndicationIEs_id_UnavailableGUAMIList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_AMFStatusIndicationIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFStatusIndication_protocolIEs (OSCTXT* pctxt, AMFStatusIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      AMFStatusIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, AMFStatusIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AMFStatusIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_AMFStatusIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_AMFStatusIndication (OSCTXT* pctxt, AMFStatusIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AMFStatusIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_AMFStatusIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_AMFStatusIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGReset_protocolIEs_element (OSCTXT* pctxt, NGReset_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _NGResetIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.t = T_NGAP_PDU_Contents_NGResetIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGResetIEs_id_Cause");

      pvalue->value.u._NGResetIEs_id_Cause = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._NGResetIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.u._NGResetIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.u._NGResetIEs_id_Cause
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGResetIEs_id_ResetType */
   case ASN1V_id_ResetType:
      pvalue->value.t = T_NGAP_PDU_Contents_NGResetIEs_id_ResetType;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGResetIEs_id_ResetType");

      pvalue->value.u._NGResetIEs_id_ResetType = rtxMemAllocType (pctxt, 
         ResetType);

      if (pvalue->value.u._NGResetIEs_id_ResetType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ResetType ((ResetType*)pvalue->value.u._NGResetIEs_id_ResetType
         );

      stat = asn1PD_ResetType (pctxt, (ResetType*)pvalue->value.
         u._NGResetIEs_id_ResetType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_NGResetIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGReset_protocolIEs (OSCTXT* pctxt, NGReset_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGReset_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGReset_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGReset_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGReset_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NGReset (OSCTXT* pctxt, NGReset* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGReset");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NGReset_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGReset: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_NGResetAcknowledge_protocolIEs_element (OSCTXT* pctxt, NGResetAcknowledge_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList */
   case ASN1V_id_UE_associatedLogicalNG_connectionList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList");

      pvalue->value.
         u._NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList
          = rtxMemAllocType (pctxt, UE_associatedLogicalNG_connectionList);

      if (pvalue->value.
         u._NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UE_associatedLogicalNG_connectionList (pvalue->value.
         u._NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList);

      stat = asn1PD_UE_associatedLogicalNG_connectionList (pctxt, pvalue->value
         .u._NGResetAcknowledgeIEs_id_UE_associatedLogicalNG_connectionList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _NGResetAcknowledgeIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_NGResetAcknowledgeIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_NGResetAcknowledgeIEs_id_CriticalityDiagnostics");

      pvalue->value.u._NGResetAcknowledgeIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.u._NGResetAcknowledgeIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._NGResetAcknowledgeIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.u._NGResetAcknowledgeIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_NGResetAcknowledgeIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_NGResetAcknowledge_protocolIEs (OSCTXT* pctxt, NGResetAcknowledge_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      NGResetAcknowledge_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, NGResetAcknowledge_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGResetAcknowledge_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_NGResetAcknowledge_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_NGResetAcknowledge (OSCTXT* pctxt, NGResetAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "NGResetAcknowledge");

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_NGResetAcknowledge_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_NGResetAcknowledge: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ErrorIndication_protocolIEs_element (OSCTXT* pctxt, ErrorIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _ErrorIndicationIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_ErrorIndicationIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._ErrorIndicationIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _ErrorIndicationIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_ErrorIndicationIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._ErrorIndicationIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _ErrorIndicationIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.t = T_NGAP_PDU_Contents_ErrorIndicationIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_Cause");

      pvalue->value.u._ErrorIndicationIEs_id_Cause = rtxMemAllocType (pctxt, 
         Cause);

      if (pvalue->value.u._ErrorIndicationIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.u._ErrorIndicationIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._ErrorIndicationIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _ErrorIndicationIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_ErrorIndicationIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_ErrorIndicationIEs_id_CriticalityDiagnostics");

      pvalue->value.u._ErrorIndicationIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.u._ErrorIndicationIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._ErrorIndicationIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.u._ErrorIndicationIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_ErrorIndicationIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_ErrorIndication_protocolIEs (OSCTXT* pctxt, ErrorIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ErrorIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ErrorIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ErrorIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ErrorIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_ErrorIndication (OSCTXT* pctxt, ErrorIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ErrorIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ErrorIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_ErrorIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_OverloadStart_protocolIEs_element (OSCTXT* pctxt, OverloadStart_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _OverloadStartIEs_id_AMFOverloadResponse */
   case ASN1V_id_AMFOverloadResponse:
      pvalue->value.
         t = T_NGAP_PDU_Contents_OverloadStartIEs_id_AMFOverloadResponse;

      RTXCTXTPUSHELEMNAME (pctxt, "_OverloadStartIEs_id_AMFOverloadResponse");

      pvalue->value.u._OverloadStartIEs_id_AMFOverloadResponse
          = rtxMemAllocType (pctxt, OverloadResponse);

      if (pvalue->value.u._OverloadStartIEs_id_AMFOverloadResponse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_OverloadResponse ((OverloadResponse*)pvalue->value.
         u._OverloadStartIEs_id_AMFOverloadResponse);

      stat = asn1PD_OverloadResponse (pctxt, (OverloadResponse*)pvalue->value.
         u._OverloadStartIEs_id_AMFOverloadResponse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _OverloadStartIEs_id_AMFTrafficLoadReductionIndication */
   case ASN1V_id_AMFTrafficLoadReductionIndication:
      pvalue->value.
         t = T_NGAP_PDU_Contents_OverloadStartIEs_id_AMFTrafficLoadReductionIndication;

      RTXCTXTPUSHELEMNAME (pctxt, "_OverloadStartIEs_id_AMFTrafficLoadReductionIndication");

      stat = asn1PD_TrafficLoadReductionIndication (pctxt, &pvalue->value.
         u._OverloadStartIEs_id_AMFTrafficLoadReductionIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _OverloadStartIEs_id_OverloadStartNSSAIList */
   case ASN1V_id_OverloadStartNSSAIList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_OverloadStartIEs_id_OverloadStartNSSAIList;

      RTXCTXTPUSHELEMNAME (pctxt, "_OverloadStartIEs_id_OverloadStartNSSAIList");

      pvalue->value.u._OverloadStartIEs_id_OverloadStartNSSAIList
          = rtxMemAllocType (pctxt, OverloadStartNSSAIList);

      if (pvalue->value.u._OverloadStartIEs_id_OverloadStartNSSAIList == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_OverloadStartNSSAIList (pvalue->value.
         u._OverloadStartIEs_id_OverloadStartNSSAIList);

      stat = asn1PD_OverloadStartNSSAIList (pctxt, pvalue->value.
         u._OverloadStartIEs_id_OverloadStartNSSAIList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_OverloadStartIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadStart_protocolIEs (OSCTXT* pctxt, OverloadStart_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      OverloadStart_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, OverloadStart_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_OverloadStart_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_OverloadStart_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadStart (OSCTXT* pctxt, OverloadStart* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OverloadStart");

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_OverloadStart_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStart: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_OverloadStop_protocolIEs_element (OSCTXT* pctxt, OverloadStop_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadStop_protocolIEs (OSCTXT* pctxt, OverloadStop_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      OverloadStop_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, OverloadStop_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_OverloadStop_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_OverloadStop_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_OverloadStop (OSCTXT* pctxt, OverloadStop* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "OverloadStop");

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_OverloadStop_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_OverloadStop: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkRANConfigurationTransfer_protocolIEs_element (OSCTXT* pctxt, UplinkRANConfigurationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL */
   case ASN1V_id_SONConfigurationTransferUL:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL");

      pvalue->value.
         u._UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL
          = rtxMemAllocType (pctxt, SONConfigurationTransfer);

      if (pvalue->value.
         u._UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SONConfigurationTransfer ((SONConfigurationTransfer*)pvalue->
         value.
         u._UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL);

      stat = asn1PD_SONConfigurationTransfer (pctxt, 
         (SONConfigurationTransfer*)pvalue->value.
         u._UplinkRANConfigurationTransferIEs_id_SONConfigurationTransferUL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL */
   case ASN1V_id_ENDC_SONConfigurationTransferUL:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL");

      pvalue->value.
         u._UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL
          = rtxMemAllocType (pctxt, EN_DCSONConfigurationTransfer);

      if (pvalue->value.
         u._UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EN_DCSONConfigurationTransfer (pvalue->value.
         u._UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL
         );

      stat = asn1PD_EN_DCSONConfigurationTransfer (pctxt, pvalue->value.
         u._UplinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferUL
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UplinkRANConfigurationTransferIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRANConfigurationTransfer_protocolIEs (OSCTXT* pctxt, UplinkRANConfigurationTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkRANConfigurationTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkRANConfigurationTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkRANConfigurationTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkRANConfigurationTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkRANConfigurationTransfer (OSCTXT* pctxt, UplinkRANConfigurationTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkRANConfigurationTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkRANConfigurationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkRANConfigurationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkRANConfigurationTransfer_protocolIEs_element (OSCTXT* pctxt, DownlinkRANConfigurationTransfer_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL */
   case ASN1V_id_SONConfigurationTransferDL:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL");

      pvalue->value.
         u._DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL
          = rtxMemAllocType (pctxt, SONConfigurationTransfer);

      if (pvalue->value.
         u._DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SONConfigurationTransfer ((SONConfigurationTransfer*)pvalue->
         value.
         u._DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL
         );

      stat = asn1PD_SONConfigurationTransfer (pctxt, 
         (SONConfigurationTransfer*)pvalue->value.
         u._DownlinkRANConfigurationTransferIEs_id_SONConfigurationTransferDL
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL */
   case ASN1V_id_ENDC_SONConfigurationTransferDL:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL");

      pvalue->value.
         u._DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL
          = rtxMemAllocType (pctxt, EN_DCSONConfigurationTransfer);

      if (pvalue->value.
         u._DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EN_DCSONConfigurationTransfer (pvalue->value.
         u._DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL
         );

      stat = asn1PD_EN_DCSONConfigurationTransfer (pctxt, pvalue->value.
         u._DownlinkRANConfigurationTransferIEs_id_ENDC_SONConfigurationTransferDL
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_DownlinkRANConfigurationTransferIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRANConfigurationTransfer_protocolIEs (OSCTXT* pctxt, DownlinkRANConfigurationTransfer_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkRANConfigurationTransfer_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkRANConfigurationTransfer_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkRANConfigurationTransfer_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkRANConfigurationTransfer_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkRANConfigurationTransfer (OSCTXT* pctxt, DownlinkRANConfigurationTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkRANConfigurationTransfer");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkRANConfigurationTransfer_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkRANConfigurationTransfer: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningRequest_protocolIEs_element (OSCTXT* pctxt, WriteReplaceWarningRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _WriteReplaceWarningRequestIEs_id_MessageIdentifier */
   case ASN1V_id_MessageIdentifier:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_MessageIdentifier;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_MessageIdentifier");

      pvalue->value.u._WriteReplaceWarningRequestIEs_id_MessageIdentifier
          = rtxMemAllocTypeZ (pctxt, MessageIdentifier);

      if (pvalue->value.u._WriteReplaceWarningRequestIEs_id_MessageIdentifier
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_MessageIdentifier (pctxt, pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_MessageIdentifier);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningRequestIEs_id_SerialNumber */
   case ASN1V_id_SerialNumber:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_SerialNumber;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_SerialNumber");

      pvalue->value.u._WriteReplaceWarningRequestIEs_id_SerialNumber
          = rtxMemAllocTypeZ (pctxt, SerialNumber);

      if (pvalue->value.u._WriteReplaceWarningRequestIEs_id_SerialNumber
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_SerialNumber (pctxt, pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_SerialNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningRequestIEs_id_WarningAreaList */
   case ASN1V_id_WarningAreaList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningAreaList;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningAreaList");

      pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningAreaList
          = rtxMemAllocType (pctxt, WarningAreaList);

      if (pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningAreaList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_WarningAreaList ((WarningAreaList*)pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_WarningAreaList);

      stat = asn1PD_WarningAreaList (pctxt, (WarningAreaList*)pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_WarningAreaList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningRequestIEs_id_RepetitionPeriod */
   case ASN1V_id_RepetitionPeriod:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_RepetitionPeriod;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_RepetitionPeriod");

      stat = asn1PD_RepetitionPeriod (pctxt, &pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_RepetitionPeriod);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested */
   case ASN1V_id_NumberOfBroadcastsRequested:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested");

      stat = asn1PD_NumberOfBroadcastsRequested (pctxt, &pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_NumberOfBroadcastsRequested);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningRequestIEs_id_WarningType */
   case ASN1V_id_WarningType:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningType;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningType");

      pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningType
          = rtxMemAllocTypeZ (pctxt, WarningType);

      if (pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningType
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_WarningType (pctxt, (WarningType*)pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_WarningType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningRequestIEs_id_WarningSecurityInfo */
   case ASN1V_id_WarningSecurityInfo:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningSecurityInfo;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningSecurityInfo");

      pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningSecurityInfo
          = rtxMemAllocTypeZ (pctxt, WarningSecurityInfo);

      if (pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningSecurityInfo
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_WarningSecurityInfo (pctxt, (WarningSecurityInfo*)pvalue->
         value.u._WriteReplaceWarningRequestIEs_id_WarningSecurityInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningRequestIEs_id_DataCodingScheme */
   case ASN1V_id_DataCodingScheme:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_DataCodingScheme;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_DataCodingScheme");

      pvalue->value.u._WriteReplaceWarningRequestIEs_id_DataCodingScheme
          = rtxMemAllocTypeZ (pctxt, DataCodingScheme);

      if (pvalue->value.u._WriteReplaceWarningRequestIEs_id_DataCodingScheme
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_DataCodingScheme (pctxt, pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_DataCodingScheme);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningRequestIEs_id_WarningMessageContents */
   case ASN1V_id_WarningMessageContents:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningMessageContents;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningMessageContents");

      pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningMessageContents
          = rtxMemAllocType (pctxt, WarningMessageContents);

      if (pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_WarningMessageContents == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_WarningMessageContents ((WarningMessageContents*)pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_WarningMessageContents);

      stat = asn1PD_WarningMessageContents (pctxt, (WarningMessageContents*)
         pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_WarningMessageContents);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd */
   case ASN1V_id_ConcurrentWarningMessageInd:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd");

      stat = asn1PD_ConcurrentWarningMessageInd (pctxt, &pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_ConcurrentWarningMessageInd);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates */
   case ASN1V_id_WarningAreaCoordinates:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates");

      pvalue->value.u._WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates
          = rtxMemAllocType (pctxt, WarningAreaCoordinates);

      if (pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_WarningAreaCoordinates ((WarningAreaCoordinates*)pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates);

      stat = asn1PD_WarningAreaCoordinates (pctxt, (WarningAreaCoordinates*)
         pvalue->value.
         u._WriteReplaceWarningRequestIEs_id_WarningAreaCoordinates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_WriteReplaceWarningRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningRequest_protocolIEs (OSCTXT* pctxt, WriteReplaceWarningRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      WriteReplaceWarningRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, WriteReplaceWarningRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_WriteReplaceWarningRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_WriteReplaceWarningRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningRequest (OSCTXT* pctxt, WriteReplaceWarningRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "WriteReplaceWarningRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_WriteReplaceWarningRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningResponse_protocolIEs_element (OSCTXT* pctxt, WriteReplaceWarningResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _WriteReplaceWarningResponseIEs_id_MessageIdentifier */
   case ASN1V_id_MessageIdentifier:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_MessageIdentifier;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_MessageIdentifier");

      pvalue->value.u._WriteReplaceWarningResponseIEs_id_MessageIdentifier
          = rtxMemAllocTypeZ (pctxt, MessageIdentifier);

      if (pvalue->value.u._WriteReplaceWarningResponseIEs_id_MessageIdentifier
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_MessageIdentifier (pctxt, pvalue->value.
         u._WriteReplaceWarningResponseIEs_id_MessageIdentifier);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningResponseIEs_id_SerialNumber */
   case ASN1V_id_SerialNumber:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_SerialNumber;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_SerialNumber");

      pvalue->value.u._WriteReplaceWarningResponseIEs_id_SerialNumber
          = rtxMemAllocTypeZ (pctxt, SerialNumber);

      if (pvalue->value.u._WriteReplaceWarningResponseIEs_id_SerialNumber
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_SerialNumber (pctxt, pvalue->value.
         u._WriteReplaceWarningResponseIEs_id_SerialNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList */
   case ASN1V_id_BroadcastCompletedAreaList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList");

      pvalue->value.
         u._WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList
          = rtxMemAllocType (pctxt, BroadcastCompletedAreaList);

      if (pvalue->value.
         u._WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BroadcastCompletedAreaList ((BroadcastCompletedAreaList*)pvalue
         ->value.
         u._WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList);

      stat = asn1PD_BroadcastCompletedAreaList (pctxt, 
         (BroadcastCompletedAreaList*)pvalue->value.
         u._WriteReplaceWarningResponseIEs_id_BroadcastCompletedAreaList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics");

      pvalue->value.u._WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._WriteReplaceWarningResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_WriteReplaceWarningResponseIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningResponse_protocolIEs (OSCTXT* pctxt, WriteReplaceWarningResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      WriteReplaceWarningResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, WriteReplaceWarningResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_WriteReplaceWarningResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_WriteReplaceWarningResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_WriteReplaceWarningResponse (OSCTXT* pctxt, WriteReplaceWarningResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "WriteReplaceWarningResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_WriteReplaceWarningResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_WriteReplaceWarningResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PWSCancelRequest_protocolIEs_element (OSCTXT* pctxt, PWSCancelRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PWSCancelRequestIEs_id_MessageIdentifier */
   case ASN1V_id_MessageIdentifier:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_MessageIdentifier;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_MessageIdentifier");

      pvalue->value.u._PWSCancelRequestIEs_id_MessageIdentifier
          = rtxMemAllocTypeZ (pctxt, MessageIdentifier);

      if (pvalue->value.u._PWSCancelRequestIEs_id_MessageIdentifier == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_MessageIdentifier (pctxt, pvalue->value.
         u._PWSCancelRequestIEs_id_MessageIdentifier);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PWSCancelRequestIEs_id_SerialNumber */
   case ASN1V_id_SerialNumber:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_SerialNumber;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_SerialNumber");

      pvalue->value.u._PWSCancelRequestIEs_id_SerialNumber
          = rtxMemAllocTypeZ (pctxt, SerialNumber);

      if (pvalue->value.u._PWSCancelRequestIEs_id_SerialNumber == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_SerialNumber (pctxt, pvalue->value.
         u._PWSCancelRequestIEs_id_SerialNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PWSCancelRequestIEs_id_WarningAreaList */
   case ASN1V_id_WarningAreaList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_WarningAreaList;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_WarningAreaList");

      pvalue->value.u._PWSCancelRequestIEs_id_WarningAreaList
          = rtxMemAllocType (pctxt, WarningAreaList);

      if (pvalue->value.u._PWSCancelRequestIEs_id_WarningAreaList == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_WarningAreaList ((WarningAreaList*)pvalue->value.
         u._PWSCancelRequestIEs_id_WarningAreaList);

      stat = asn1PD_WarningAreaList (pctxt, (WarningAreaList*)pvalue->value.
         u._PWSCancelRequestIEs_id_WarningAreaList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PWSCancelRequestIEs_id_CancelAllWarningMessages */
   case ASN1V_id_CancelAllWarningMessages:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSCancelRequestIEs_id_CancelAllWarningMessages;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelRequestIEs_id_CancelAllWarningMessages");

      stat = asn1PD_CancelAllWarningMessages (pctxt, &pvalue->value.
         u._PWSCancelRequestIEs_id_CancelAllWarningMessages);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PWSCancelRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSCancelRequest_protocolIEs (OSCTXT* pctxt, PWSCancelRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PWSCancelRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PWSCancelRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PWSCancelRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PWSCancelRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSCancelRequest (OSCTXT* pctxt, PWSCancelRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSCancelRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PWSCancelRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PWSCancelResponse_protocolIEs_element (OSCTXT* pctxt, PWSCancelResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PWSCancelResponseIEs_id_MessageIdentifier */
   case ASN1V_id_MessageIdentifier:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_MessageIdentifier;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_MessageIdentifier");

      pvalue->value.u._PWSCancelResponseIEs_id_MessageIdentifier
          = rtxMemAllocTypeZ (pctxt, MessageIdentifier);

      if (pvalue->value.u._PWSCancelResponseIEs_id_MessageIdentifier == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_MessageIdentifier (pctxt, pvalue->value.
         u._PWSCancelResponseIEs_id_MessageIdentifier);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PWSCancelResponseIEs_id_SerialNumber */
   case ASN1V_id_SerialNumber:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_SerialNumber;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_SerialNumber");

      pvalue->value.u._PWSCancelResponseIEs_id_SerialNumber
          = rtxMemAllocTypeZ (pctxt, SerialNumber);

      if (pvalue->value.u._PWSCancelResponseIEs_id_SerialNumber == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_SerialNumber (pctxt, pvalue->value.
         u._PWSCancelResponseIEs_id_SerialNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PWSCancelResponseIEs_id_BroadcastCancelledAreaList */
   case ASN1V_id_BroadcastCancelledAreaList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_BroadcastCancelledAreaList;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_BroadcastCancelledAreaList");

      pvalue->value.u._PWSCancelResponseIEs_id_BroadcastCancelledAreaList
          = rtxMemAllocType (pctxt, BroadcastCancelledAreaList);

      if (pvalue->value.u._PWSCancelResponseIEs_id_BroadcastCancelledAreaList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BroadcastCancelledAreaList ((BroadcastCancelledAreaList*)pvalue
         ->value.u._PWSCancelResponseIEs_id_BroadcastCancelledAreaList);

      stat = asn1PD_BroadcastCancelledAreaList (pctxt, 
         (BroadcastCancelledAreaList*)pvalue->value.
         u._PWSCancelResponseIEs_id_BroadcastCancelledAreaList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PWSCancelResponseIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSCancelResponseIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSCancelResponseIEs_id_CriticalityDiagnostics");

      pvalue->value.u._PWSCancelResponseIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.u._PWSCancelResponseIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._PWSCancelResponseIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.u._PWSCancelResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PWSCancelResponseIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSCancelResponse_protocolIEs (OSCTXT* pctxt, PWSCancelResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PWSCancelResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PWSCancelResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PWSCancelResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PWSCancelResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSCancelResponse (OSCTXT* pctxt, PWSCancelResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSCancelResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PWSCancelResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSCancelResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PWSRestartIndication_protocolIEs_element (OSCTXT* pctxt, PWSRestartIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PWSRestartIndicationIEs_id_CellIDListForRestart */
   case ASN1V_id_CellIDListForRestart:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_CellIDListForRestart;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_CellIDListForRestart");

      pvalue->value.u._PWSRestartIndicationIEs_id_CellIDListForRestart
          = rtxMemAllocType (pctxt, CellIDListForRestart);

      if (pvalue->value.u._PWSRestartIndicationIEs_id_CellIDListForRestart
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellIDListForRestart ((CellIDListForRestart*)pvalue->value.
         u._PWSRestartIndicationIEs_id_CellIDListForRestart);

      stat = asn1PD_CellIDListForRestart (pctxt, (CellIDListForRestart*)pvalue
         ->value.u._PWSRestartIndicationIEs_id_CellIDListForRestart);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PWSRestartIndicationIEs_id_GlobalRANNodeID */
   case ASN1V_id_GlobalRANNodeID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_GlobalRANNodeID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_GlobalRANNodeID");

      pvalue->value.u._PWSRestartIndicationIEs_id_GlobalRANNodeID
          = rtxMemAllocType (pctxt, GlobalRANNodeID);

      if (pvalue->value.u._PWSRestartIndicationIEs_id_GlobalRANNodeID == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GlobalRANNodeID ((GlobalRANNodeID*)pvalue->value.
         u._PWSRestartIndicationIEs_id_GlobalRANNodeID);

      stat = asn1PD_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.
         u._PWSRestartIndicationIEs_id_GlobalRANNodeID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PWSRestartIndicationIEs_id_TAIListForRestart */
   case ASN1V_id_TAIListForRestart:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_TAIListForRestart;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_TAIListForRestart");

      pvalue->value.u._PWSRestartIndicationIEs_id_TAIListForRestart
          = rtxMemAllocType (pctxt, TAIListForRestart);

      if (pvalue->value.u._PWSRestartIndicationIEs_id_TAIListForRestart
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TAIListForRestart (pvalue->value.
         u._PWSRestartIndicationIEs_id_TAIListForRestart);

      stat = asn1PD_TAIListForRestart (pctxt, pvalue->value.
         u._PWSRestartIndicationIEs_id_TAIListForRestart);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart */
   case ASN1V_id_EmergencyAreaIDListForRestart:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart");

      pvalue->value.u._PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart
          = rtxMemAllocType (pctxt, EmergencyAreaIDListForRestart);

      if (pvalue->value.
         u._PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EmergencyAreaIDListForRestart ((EmergencyAreaIDListForRestart*)
         pvalue->value.
         u._PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart);

      stat = asn1PD_EmergencyAreaIDListForRestart (pctxt, 
         (EmergencyAreaIDListForRestart*)pvalue->value.
         u._PWSRestartIndicationIEs_id_EmergencyAreaIDListForRestart);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PWSRestartIndicationIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSRestartIndication_protocolIEs (OSCTXT* pctxt, PWSRestartIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PWSRestartIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PWSRestartIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PWSRestartIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PWSRestartIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSRestartIndication (OSCTXT* pctxt, PWSRestartIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSRestartIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PWSRestartIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSRestartIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PWSFailureIndication_protocolIEs_element (OSCTXT* pctxt, PWSFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _PWSFailureIndicationIEs_id_PWSFailedCellIDList */
   case ASN1V_id_PWSFailedCellIDList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSFailureIndicationIEs_id_PWSFailedCellIDList;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSFailureIndicationIEs_id_PWSFailedCellIDList");

      pvalue->value.u._PWSFailureIndicationIEs_id_PWSFailedCellIDList
          = rtxMemAllocType (pctxt, PWSFailedCellIDList);

      if (pvalue->value.u._PWSFailureIndicationIEs_id_PWSFailedCellIDList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PWSFailedCellIDList ((PWSFailedCellIDList*)pvalue->value.
         u._PWSFailureIndicationIEs_id_PWSFailedCellIDList);

      stat = asn1PD_PWSFailedCellIDList (pctxt, (PWSFailedCellIDList*)pvalue->
         value.u._PWSFailureIndicationIEs_id_PWSFailedCellIDList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _PWSFailureIndicationIEs_id_GlobalRANNodeID */
   case ASN1V_id_GlobalRANNodeID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_PWSFailureIndicationIEs_id_GlobalRANNodeID;

      RTXCTXTPUSHELEMNAME (pctxt, "_PWSFailureIndicationIEs_id_GlobalRANNodeID");

      pvalue->value.u._PWSFailureIndicationIEs_id_GlobalRANNodeID
          = rtxMemAllocType (pctxt, GlobalRANNodeID);

      if (pvalue->value.u._PWSFailureIndicationIEs_id_GlobalRANNodeID == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GlobalRANNodeID ((GlobalRANNodeID*)pvalue->value.
         u._PWSFailureIndicationIEs_id_GlobalRANNodeID);

      stat = asn1PD_GlobalRANNodeID (pctxt, (GlobalRANNodeID*)pvalue->value.
         u._PWSFailureIndicationIEs_id_GlobalRANNodeID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_PWSFailureIndicationIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSFailureIndication_protocolIEs (OSCTXT* pctxt, PWSFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PWSFailureIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PWSFailureIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PWSFailureIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PWSFailureIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PWSFailureIndication (OSCTXT* pctxt, PWSFailureIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PWSFailureIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_PWSFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PWSFailureIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, DownlinkUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._DownlinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._DownlinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID */
   case ASN1V_id_RoutingID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID");

      pvalue->value.u._DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID
          = rtxMemAllocType (pctxt, RoutingID);

      if (pvalue->value.u._DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RoutingID (pvalue->value.
         u._DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID);

      stat = asn1PD_RoutingID (pctxt, pvalue->value.
         u._DownlinkUEAssociatedNRPPaTransportIEs_id_RoutingID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
   case ASN1V_id_NRPPa_PDU:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

      pvalue->value.u._DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
          = rtxMemAllocType (pctxt, NRPPa_PDU);

      if (pvalue->value.u._DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NRPPa_PDU (pvalue->value.
         u._DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);

      stat = asn1PD_NRPPa_PDU (pctxt, pvalue->value.
         u._DownlinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_DownlinkUEAssociatedNRPPaTransportIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, DownlinkUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkUEAssociatedNRPPaTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkUEAssociatedNRPPaTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkUEAssociatedNRPPaTransport (OSCTXT* pctxt, DownlinkUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, UplinkUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UplinkUEAssociatedNRPPaTransportIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UplinkUEAssociatedNRPPaTransportIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID */
   case ASN1V_id_RoutingID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID");

      pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID
          = rtxMemAllocType (pctxt, RoutingID);

      if (pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RoutingID (pvalue->value.
         u._UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID);

      stat = asn1PD_RoutingID (pctxt, pvalue->value.
         u._UplinkUEAssociatedNRPPaTransportIEs_id_RoutingID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
   case ASN1V_id_NRPPa_PDU:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

      pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
          = rtxMemAllocType (pctxt, NRPPa_PDU);

      if (pvalue->value.u._UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NRPPa_PDU (pvalue->value.
         u._UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);

      stat = asn1PD_NRPPa_PDU (pctxt, pvalue->value.
         u._UplinkUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UplinkUEAssociatedNRPPaTransportIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, UplinkUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkUEAssociatedNRPPaTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkUEAssociatedNRPPaTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkUEAssociatedNRPPaTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkUEAssociatedNRPPaTransport (OSCTXT* pctxt, UplinkUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID */
   case ASN1V_id_RoutingID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID");

      pvalue->value.u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID
          = rtxMemAllocType (pctxt, RoutingID);

      if (pvalue->value.
         u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RoutingID (pvalue->value.
         u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID);

      stat = asn1PD_RoutingID (pctxt, pvalue->value.
         u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
   case ASN1V_id_NRPPa_PDU:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

      pvalue->value.u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
          = rtxMemAllocType (pctxt, NRPPa_PDU);

      if (pvalue->value.
         u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NRPPa_PDU (pvalue->value.
         u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);

      stat = asn1PD_NRPPa_PDU (pctxt, pvalue->value.
         u._DownlinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_DownlinkNonUEAssociatedNRPPaTransportIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, DownlinkNonUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DownlinkNonUEAssociatedNRPPaTransport (OSCTXT* pctxt, DownlinkNonUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DownlinkNonUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DownlinkNonUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DownlinkNonUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element (OSCTXT* pctxt, UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID */
   case ASN1V_id_RoutingID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID");

      pvalue->value.u._UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID
          = rtxMemAllocType (pctxt, RoutingID);

      if (pvalue->value.u._UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RoutingID (pvalue->value.
         u._UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID);

      stat = asn1PD_RoutingID (pctxt, pvalue->value.
         u._UplinkNonUEAssociatedNRPPaTransportIEs_id_RoutingID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU */
   case ASN1V_id_NRPPa_PDU:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU;

      RTXCTXTPUSHELEMNAME (pctxt, "_UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU");

      pvalue->value.u._UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
          = rtxMemAllocType (pctxt, NRPPa_PDU);

      if (pvalue->value.u._UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NRPPa_PDU (pvalue->value.
         u._UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);

      stat = asn1PD_NRPPa_PDU (pctxt, pvalue->value.
         u._UplinkNonUEAssociatedNRPPaTransportIEs_id_NRPPa_PDU);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UplinkNonUEAssociatedNRPPaTransportIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs (OSCTXT* pctxt, UplinkNonUEAssociatedNRPPaTransport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UplinkNonUEAssociatedNRPPaTransport (OSCTXT* pctxt, UplinkNonUEAssociatedNRPPaTransport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkNonUEAssociatedNRPPaTransport");

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UplinkNonUEAssociatedNRPPaTransport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UplinkNonUEAssociatedNRPPaTransport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TraceStart_protocolIEs_element (OSCTXT* pctxt, TraceStart_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _TraceStartIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.t = T_NGAP_PDU_Contents_TraceStartIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_TraceStartIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._TraceStartIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _TraceStartIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.t = T_NGAP_PDU_Contents_TraceStartIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_TraceStartIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._TraceStartIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _TraceStartIEs_id_TraceActivation */
   case ASN1V_id_TraceActivation:
      pvalue->value.t = T_NGAP_PDU_Contents_TraceStartIEs_id_TraceActivation;

      RTXCTXTPUSHELEMNAME (pctxt, "_TraceStartIEs_id_TraceActivation");

      pvalue->value.u._TraceStartIEs_id_TraceActivation
          = rtxMemAllocType (pctxt, TraceActivation);

      if (pvalue->value.u._TraceStartIEs_id_TraceActivation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TraceActivation ((TraceActivation*)pvalue->value.
         u._TraceStartIEs_id_TraceActivation);

      stat = asn1PD_TraceActivation (pctxt, (TraceActivation*)pvalue->value.
         u._TraceStartIEs_id_TraceActivation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_TraceStartIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TraceStart_protocolIEs (OSCTXT* pctxt, TraceStart_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TraceStart_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TraceStart_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TraceStart_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TraceStart_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_TraceStart (OSCTXT* pctxt, TraceStart* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceStart");

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_TraceStart_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceStart: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_TraceFailureIndication_protocolIEs_element (OSCTXT* pctxt, TraceFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._TraceFailureIndicationIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._TraceFailureIndicationIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _TraceFailureIndicationIEs_id_NGRANTraceID */
   case ASN1V_id_NGRANTraceID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_NGRANTraceID;

      RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_NGRANTraceID");

      pvalue->value.u._TraceFailureIndicationIEs_id_NGRANTraceID
          = rtxMemAllocTypeZ (pctxt, NGRANTraceID);

      if (pvalue->value.u._TraceFailureIndicationIEs_id_NGRANTraceID == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_NGRANTraceID (pctxt, (NGRANTraceID*)pvalue->value.
         u._TraceFailureIndicationIEs_id_NGRANTraceID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _TraceFailureIndicationIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_TraceFailureIndicationIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_TraceFailureIndicationIEs_id_Cause");

      pvalue->value.u._TraceFailureIndicationIEs_id_Cause
          = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._TraceFailureIndicationIEs_id_Cause == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.
         u._TraceFailureIndicationIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._TraceFailureIndicationIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_TraceFailureIndicationIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_TraceFailureIndication_protocolIEs (OSCTXT* pctxt, TraceFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      TraceFailureIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, TraceFailureIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TraceFailureIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_TraceFailureIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_TraceFailureIndication (OSCTXT* pctxt, TraceFailureIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceFailureIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_TraceFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_TraceFailureIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_DeactivateTrace_protocolIEs_element (OSCTXT* pctxt, DeactivateTrace_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _DeactivateTraceIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DeactivateTraceIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DeactivateTraceIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._DeactivateTraceIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DeactivateTraceIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DeactivateTraceIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DeactivateTraceIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._DeactivateTraceIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _DeactivateTraceIEs_id_NGRANTraceID */
   case ASN1V_id_NGRANTraceID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_DeactivateTraceIEs_id_NGRANTraceID;

      RTXCTXTPUSHELEMNAME (pctxt, "_DeactivateTraceIEs_id_NGRANTraceID");

      pvalue->value.u._DeactivateTraceIEs_id_NGRANTraceID
          = rtxMemAllocTypeZ (pctxt, NGRANTraceID);

      if (pvalue->value.u._DeactivateTraceIEs_id_NGRANTraceID == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_NGRANTraceID (pctxt, (NGRANTraceID*)pvalue->value.
         u._DeactivateTraceIEs_id_NGRANTraceID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_DeactivateTraceIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_DeactivateTrace_protocolIEs (OSCTXT* pctxt, DeactivateTrace_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      DeactivateTrace_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, DeactivateTrace_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DeactivateTrace_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_DeactivateTrace_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_DeactivateTrace (OSCTXT* pctxt, DeactivateTrace* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DeactivateTrace");

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_DeactivateTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_DeactivateTrace: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_CellTrafficTrace_protocolIEs_element (OSCTXT* pctxt, CellTrafficTrace_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _CellTrafficTraceIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._CellTrafficTraceIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _CellTrafficTraceIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._CellTrafficTraceIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _CellTrafficTraceIEs_id_NGRANTraceID */
   case ASN1V_id_NGRANTraceID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_NGRANTraceID;

      RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_NGRANTraceID");

      pvalue->value.u._CellTrafficTraceIEs_id_NGRANTraceID
          = rtxMemAllocTypeZ (pctxt, NGRANTraceID);

      if (pvalue->value.u._CellTrafficTraceIEs_id_NGRANTraceID == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1PD_NGRANTraceID (pctxt, (NGRANTraceID*)pvalue->value.
         u._CellTrafficTraceIEs_id_NGRANTraceID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _CellTrafficTraceIEs_id_NGRAN_CGI */
   case ASN1V_id_NGRAN_CGI:
      pvalue->value.t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_NGRAN_CGI;

      RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_NGRAN_CGI");

      pvalue->value.u._CellTrafficTraceIEs_id_NGRAN_CGI
          = rtxMemAllocType (pctxt, NGRAN_CGI);

      if (pvalue->value.u._CellTrafficTraceIEs_id_NGRAN_CGI == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NGRAN_CGI ((NGRAN_CGI*)pvalue->value.
         u._CellTrafficTraceIEs_id_NGRAN_CGI);

      stat = asn1PD_NGRAN_CGI (pctxt, (NGRAN_CGI*)pvalue->value.
         u._CellTrafficTraceIEs_id_NGRAN_CGI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress */
   case ASN1V_id_TraceCollectionEntityIPAddress:
      pvalue->value.
         t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress;

      RTXCTXTPUSHELEMNAME (pctxt, "_CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress");

      pvalue->value.u._CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress
          = rtxMemAllocType (pctxt, TransportLayerAddress);

      if (pvalue->value.
         u._CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TransportLayerAddress (pvalue->value.
         u._CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress);

      stat = asn1PD_TransportLayerAddress (pctxt, pvalue->value.
         u._CellTrafficTraceIEs_id_TraceCollectionEntityIPAddress);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_CellTrafficTraceIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_CellTrafficTrace_protocolIEs (OSCTXT* pctxt, CellTrafficTrace_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      CellTrafficTrace_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, CellTrafficTrace_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CellTrafficTrace_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_CellTrafficTrace_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_CellTrafficTrace (OSCTXT* pctxt, CellTrafficTrace* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CellTrafficTrace");

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_CellTrafficTrace_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_CellTrafficTrace: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LocationReportingControl_protocolIEs_element (OSCTXT* pctxt, LocationReportingControl_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _LocationReportingControlIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportingControlIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingControlIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._LocationReportingControlIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _LocationReportingControlIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportingControlIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingControlIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._LocationReportingControlIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _LocationReportingControlIEs_id_LocationReportingRequestType */
   case ASN1V_id_LocationReportingRequestType:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportingControlIEs_id_LocationReportingRequestType;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingControlIEs_id_LocationReportingRequestType");

      pvalue->value.
         u._LocationReportingControlIEs_id_LocationReportingRequestType
          = rtxMemAllocType (pctxt, LocationReportingRequestType);

      if (pvalue->value.
         u._LocationReportingControlIEs_id_LocationReportingRequestType
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReportingRequestType ((LocationReportingRequestType*)
         pvalue->value.
         u._LocationReportingControlIEs_id_LocationReportingRequestType);

      stat = asn1PD_LocationReportingRequestType (pctxt, 
         (LocationReportingRequestType*)pvalue->value.
         u._LocationReportingControlIEs_id_LocationReportingRequestType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_LocationReportingControlIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReportingControl_protocolIEs (OSCTXT* pctxt, LocationReportingControl_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LocationReportingControl_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, LocationReportingControl_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReportingControl_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LocationReportingControl_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReportingControl (OSCTXT* pctxt, LocationReportingControl* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingControl");

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_LocationReportingControl_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingControl: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LocationReportingFailureIndication_protocolIEs_element (OSCTXT* pctxt, LocationReportingFailureIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._LocationReportingFailureIndicationIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._LocationReportingFailureIndicationIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _LocationReportingFailureIndicationIEs_id_Cause */
   case ASN1V_id_Cause:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_id_Cause;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportingFailureIndicationIEs_id_Cause");

      pvalue->value.u._LocationReportingFailureIndicationIEs_id_Cause
          = rtxMemAllocType (pctxt, Cause);

      if (pvalue->value.u._LocationReportingFailureIndicationIEs_id_Cause
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Cause ((Cause*)pvalue->value.
         u._LocationReportingFailureIndicationIEs_id_Cause);

      stat = asn1PD_Cause (pctxt, (Cause*)pvalue->value.
         u._LocationReportingFailureIndicationIEs_id_Cause);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_LocationReportingFailureIndicationIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReportingFailureIndication_protocolIEs (OSCTXT* pctxt, LocationReportingFailureIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LocationReportingFailureIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, LocationReportingFailureIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReportingFailureIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LocationReportingFailureIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReportingFailureIndication (OSCTXT* pctxt, LocationReportingFailureIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingFailureIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_LocationReportingFailureIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReportingFailureIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_LocationReport_protocolIEs_element (OSCTXT* pctxt, LocationReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _LocationReportIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._LocationReportIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _LocationReportIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._LocationReportIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _LocationReportIEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportIEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_UserLocationInformation");

      pvalue->value.u._LocationReportIEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.u._LocationReportIEs_id_UserLocationInformation
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._LocationReportIEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.u._LocationReportIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _LocationReportIEs_id_UEPresenceInAreaOfInterestList */
   case ASN1V_id_UEPresenceInAreaOfInterestList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportIEs_id_UEPresenceInAreaOfInterestList;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_UEPresenceInAreaOfInterestList");

      pvalue->value.u._LocationReportIEs_id_UEPresenceInAreaOfInterestList
          = rtxMemAllocType (pctxt, UEPresenceInAreaOfInterestList);

      if (pvalue->value.u._LocationReportIEs_id_UEPresenceInAreaOfInterestList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UEPresenceInAreaOfInterestList (pvalue->value.
         u._LocationReportIEs_id_UEPresenceInAreaOfInterestList);

      stat = asn1PD_UEPresenceInAreaOfInterestList (pctxt, pvalue->value.
         u._LocationReportIEs_id_UEPresenceInAreaOfInterestList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _LocationReportIEs_id_LocationReportingRequestType */
   case ASN1V_id_LocationReportingRequestType:
      pvalue->value.
         t = T_NGAP_PDU_Contents_LocationReportIEs_id_LocationReportingRequestType;

      RTXCTXTPUSHELEMNAME (pctxt, "_LocationReportIEs_id_LocationReportingRequestType");

      pvalue->value.u._LocationReportIEs_id_LocationReportingRequestType
          = rtxMemAllocType (pctxt, LocationReportingRequestType);

      if (pvalue->value.u._LocationReportIEs_id_LocationReportingRequestType
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReportingRequestType ((LocationReportingRequestType*)
         pvalue->value.u._LocationReportIEs_id_LocationReportingRequestType);

      stat = asn1PD_LocationReportingRequestType (pctxt, 
         (LocationReportingRequestType*)pvalue->value.
         u._LocationReportIEs_id_LocationReportingRequestType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_LocationReportIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReport_protocolIEs (OSCTXT* pctxt, LocationReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      LocationReport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, LocationReport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LocationReport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_LocationReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_LocationReport (OSCTXT* pctxt, LocationReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReport");

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_LocationReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_LocationReport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UETNLABindingReleaseRequest_protocolIEs_element (OSCTXT* pctxt, UETNLABindingReleaseRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UETNLABindingReleaseRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UETNLABindingReleaseRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UETNLABindingReleaseRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UETNLABindingReleaseRequest_protocolIEs (OSCTXT* pctxt, UETNLABindingReleaseRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UETNLABindingReleaseRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UETNLABindingReleaseRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UETNLABindingReleaseRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UETNLABindingReleaseRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UETNLABindingReleaseRequest (OSCTXT* pctxt, UETNLABindingReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UETNLABindingReleaseRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UETNLABindingReleaseRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UETNLABindingReleaseRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityInfoIndication_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityInfoIndication_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UERadioCapabilityInfoIndicationIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UERadioCapabilityInfoIndicationIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UERadioCapabilityInfoIndicationIEs_id_UERadioCapability */
   case ASN1V_id_UERadioCapability:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_UERadioCapability;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_UERadioCapability");

      pvalue->value.u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability
          = rtxMemAllocType (pctxt, UERadioCapability);

      if (pvalue->value.
         u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapability (pvalue->value.
         u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability);

      stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
         u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapability);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging */
   case ASN1V_id_UERadioCapabilityForPaging:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging");

      pvalue->value.
         u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging
          = rtxMemAllocType (pctxt, UERadioCapabilityForPaging);

      if (pvalue->value.
         u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityForPaging ((UERadioCapabilityForPaging*)pvalue
         ->value.
         u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging);

      stat = asn1PD_UERadioCapabilityForPaging (pctxt, 
         (UERadioCapabilityForPaging*)pvalue->value.
         u._UERadioCapabilityInfoIndicationIEs_id_UERadioCapabilityForPaging);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UERadioCapabilityInfoIndicationIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityInfoIndication_protocolIEs (OSCTXT* pctxt, UERadioCapabilityInfoIndication_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UERadioCapabilityInfoIndication_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UERadioCapabilityInfoIndication_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityInfoIndication_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UERadioCapabilityInfoIndication_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityInfoIndication (OSCTXT* pctxt, UERadioCapabilityInfoIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityInfoIndication");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UERadioCapabilityInfoIndication_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityInfoIndication: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckRequest_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityCheckRequest_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UERadioCapabilityCheckRequestIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UERadioCapabilityCheckRequestIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UERadioCapabilityCheckRequestIEs_id_UERadioCapability */
   case ASN1V_id_UERadioCapability:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_id_UERadioCapability;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckRequestIEs_id_UERadioCapability");

      pvalue->value.u._UERadioCapabilityCheckRequestIEs_id_UERadioCapability
          = rtxMemAllocType (pctxt, UERadioCapability);

      if (pvalue->value.
         u._UERadioCapabilityCheckRequestIEs_id_UERadioCapability == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapability (pvalue->value.
         u._UERadioCapabilityCheckRequestIEs_id_UERadioCapability);

      stat = asn1PD_UERadioCapability (pctxt, pvalue->value.
         u._UERadioCapabilityCheckRequestIEs_id_UERadioCapability);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UERadioCapabilityCheckRequestIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckRequest_protocolIEs (OSCTXT* pctxt, UERadioCapabilityCheckRequest_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UERadioCapabilityCheckRequest_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UERadioCapabilityCheckRequest_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityCheckRequest_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UERadioCapabilityCheckRequest_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckRequest (OSCTXT* pctxt, UERadioCapabilityCheckRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityCheckRequest");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UERadioCapabilityCheckRequest_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckRequest: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckResponse_protocolIEs_element (OSCTXT* pctxt, UERadioCapabilityCheckResponse_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UERadioCapabilityCheckResponseIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._UERadioCapabilityCheckResponseIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator */
   case ASN1V_id_IMSVoiceSupportIndicator:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator");

      stat = asn1PD_IMSVoiceSupportIndicator (pctxt, &pvalue->value.
         u._UERadioCapabilityCheckResponseIEs_id_IMSVoiceSupportIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics */
   case ASN1V_id_CriticalityDiagnostics:
      pvalue->value.
         t = T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics;

      RTXCTXTPUSHELEMNAME (pctxt, "_UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics");

      pvalue->value.
         u._UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics
          = rtxMemAllocType (pctxt, CriticalityDiagnostics);

      if (pvalue->value.
         u._UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics ((CriticalityDiagnostics*)pvalue->value.
         u._UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics (pctxt, (CriticalityDiagnostics*)
         pvalue->value.
         u._UERadioCapabilityCheckResponseIEs_id_CriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_UERadioCapabilityCheckResponseIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckResponse_protocolIEs (OSCTXT* pctxt, UERadioCapabilityCheckResponse_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      UERadioCapabilityCheckResponse_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, UERadioCapabilityCheckResponse_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UERadioCapabilityCheckResponse_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_UERadioCapabilityCheckResponse_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_UERadioCapabilityCheckResponse (OSCTXT* pctxt, UERadioCapabilityCheckResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UERadioCapabilityCheckResponse");

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_UERadioCapabilityCheckResponse_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_UERadioCapabilityCheckResponse: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_PrivateMessage_privateIEs_element (OSCTXT* pctxt, PrivateMessage_privateIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage_privateIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_PrivateIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage_privateIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_PrivateMessage_privateIEs (OSCTXT* pctxt, PrivateMessage_privateIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage_privateIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      PrivateMessage_privateIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, PrivateMessage_privateIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PrivateMessage_privateIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_PrivateMessage_privateIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage_privateIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_PrivateMessage (OSCTXT* pctxt, PrivateMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateMessage");

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode privateIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "privateIEs");

   stat = asn1PD_PrivateMessage_privateIEs (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_PrivateMessage: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_SecondaryRATDataUsageReport_protocolIEs_element (OSCTXT* pctxt, SecondaryRATDataUsageReport_protocolIEs_element* pvalue)
{
   int stat = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport_protocolIEs_element: start\n");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   { OSUINT32 openTypeLen;
   size_t bitStartOffset, bitLength;

   stat = pd_UnconsLength (pctxt, &openTypeLen);
   if (stat < 0) return LOG_RTERR (pctxt, stat);
   else if (stat == RT_OK_FRAG) {
      rtxErrAddStrParm (pctxt, "open type with fragmented length (use -perindef)");
      return LOG_RTERRNEW (pctxt, RTERR_NOTSUPP);
   }
   bitStartOffset = PU_GETCTXTBITOFFSET (pctxt);
   bitLength = openTypeLen * 8;

   switch (pvalue->id) {
   /* _SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID */
   case ASN1V_id_AMF_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID");

      stat = asn1PD_AMF_UE_NGAP_ID (pctxt, &pvalue->value.
         u._SecondaryRATDataUsageReportIEs_id_AMF_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID */
   case ASN1V_id_RAN_UE_NGAP_ID:
      pvalue->value.
         t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID;

      RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID");

      stat = asn1PD_RAN_UE_NGAP_ID (pctxt, &pvalue->value.
         u._SecondaryRATDataUsageReportIEs_id_RAN_UE_NGAP_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList */
   case ASN1V_id_PDUSessionResourceSecondaryRATUsageList:
      pvalue->value.
         t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList;

      RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList");

      pvalue->value.
         u._SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList
          = rtxMemAllocType (pctxt, PDUSessionResourceSecondaryRATUsageList);

      if (pvalue->value.
         u._SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList
          == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PDUSessionResourceSecondaryRATUsageList (pvalue->value.
         u._SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList
         );

      stat = asn1PD_PDUSessionResourceSecondaryRATUsageList (pctxt, pvalue->
         value.
         u._SecondaryRATDataUsageReportIEs_id_PDUSessionResourceSecondaryRATUsageList
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _SecondaryRATDataUsageReportIEs_id_HandoverFlag */
   case ASN1V_id_HandoverFlag:
      pvalue->value.
         t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_HandoverFlag;

      RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_HandoverFlag");

      stat = asn1PD_HandoverFlag (pctxt, &pvalue->value.
         u._SecondaryRATDataUsageReportIEs_id_HandoverFlag);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   /* _SecondaryRATDataUsageReportIEs_id_UserLocationInformation */
   case ASN1V_id_UserLocationInformation:
      pvalue->value.
         t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_id_UserLocationInformation;

      RTXCTXTPUSHELEMNAME (pctxt, "_SecondaryRATDataUsageReportIEs_id_UserLocationInformation");

      pvalue->value.
         u._SecondaryRATDataUsageReportIEs_id_UserLocationInformation
          = rtxMemAllocType (pctxt, UserLocationInformation);

      if (pvalue->value.
         u._SecondaryRATDataUsageReportIEs_id_UserLocationInformation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UserLocationInformation ((UserLocationInformation*)pvalue->value
         .u._SecondaryRATDataUsageReportIEs_id_UserLocationInformation);

      stat = asn1PD_UserLocationInformation (pctxt, (UserLocationInformation*)
         pvalue->value.
         u._SecondaryRATDataUsageReportIEs_id_UserLocationInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      break;

   default:
      pvalue->value.t = T_NGAP_PDU_Contents_SecondaryRATDataUsageReportIEs_UNDEF_;
      pvalue->value.u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
      if (0 == pvalue->value.u.extElem1)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      { OSOCTET* pdata = (OSOCTET*) rtxMemAlloc (pctxt, openTypeLen);
      if (0 == pdata) return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = rtxDecBitsToByteArray (pctxt, pdata, openTypeLen, openTypeLen*8);
      if (stat != 0) {
         rtxMemFreePtr (pctxt, pdata);
         rtxMemFreePtr (pctxt, pvalue->value.u.extElem1);
         return LOG_RTERR (pctxt, stat);
      }
      pvalue->value.u.extElem1->numocts = openTypeLen;
      pvalue->value.u.extElem1->data = pdata;
      }
      break;
   }

   {
   size_t bitEndOffset = PU_GETCTXTBITOFFSET (pctxt);
   size_t bitsConsumed = bitEndOffset - bitStartOffset;
   if (bitsConsumed < bitLength) {
      stat = pd_moveBitCursor (pctxt, (int)(bitLength - bitsConsumed));
   }
   else stat = (bitsConsumed > bitLength) ? ASN_E_INVLEN : 0;
   }}
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport_protocolIEs_element: end\n");

   return (stat);
}

EXTERN int asn1PD_SecondaryRATDataUsageReport_protocolIEs (OSCTXT* pctxt, SecondaryRATDataUsageReport_protocolIEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport_protocolIEs: start\n");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      SecondaryRATDataUsageReport_protocolIEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, SecondaryRATDataUsageReport_protocolIEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SecondaryRATDataUsageReport_protocolIEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_SecondaryRATDataUsageReport_protocolIEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport_protocolIEs: end\n");

   return (stat);
}

EXTERN int asn1PD_SecondaryRATDataUsageReport (OSCTXT* pctxt, SecondaryRATDataUsageReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SecondaryRATDataUsageReport");

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport: start\n");

   /* extension bit */

   PU_NEWFIELD (pctxt, "extension marker");

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   PU_SETBITCOUNT (pctxt);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_SecondaryRATDataUsageReport_protocolIEs (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      PU_NEWFIELD (pctxt, "ext opt bits len");

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      PU_SETBITCOUNT (pctxt);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      PU_NEWFIELD (pctxt, "ext opt bit mask");

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      PU_SETBITCOUNT (pctxt);

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            /* set ext elem name for trace */
            switch (i_) {
               case 0: RTXCTXTPUSHELEMNAME (pctxt, "extElem1");
               break;
               default:;
            }

            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTDIAGSTRM2 (pctxt,"asn1PD_SecondaryRATDataUsageReport: end\n");

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

