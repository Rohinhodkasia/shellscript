/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.4.1.1, Date: 02-Jun-2020.
 */
#include "TS24301IES.h"
#include "TS24008IES.h"
#include "rtxsrc/rtxCommon.h"
#include "rtxsrc/rtxDiagBitTrace.h"

/*
 * Randomly generated test file: seed = 1591119629
 */
TS24301IE_AuthRespParam* asn1Test_TS24301IE_AuthRespParam (OSCTXT* pctxt)
{
   TS24301IE_AuthRespParam* pvalue = rtxMemAllocType (pctxt, TS24301IE_AuthRespParam);
   asn1Init_TS24301IE_AuthRespParam (pvalue);

   {
      static const OSOCTET testdata[] = { 
      0x82, 0x23, 0x3f, 0x71 };
      pvalue->numocts = 4;
      OSCRTLSAFEMEMCPY ((void*)pvalue->data, 4, testdata, 4);
   }
   return (pvalue);
}

TS24301IE_EMMCause* asn1Test_TS24301IE_EMMCause (OSCTXT* pctxt)
{
   TS24301IE_EMMCause* pvalue = rtxMemAllocType (pctxt, TS24301IE_EMMCause);

   *pvalue = TS24301IE_EMMCause_imsiUnkInHSS;
   return (pvalue);
}

TS24301IE_ESMMessageContainer*
    asn1Test_TS24301IE_ESMMessageContainer (OSCTXT* pctxt)
{
   TS24301IE_ESMMessageContainer* pvalue = rtxMemAllocType (pctxt, TS24301IE_ESMMessageContainer);
   asn1Init_TS24301IE_ESMMessageContainer (pvalue);

   pvalue->numocts = 0;
   pvalue->data = (OSOCTET*) 0;
   return (pvalue);
}

TS24301IE_NASMessageContainer*
    asn1Test_TS24301IE_NASMessageContainer (OSCTXT* pctxt)
{
   TS24301IE_NASMessageContainer* pvalue = rtxMemAllocType (pctxt, TS24301IE_NASMessageContainer);
   asn1Init_TS24301IE_NASMessageContainer (pvalue);

   {
      static const OSOCTET testdata[] = { 
      0x56, 0xfd };
      pvalue->numocts = 2;
      OSCRTLSAFEMEMCPY ((void*)pvalue->data, 2, testdata, 2);
   }
   return (pvalue);
}

TS24301IE_Nonce* asn1Test_TS24301IE_Nonce (OSCTXT* pctxt)
{
   TS24301IE_Nonce* pvalue = rtxMemAllocType (pctxt, TS24301IE_Nonce);

   {
      static const OSOCTET testdata[] = { 
      0xfd, 0xf9, 0xe0, 0x6d };
      OSCRTLSAFEMEMCPY ((void*)pvalue->data, 4, testdata, 4);
   }
   return (pvalue);
}

TS24301IE_ServiceType* asn1Test_TS24301IE_ServiceType (OSCTXT* pctxt)
{
   TS24301IE_ServiceType* pvalue = rtxMemAllocType (pctxt, TS24301IE_ServiceType);

   *pvalue = 9;
   return (pvalue);
}

TS24301IE_ShortMAC* asn1Test_TS24301IE_ShortMAC (OSCTXT* pctxt)
{
   TS24301IE_ShortMAC* pvalue = rtxMemAllocType (pctxt, TS24301IE_ShortMAC);

   {
      static const OSOCTET testdata[] = { 
      0x34, 0xfa };
      OSCRTLSAFEMEMCPY ((void*)pvalue->data, 2, testdata, 2);
   }
   return (pvalue);
}

TS24301IE_TrackingAreaCode* asn1Test_TS24301IE_TrackingAreaCode (OSCTXT* pctxt)
{
   TS24301IE_TrackingAreaCode* pvalue = rtxMemAllocType (pctxt, TS24301IE_TrackingAreaCode);

   {
      static const OSOCTET testdata[] = { 
      0x1f, 0x66 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->data, 2, testdata, 2);
   }
   return (pvalue);
}

TS24301IE_SSCode* asn1Test_TS24301IE_SSCode (OSCTXT* pctxt)
{
   TS24301IE_SSCode* pvalue = rtxMemAllocType (pctxt, TS24301IE_SSCode);

   *pvalue = 218;
   return (pvalue);
}

TS24301IE_LCSIndicator* asn1Test_TS24301IE_LCSIndicator (OSCTXT* pctxt)
{
   TS24301IE_LCSIndicator* pvalue = rtxMemAllocType (pctxt, TS24301IE_LCSIndicator);

   *pvalue = 109;
   return (pvalue);
}

TS24301IE_LCSClientIdentity*
    asn1Test_TS24301IE_LCSClientIdentity (OSCTXT* pctxt)
{
   TS24301IE_LCSClientIdentity* pvalue = rtxMemAllocType (pctxt, TS24301IE_LCSClientIdentity);
   asn1Init_TS24301IE_LCSClientIdentity (pvalue);

   {
      static const OSOCTET testdata[] = { 
      0xeb };
      pvalue->numocts = 1;
      OSCRTLSAFEMEMCPY ((void*)pvalue->data, 1, testdata, 1);
   }
   return (pvalue);
}

TS24301IE_GenMsgContainerType*
    asn1Test_TS24301IE_GenMsgContainerType (OSCTXT* pctxt)
{
   TS24301IE_GenMsgContainerType* pvalue = rtxMemAllocType (pctxt, TS24301IE_GenMsgContainerType);

   *pvalue = TS24301IE_GenMsgContainerType_lppMsgCont;
   return (pvalue);
}

TS24301IE_GenMessageContainer*
    asn1Test_TS24301IE_GenMessageContainer (OSCTXT* pctxt)
{
   TS24301IE_GenMessageContainer* pvalue = rtxMemAllocType (pctxt, TS24301IE_GenMessageContainer);
   asn1Init_TS24301IE_GenMessageContainer (pvalue);

   pvalue->numocts = 0;
   pvalue->data = (OSOCTET*) 0;
   return (pvalue);
}

TS24301IE_InformationType* asn1Test_TS24301IE_InformationType (OSCTXT* pctxt)
{
   TS24301IE_InformationType* pvalue = rtxMemAllocType (pctxt, TS24301IE_InformationType);

   *pvalue = TS24301IE_InformationType_itUEPagingProbInfo;
   return (pvalue);
}

TS24301IE_ESMCause* asn1Test_TS24301IE_ESMCause (OSCTXT* pctxt)
{
   TS24301IE_ESMCause* pvalue = rtxMemAllocType (pctxt, TS24301IE_ESMCause);

   *pvalue = TS24301IE_ESMCause_operDeterBarring;
   return (pvalue);
}

TS24301IE_LinkedEPSBearerIdent*
    asn1Test_TS24301IE_LinkedEPSBearerIdent (OSCTXT* pctxt)
{
   TS24301IE_LinkedEPSBearerIdent* pvalue = rtxMemAllocType (pctxt, TS24301IE_LinkedEPSBearerIdent);

   *pvalue = 1;
   return (pvalue);
}

TS24301IE_PDNTypeValue* asn1Test_TS24301IE_PDNTypeValue (OSCTXT* pctxt)
{
   TS24301IE_PDNTypeValue* pvalue = rtxMemAllocType (pctxt, TS24301IE_PDNTypeValue);

   *pvalue = TS24301IE_PDNTypeValue_ipv4;
   return (pvalue);
}

TS24301IE_RemoteUEAddrType* asn1Test_TS24301IE_RemoteUEAddrType (OSCTXT* pctxt)
{
   TS24301IE_RemoteUEAddrType* pvalue = rtxMemAllocType (pctxt, TS24301IE_RemoteUEAddrType);

   *pvalue = TS24301IE_RemoteUEAddrType_remUENoIp;
   return (pvalue);
}

TS24301IE_ServPLMNRateCtrl* asn1Test_TS24301IE_ServPLMNRateCtrl (OSCTXT* pctxt)
{
   TS24301IE_ServPLMNRateCtrl* pvalue = rtxMemAllocType (pctxt, TS24301IE_ServPLMNRateCtrl);

   {
      static const OSOCTET testdata[] = { 
      0x24, 0xcb };
      OSCRTLSAFEMEMCPY ((void*)pvalue->data, 2, testdata, 2);
   }
   return (pvalue);
}

TS24301IE_EPSBearerContextStatus*
    asn1Test_TS24301IE_EPSBearerContextStatus (OSCTXT* pctxt)
{
   TS24301IE_EPSBearerContextStatus* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSBearerContextStatus);
   asn1Init_TS24301IE_EPSBearerContextStatus (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->ebi7 = 1;

   pvalue->ebi6 = 1;

   pvalue->ebi5 = 1;

   pvalue->ebi4 = 0;

   pvalue->ebi3 = 0;

   pvalue->ebi2 = 1;

   pvalue->ebi1 = 1;

   pvalue->ebi0 = 0;

   pvalue->ebi15 = 0;

   pvalue->ebi14 = 0;

   pvalue->ebi13 = 1;

   pvalue->ebi12 = 1;

   pvalue->ebi11 = 0;

   pvalue->ebi10 = 0;

   pvalue->ebi9 = 0;

   pvalue->ebi8 = 1;
   return (pvalue);
}

TS24301IE_NASSecParamsFromEUTRA*
    asn1Test_TS24301IE_NASSecParamsFromEUTRA (OSCTXT* pctxt)
{
   TS24301IE_NASSecParamsFromEUTRA* pvalue = rtxMemAllocType (pctxt, TS24301IE_NASSecParamsFromEUTRA);
   asn1Init_TS24301IE_NASSecParamsFromEUTRA (pvalue);

   pvalue->spare = 11;

   pvalue->dlNASCount = 6;
   return (pvalue);
}

TS24301IE_NASSecParamsToEUTRA*
    asn1Test_TS24301IE_NASSecParamsToEUTRA (OSCTXT* pctxt)
{
   TS24301IE_NASSecParamsToEUTRA* pvalue = rtxMemAllocType (pctxt, TS24301IE_NASSecParamsToEUTRA);
   asn1Init_TS24301IE_NASSecParamsToEUTRA (pvalue);

   {
      static const OSOCTET testdata[] = { 
      0x86, 0xe1, 0x87, 0x3a };
      OSCRTLSAFEMEMCPY ((void*)pvalue->nonceMMEValue, 4, testdata, 4);
   }

   pvalue->spare1 = 0;

   pvalue->typeOfCiphAlg = 4;

   pvalue->spare2 = 0;

   pvalue->typeOfProtAlg = 3;

   pvalue->spare3 = 13;

   pvalue->tsc = 1;

   pvalue->nasKeySetIdent = 1;
   return (pvalue);
}

TS24301IE_AddnUpdateResult* asn1Test_TS24301IE_AddnUpdateResult (OSCTXT* pctxt)
{
   TS24301IE_AddnUpdateResult* pvalue = rtxMemAllocType (pctxt, TS24301IE_AddnUpdateResult);
   asn1Init_TS24301IE_AddnUpdateResult (pvalue);

   pvalue->spare = 1;

   pvalue->value = TS24301IE_AddnUpdateResult_value_noInfo;
   return (pvalue);
}

TS24301IE_AddnUpdateType* asn1Test_TS24301IE_AddnUpdateType (OSCTXT* pctxt)
{
   TS24301IE_AddnUpdateType* pvalue = rtxMemAllocType (pctxt, TS24301IE_AddnUpdateType);

   pvalue->pnb_CIoT = TS24301IE_AddnUpdateType_pnb_CIoT_noAddInfo;

   pvalue->saf = 0;

   pvalue->autv = 0;
   return (pvalue);
}

TS24301IE_SMSServicesStatus*
    asn1Test_TS24301IE_SMSServicesStatus (OSCTXT* pctxt)
{
   TS24301IE_SMSServicesStatus* pvalue = rtxMemAllocType (pctxt, TS24301IE_SMSServicesStatus);
   asn1Init_TS24301IE_SMSServicesStatus (pvalue);

   pvalue->spare = 0;

   pvalue->value = 6;
   return (pvalue);
}

TS24301IE_CSFBResponse* asn1Test_TS24301IE_CSFBResponse (OSCTXT* pctxt)
{
   TS24301IE_CSFBResponse* pvalue = rtxMemAllocType (pctxt, TS24301IE_CSFBResponse);
   asn1Init_TS24301IE_CSFBResponse (pvalue);

   pvalue->spare = 0;

   pvalue->value = 5;
   return (pvalue);
}

TS24301IE_DetachType* asn1Test_TS24301IE_DetachType (OSCTXT* pctxt)
{
   TS24301IE_DetachType* pvalue = rtxMemAllocType (pctxt, TS24301IE_DetachType);

   pvalue->switchOff = 0;

   pvalue->typeOfDetach = 0;
   return (pvalue);
}

TS24301IE_EPSAttachResult* asn1Test_TS24301IE_EPSAttachResult (OSCTXT* pctxt)
{
   TS24301IE_EPSAttachResult* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSAttachResult);
   asn1Init_TS24301IE_EPSAttachResult (pvalue);

   pvalue->spare = 0;

   pvalue->result = 1;
   return (pvalue);
}

TS24301IE_EPSAttachType* asn1Test_TS24301IE_EPSAttachType (OSCTXT* pctxt)
{
   TS24301IE_EPSAttachType* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSAttachType);
   asn1Init_TS24301IE_EPSAttachType (pvalue);

   pvalue->spare = 0;

   pvalue->value = 3;
   return (pvalue);
}

TS24301IE_EPSMobileIdentity_GUTI*
    asn1Test_TS24301IE_EPSMobileIdentity_GUTI (OSCTXT* pctxt)
{
   TS24301IE_EPSMobileIdentity_GUTI* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSMobileIdentity_GUTI);
   asn1Init_TS24301IE_EPSMobileIdentity_GUTI (pvalue);

   rtxStrncpy (pvalue->mcc_mnc.mcc, 4, "724", 3);
   rtxStrncpy (pvalue->mcc_mnc.mnc, 4, "05", 3);

   {
      static const OSOCTET testdata[] = { 
      0x26, 0x64 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->mmeGroupID, 2, testdata, 2);
   }

   pvalue->mmeCode = 124;

   {
      static const OSOCTET testdata[] = { 
      0xe3, 0x8c, 0x73, 0x78 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->tmsi, 4, testdata, 4);
   }
   return (pvalue);
}

TS24301IE_EPSMobileIdentity*
    asn1Test_TS24301IE_EPSMobileIdentity (OSCTXT* pctxt)
{
   TS24301IE_EPSMobileIdentity* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSMobileIdentity);
   asn1Init_TS24301IE_EPSMobileIdentity (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->filler = 5;

   pvalue->oddEvenInd = 1;

   pvalue->typeOfIdent = TS24301IE_EPSMobileIdentity_typeOfIdent_imsi;

   switch (pvalue->typeOfIdent) {
      /* guti */
      case 6:

         rtxStrncpy (pvalue->content.u.guti.mcc_mnc.mcc, 4, "250", 3);
         rtxStrncpy (pvalue->content.u.guti.mcc_mnc.mnc, 4, "12", 3);

         {
            static const OSOCTET testdata[] = { 
            0x38, 0x49 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->content.u.guti.mmeGroupID, 2, testdata, 2);
         }

         pvalue->content.u.guti.mmeCode = 14;

         {
            static const OSOCTET testdata[] = { 
            0xf2, 0xa5, 0x35, 0x94 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->content.u.guti.tmsi, 4, testdata, 4);
         }
         break;

      /* imsi */
      case 1:
         rtxStrncpy (pvalue->content.u.imsi, sizeof(pvalue->content.u.imsi), "61001123456789", 15);
         break;

      /* imei */
      case 3:
         OSCRTLSTRNCPY_S (pvalue->content.u.imei, 16, "636794106859037", 16);
         break;

      default: break;
   }
   return (pvalue);
}

TS24301IE_EPSNetworkFeatureSupport*
    asn1Test_TS24301IE_EPSNetworkFeatureSupport (OSCTXT* pctxt)
{
   TS24301IE_EPSNetworkFeatureSupport* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSNetworkFeatureSupport);
   asn1Init_TS24301IE_EPSNetworkFeatureSupport (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->cpCIoT = 1;

   pvalue->erNoPDN = 1;

   pvalue->esr = 0;

   pvalue->csLCS = 2;

   pvalue->epcLCS = 1;

   pvalue->emcBS = 1;

   pvalue->imsVoPS = 1;

   pvalue->m.octet4Present = 1;

   pvalue->octet4.sigEPSBC = 1;

   pvalue->octet4.iwkN26 = 1;

   pvalue->octet4.rDCNR = 1;

   pvalue->octet4.rEC = 0;

   pvalue->octet4.ePCO = 1;

   pvalue->octet4.hcCpCIoT = 1;

   pvalue->octet4.s1DT = 1;

   pvalue->octet4.upCIot = 1;
   return (pvalue);
}

TS24301IE_EPSUpdateResult* asn1Test_TS24301IE_EPSUpdateResult (OSCTXT* pctxt)
{
   TS24301IE_EPSUpdateResult* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSUpdateResult);
   asn1Init_TS24301IE_EPSUpdateResult (pvalue);

   pvalue->spare = 0;

   pvalue->result = 1;
   return (pvalue);
}

TS24301IE_EPSUpdateType* asn1Test_TS24301IE_EPSUpdateType (OSCTXT* pctxt)
{
   TS24301IE_EPSUpdateType* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSUpdateType);

   pvalue->active = 1;

   pvalue->value = 1;
   return (pvalue);
}

TS24301IE_KSIAndSequenceNumber*
    asn1Test_TS24301IE_KSIAndSequenceNumber (OSCTXT* pctxt)
{
   TS24301IE_KSIAndSequenceNumber* pvalue = rtxMemAllocType (pctxt, TS24301IE_KSIAndSequenceNumber);

   pvalue->ksi = 1;

   pvalue->seqNo = 5;
   return (pvalue);
}

TS24301IE_NASKeySetIdentifier*
    asn1Test_TS24301IE_NASKeySetIdentifier (OSCTXT* pctxt)
{
   TS24301IE_NASKeySetIdentifier* pvalue = rtxMemAllocType (pctxt, TS24301IE_NASKeySetIdentifier);

   pvalue->tsc = 1;

   pvalue->ident = 1;
   return (pvalue);
}

TS24301IE_NASSecurityAlgorithms*
    asn1Test_TS24301IE_NASSecurityAlgorithms (OSCTXT* pctxt)
{
   TS24301IE_NASSecurityAlgorithms* pvalue = rtxMemAllocType (pctxt, TS24301IE_NASSecurityAlgorithms);
   asn1Init_TS24301IE_NASSecurityAlgorithms (pvalue);

   pvalue->spare1 = 0;

   pvalue->typeOfCiph = TS24301IE_NASSecurityAlgorithms_typeOfCiph_eea0;

   pvalue->spare2 = 0;

   pvalue->typeOfProt = TS24301IE_NASSecurityAlgorithms_typeOfProt_eia0;
   return (pvalue);
}

TS24301IE_PagingIdentity* asn1Test_TS24301IE_PagingIdentity (OSCTXT* pctxt)
{
   TS24301IE_PagingIdentity* pvalue = rtxMemAllocType (pctxt, TS24301IE_PagingIdentity);
   asn1Init_TS24301IE_PagingIdentity (pvalue);

   pvalue->spare = 27;

   pvalue->ident = TS24301IE_PagingIdentity_ident_imsi;
   return (pvalue);
}

TS24301IE_ExtEMMCause* asn1Test_TS24301IE_ExtEMMCause (OSCTXT* pctxt)
{
   TS24301IE_ExtEMMCause* pvalue = rtxMemAllocType (pctxt, TS24301IE_ExtEMMCause);
   asn1Init_TS24301IE_ExtEMMCause (pvalue);

   pvalue->spare = 0;

   pvalue->nbiotAllowed = 0;

   pvalue->epsOptInfo = 1;

   pvalue->e_UTRAN_NotAllowed = 0;
   return (pvalue);
}

TS24301IE_TrackingAreaIdent*
    asn1Test_TS24301IE_TrackingAreaIdent (OSCTXT* pctxt)
{
   TS24301IE_TrackingAreaIdent* pvalue = rtxMemAllocType (pctxt, TS24301IE_TrackingAreaIdent);
   asn1Init_TS24301IE_TrackingAreaIdent (pvalue);

   rtxStrncpy (pvalue->mcc_mnc.mcc, 4, "614", 3);
   rtxStrncpy (pvalue->mcc_mnc.mnc, 4, "02", 3);

   {
      static const OSOCTET testdata[] = { 
      0xe1, 0x23 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->tac.data, 2, testdata, 2);
   }
   return (pvalue);
}

TS24301IE_TrackingAreaIdentListItem*
    asn1Test_TS24301IE_TrackingAreaIdentListItem (OSCTXT* pctxt)
{
   TS24301IE_TrackingAreaIdentListItem* pvalue = rtxMemAllocType (pctxt, TS24301IE_TrackingAreaIdentListItem);
   asn1Init_TS24301IE_TrackingAreaIdentListItem (pvalue);

   pvalue->spare = 0;

   pvalue->typeOfList = 1;

   pvalue->numElements = 26;

   switch (pvalue->typeOfList) {
      /* partTrkIdentList0 */
      case 0:

         rtxStrncpy (pvalue->elements.u.partTrkIdentList0.mcc_mnc.mcc, 4, "404", 3);
         rtxStrncpy (pvalue->elements.u.partTrkIdentList0.mcc_mnc.mnc, 4, "78", 3);

         pvalue->elements.u.partTrkIdentList0.tacs.n = 8;
         {
            static const OSOCTET testdata[] = { 
            0x30, 0x88 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[0].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x51, 0x5a };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[1].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x4d, 0xd0 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[2].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x12, 0x4 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[3].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x75, 0x7f };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[4].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0xcf, 0xf6 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[5].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x35, 0xbb };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[6].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0xd7, 0xed };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList0.tacs.elem[7].data, 2, testdata, 2);
         }

         break;

      /* partTrkIdentList1 */
      case 1:

         rtxStrncpy (pvalue->elements.u.partTrkIdentList1.mcc_mnc.mcc, 4, "724", 3);
         rtxStrncpy (pvalue->elements.u.partTrkIdentList1.mcc_mnc.mnc, 4, "05", 3);

         {
            static const OSOCTET testdata[] = { 
            0xd8, 0x98 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList1.tac.data, 2, testdata, 2);
         }
         break;

      /* partTrkIdentList2 */
      case 2:
         pvalue->elements.u.partTrkIdentList2.n = 1;

         rtxStrncpy (pvalue->elements.u.partTrkIdentList2.elem[0].mcc_mnc.mcc, 4, "202", 3);
         rtxStrncpy (pvalue->elements.u.partTrkIdentList2.elem[0].mcc_mnc.mnc, 4, "05", 3);

         {
            static const OSOCTET testdata[] = { 
            0x46, 0x2a };
            OSCRTLSAFEMEMCPY ((void*)pvalue->elements.u.partTrkIdentList2.elem[0].tac.data, 2, testdata, 2);
         }

         break;

      default: break;
   }
   return (pvalue);
}

TS24301IE_TrackingAreaIdentList*
    asn1Test_TS24301IE_TrackingAreaIdentList (OSCTXT* pctxt)
{
   TS24301IE_TrackingAreaIdentList* pvalue = rtxMemAllocType (pctxt, TS24301IE_TrackingAreaIdentList);
   asn1Init_TS24301IE_TrackingAreaIdentList (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->idents.n = 1;

   pvalue->idents.elem[0].spare = 0;

   pvalue->idents.elem[0].typeOfList = 0;

   pvalue->idents.elem[0].numElements = 29;

   switch (pvalue->idents.elem[0].typeOfList) {
      /* partTrkIdentList0 */
      case 0:

         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mcc, 4, "404", 3);
         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mnc, 4, "22", 3);

         pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.n = 3;
         {
            static const OSOCTET testdata[] = { 
            0x3f, 0xe7 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[0].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x26, 0xbc };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[1].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x04, 0xd5 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[2].data, 2, testdata, 2);
         }

         break;

      /* partTrkIdentList1 */
      case 1:

         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mcc, 4, "629", 3);
         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mnc, 4, "10", 3);

         {
            static const OSOCTET testdata[] = { 
            0x55, 0x30 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList1.tac.data, 2, testdata, 2);
         }
         break;

      /* partTrkIdentList2 */
      case 2:
         pvalue->idents.elem[0].elements.u.partTrkIdentList2.n = 1;

         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mcc, 4, "620", 3);
         rtxStrncpy (pvalue->idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mnc, 4, "03", 3);

         {
            static const OSOCTET testdata[] = { 
            0x27, 0x43 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->idents.elem[0].elements.u.partTrkIdentList2.elem[0].tac.data, 2, testdata, 2);
         }

         break;

      default: break;
   }

   return (pvalue);
}

TS24301IE_EPSEncryptAlgsSupported*
    asn1Test_TS24301IE_EPSEncryptAlgsSupported (OSCTXT* pctxt)
{
   TS24301IE_EPSEncryptAlgsSupported* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSEncryptAlgsSupported);

   pvalue->eea0 = 1;

   pvalue->x128_eea1 = 0;

   pvalue->x128_eea2 = 1;

   pvalue->eea3 = 0;

   pvalue->eea4 = 1;

   pvalue->eea5 = 0;

   pvalue->eea6 = 1;

   pvalue->eea7 = 1;
   return (pvalue);
}

TS24301IE_EPSIntegAlgsSupported*
    asn1Test_TS24301IE_EPSIntegAlgsSupported (OSCTXT* pctxt)
{
   TS24301IE_EPSIntegAlgsSupported* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSIntegAlgsSupported);

   pvalue->eia0 = 0;

   pvalue->eia1 = 0;

   pvalue->eia2 = 1;

   pvalue->eia3 = 0;

   pvalue->eia4 = 1;

   pvalue->eia5 = 1;

   pvalue->eia6 = 1;

   pvalue->eia7 = 1;
   return (pvalue);
}

TS24301IE_UMTSEncryptAlgsSupported*
    asn1Test_TS24301IE_UMTSEncryptAlgsSupported (OSCTXT* pctxt)
{
   TS24301IE_UMTSEncryptAlgsSupported* pvalue = rtxMemAllocType (pctxt, TS24301IE_UMTSEncryptAlgsSupported);

   pvalue->uea0 = 0;

   pvalue->uea1 = 0;

   pvalue->uea2 = 0;

   pvalue->uea3 = 1;

   pvalue->uea4 = 0;

   pvalue->uea5 = 0;

   pvalue->uea6 = 0;

   pvalue->uea7 = 0;
   return (pvalue);
}

TS24301IE_UMTSIntegAlgsSupported*
    asn1Test_TS24301IE_UMTSIntegAlgsSupported (OSCTXT* pctxt)
{
   TS24301IE_UMTSIntegAlgsSupported* pvalue = rtxMemAllocType (pctxt, TS24301IE_UMTSIntegAlgsSupported);

   pvalue->uia1 = 0;

   pvalue->uia2 = 0;

   pvalue->uia3 = 1;

   pvalue->uia4 = 1;

   pvalue->uia5 = 1;

   pvalue->uia6 = 1;

   pvalue->uia7 = 0;
   return (pvalue);
}

TS24301IE_UENetworkCapability*
    asn1Test_TS24301IE_UENetworkCapability (OSCTXT* pctxt)
{
   TS24301IE_UENetworkCapability* pvalue = rtxMemAllocType (pctxt, TS24301IE_UENetworkCapability);
   asn1Init_TS24301IE_UENetworkCapability (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->epsEncryptAlgs.eea0 = 0;

   pvalue->epsEncryptAlgs.x128_eea1 = 1;

   pvalue->epsEncryptAlgs.x128_eea2 = 1;

   pvalue->epsEncryptAlgs.eea3 = 0;

   pvalue->epsEncryptAlgs.eea4 = 1;

   pvalue->epsEncryptAlgs.eea5 = 1;

   pvalue->epsEncryptAlgs.eea6 = 0;

   pvalue->epsEncryptAlgs.eea7 = 0;

   pvalue->epsIntegAlgs.eia0 = 0;

   pvalue->epsIntegAlgs.eia1 = 0;

   pvalue->epsIntegAlgs.eia2 = 1;

   pvalue->epsIntegAlgs.eia3 = 0;

   pvalue->epsIntegAlgs.eia4 = 0;

   pvalue->epsIntegAlgs.eia5 = 0;

   pvalue->epsIntegAlgs.eia6 = 1;

   pvalue->epsIntegAlgs.eia7 = 1;

   pvalue->m.umtsEncryptAlgsPresent = 1;

   pvalue->umtsEncryptAlgs.uea0 = 0;

   pvalue->umtsEncryptAlgs.uea1 = 1;

   pvalue->umtsEncryptAlgs.uea2 = 1;

   pvalue->umtsEncryptAlgs.uea3 = 0;

   pvalue->umtsEncryptAlgs.uea4 = 0;

   pvalue->umtsEncryptAlgs.uea5 = 1;

   pvalue->umtsEncryptAlgs.uea6 = 0;

   pvalue->umtsEncryptAlgs.uea7 = 0;

   pvalue->m.octet6Present = 1;

   pvalue->octet6.ucs2 = 0;

   pvalue->octet6.umtsIntegAlgs.uia1 = 0;

   pvalue->octet6.umtsIntegAlgs.uia2 = 1;

   pvalue->octet6.umtsIntegAlgs.uia3 = 1;

   pvalue->octet6.umtsIntegAlgs.uia4 = 0;

   pvalue->octet6.umtsIntegAlgs.uia5 = 0;

   pvalue->octet6.umtsIntegAlgs.uia6 = 1;

   pvalue->octet6.umtsIntegAlgs.uia7 = 0;

   pvalue->m.octet7Present = 1;

   pvalue->octet7.proSedd = 0;

   pvalue->octet7.proSe = 0;

   pvalue->octet7.h245_ash = 1;

   pvalue->octet7.acc_csfb = 1;

   pvalue->octet7.lpp = 1;

   pvalue->octet7.lcs = 1;

   pvalue->octet7.x1xSR_VCC = 1;

   pvalue->octet7.nf = 1;

   pvalue->m.octet8Present = 1;

   pvalue->octet8.ePCO = 1;

   pvalue->octet8.hc_CP_CIoT = 0;

   pvalue->octet8.erwoPDN = 0;

   pvalue->octet8.s1_Udata = 1;

   pvalue->octet8.upCIoT = 0;

   pvalue->octet8.cpCIoT = 1;

   pvalue->octet8.prose_relay = 1;

   pvalue->octet8.proSedc = 1;

   pvalue->m.octet9Present = 1;

   pvalue->octet9.bearers = 1;

   pvalue->octet9.sgc = 0;

   pvalue->octet9.n1Mode = 1;

   pvalue->octet9.dcnr = 1;

   pvalue->octet9.cpBackoff = 0;

   pvalue->octet9.restrictEC = 1;

   pvalue->octet9.v2xPC5 = 1;

   pvalue->octet9.multDRB = 0;

   pvalue->m.octet10Present = 1;

   pvalue->octet10.spare = 61;

   pvalue->octet10.wusa = 1;

   pvalue->octet10.racs = 1;

   pvalue->m.spare4Present = 1;
   pvalue->spare4.numocts = 13;
   pvalue->spare4.data = (OSOCTET*) rtxMemAlloc (pctxt, 13);
   {
      static const OSOCTET testdata[] = {
      0x3d, 0x58, 0x4c, 0xb7, 0xb3, 0xf3, 0x0d, 0xe5, 
      0xb3, 0x28, 0xd5, 0xcf, 0x4c };
      OSCRTLSAFEMEMCPY ((void*)pvalue->spare4.data, 13, testdata, 13);
   }
   return (pvalue);
}

TS24301IE_GPRSIntegAlgsSupported*
    asn1Test_TS24301IE_GPRSIntegAlgsSupported (OSCTXT* pctxt)
{
   TS24301IE_GPRSIntegAlgsSupported* pvalue = rtxMemAllocType (pctxt, TS24301IE_GPRSIntegAlgsSupported);

   pvalue->gea1 = 1;

   pvalue->gea2 = 1;

   pvalue->gea3 = 0;

   pvalue->gea4 = 0;

   pvalue->gea5 = 0;

   pvalue->gea6 = 1;

   pvalue->gea7 = 1;
   return (pvalue);
}

TS24301IE_UERadioCapInfoUpdateNeeded*
    asn1Test_TS24301IE_UERadioCapInfoUpdateNeeded (OSCTXT* pctxt)
{
   TS24301IE_UERadioCapInfoUpdateNeeded* pvalue = rtxMemAllocType (pctxt, TS24301IE_UERadioCapInfoUpdateNeeded);

   pvalue->spare = 0;

   pvalue->value = 0;
   return (pvalue);
}

TS24301IE_UESecurityCapability*
    asn1Test_TS24301IE_UESecurityCapability (OSCTXT* pctxt)
{
   TS24301IE_UESecurityCapability* pvalue = rtxMemAllocType (pctxt, TS24301IE_UESecurityCapability);
   asn1Init_TS24301IE_UESecurityCapability (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->epsEncryptAlgs.eea0 = 0;

   pvalue->epsEncryptAlgs.x128_eea1 = 1;

   pvalue->epsEncryptAlgs.x128_eea2 = 1;

   pvalue->epsEncryptAlgs.eea3 = 0;

   pvalue->epsEncryptAlgs.eea4 = 1;

   pvalue->epsEncryptAlgs.eea5 = 1;

   pvalue->epsEncryptAlgs.eea6 = 1;

   pvalue->epsEncryptAlgs.eea7 = 0;

   pvalue->epsIntegAlgs.eia0 = 1;

   pvalue->epsIntegAlgs.eia1 = 0;

   pvalue->epsIntegAlgs.eia2 = 0;

   pvalue->epsIntegAlgs.eia3 = 0;

   pvalue->epsIntegAlgs.eia4 = 0;

   pvalue->epsIntegAlgs.eia5 = 0;

   pvalue->epsIntegAlgs.eia6 = 1;

   pvalue->epsIntegAlgs.eia7 = 0;

   pvalue->m.umtsEncryptAlgsPresent = 1;

   pvalue->umtsEncryptAlgs.uea0 = 1;

   pvalue->umtsEncryptAlgs.uea1 = 0;

   pvalue->umtsEncryptAlgs.uea2 = 0;

   pvalue->umtsEncryptAlgs.uea3 = 0;

   pvalue->umtsEncryptAlgs.uea4 = 0;

   pvalue->umtsEncryptAlgs.uea5 = 1;

   pvalue->umtsEncryptAlgs.uea6 = 1;

   pvalue->umtsEncryptAlgs.uea7 = 1;

   pvalue->m.octet6Present = 1;

   pvalue->octet6.spare = 0;

   pvalue->octet6.umtsIntegAlgs.uia1 = 1;

   pvalue->octet6.umtsIntegAlgs.uia2 = 0;

   pvalue->octet6.umtsIntegAlgs.uia3 = 0;

   pvalue->octet6.umtsIntegAlgs.uia4 = 0;

   pvalue->octet6.umtsIntegAlgs.uia5 = 1;

   pvalue->octet6.umtsIntegAlgs.uia6 = 1;

   pvalue->octet6.umtsIntegAlgs.uia7 = 0;

   pvalue->m.octet7Present = 1;

   pvalue->octet7.spare = 0;

   pvalue->octet7.gprsIntegAlgs.gea1 = 0;

   pvalue->octet7.gprsIntegAlgs.gea2 = 0;

   pvalue->octet7.gprsIntegAlgs.gea3 = 0;

   pvalue->octet7.gprsIntegAlgs.gea4 = 0;

   pvalue->octet7.gprsIntegAlgs.gea5 = 1;

   pvalue->octet7.gprsIntegAlgs.gea6 = 1;

   pvalue->octet7.gprsIntegAlgs.gea7 = 1;
   return (pvalue);
}

TS24301IE_ExtEmergencyNumberInfo*
    asn1Test_TS24301IE_ExtEmergencyNumberInfo (OSCTXT* pctxt)
{
   TS24301IE_ExtEmergencyNumberInfo* pvalue = rtxMemAllocType (pctxt, TS24301IE_ExtEmergencyNumberInfo);
   asn1Init_TS24301IE_ExtEmergencyNumberInfo (pvalue);

   pvalue->number.length = 0; /* length will be calculated */

   pvalue->number.digits = "3463*160";

   pvalue->subservices.subservicesLen = 0; /* length will be calculated */

   pvalue->subservices.subservices.numocts = 17;
   pvalue->subservices.subservices.data = (OSOCTET*) rtxMemAlloc (pctxt, 17);
   {
      static const OSOCTET testdata[] = {
      0x8a, 0x67, 0xec, 0x37, 0xaf, 0x8c, 0x0b, 0xfc, 
      0x38, 0x2f, 0xbd, 0x23, 0x4e, 0x03, 0xce, 0xe7, 
      0x1d };
      OSCRTLSAFEMEMCPY ((void*)pvalue->subservices.subservices.data, 17, testdata, 17);
   }
   return (pvalue);
}

TS24301IE_ExtEmergencyNumberList*
    asn1Test_TS24301IE_ExtEmergencyNumberList (OSCTXT* pctxt)
{
   TS24301IE_ExtEmergencyNumberList* pvalue = rtxMemAllocType (pctxt, TS24301IE_ExtEmergencyNumberList);
   asn1Init_TS24301IE_ExtEmergencyNumberList (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 17;

   pvalue->catValue = 0;

   /* zero elements */
   return (pvalue);
}

TS24301IE_CLI* asn1Test_TS24301IE_CLI (OSCTXT* pctxt)
{
   TS24301IE_CLI* pvalue = rtxMemAllocType (pctxt, TS24301IE_CLI);
   asn1Init_TS24301IE_CLI (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->value = "2700059a";
   return (pvalue);
}

TS24301IE_GUTIType* asn1Test_TS24301IE_GUTIType (OSCTXT* pctxt)
{
   TS24301IE_GUTIType* pvalue = rtxMemAllocType (pctxt, TS24301IE_GUTIType);
   asn1Init_TS24301IE_GUTIType (pvalue);

   pvalue->spare = 2;

   pvalue->mapped = 0;
   return (pvalue);
}

TS24301IE_CtrlPlaneSvcType* asn1Test_TS24301IE_CtrlPlaneSvcType (OSCTXT* pctxt)
{
   TS24301IE_CtrlPlaneSvcType* pvalue = rtxMemAllocType (pctxt, TS24301IE_CtrlPlaneSvcType);

   pvalue->activeFlag = 1;

   pvalue->svcTypeValue = 4;
   return (pvalue);
}

TS24301IE_HashMME* asn1Test_TS24301IE_HashMME (OSCTXT* pctxt)
{
   TS24301IE_HashMME* pvalue = rtxMemAllocType (pctxt, TS24301IE_HashMME);

   pvalue->length = 63;

   {
      static const OSOCTET testdata[] = { 
      0xc4, 0xc9, 0xee, 0x52, 0xd4, 0x6b, 0x0a, 0x4 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->hashValue, 8, testdata, 8);
   }
   return (pvalue);
}

TS24301IE_ReplayedNASMsgContainer*
    asn1Test_TS24301IE_ReplayedNASMsgContainer (OSCTXT* pctxt)
{
   TS24301IE_ReplayedNASMsgContainer* pvalue = rtxMemAllocType (pctxt, TS24301IE_ReplayedNASMsgContainer);
   asn1Init_TS24301IE_ReplayedNASMsgContainer (pvalue);

   pvalue->length = 32299;

   pvalue->contents.numocts = 1;
   pvalue->contents.data = (OSOCTET*) rtxMemAlloc (pctxt, 1);
   {
      static const OSOCTET testdata[] = {
      0x2d };
      OSCRTLSAFEMEMCPY ((void*)pvalue->contents.data, 1, testdata, 1);
   }
   return (pvalue);
}

TS24301IE_NetworkPolicy* asn1Test_TS24301IE_NetworkPolicy (OSCTXT* pctxt)
{
   TS24301IE_NetworkPolicy* pvalue = rtxMemAllocType (pctxt, TS24301IE_NetworkPolicy);
   asn1Init_TS24301IE_NetworkPolicy (pvalue);

   pvalue->spare = 3;

   pvalue->redirPolicy = 0;
   return (pvalue);
}

TS24301IE_UEAddlSecurityCapability*
    asn1Test_TS24301IE_UEAddlSecurityCapability (OSCTXT* pctxt)
{
   TS24301IE_UEAddlSecurityCapability* pvalue = rtxMemAllocType (pctxt, TS24301IE_UEAddlSecurityCapability);

   pvalue->length = 251;

   pvalue->contents.elem[0] = 1;

   pvalue->contents.elem[1] = 0;

   pvalue->contents.elem[2] = 1;

   pvalue->contents.elem[3] = 1;

   pvalue->contents.elem[4] = 1;

   pvalue->contents.elem[5] = 0;

   pvalue->contents.elem[6] = 0;

   pvalue->contents.elem[7] = 0;

   pvalue->contents.elem[8] = 1;

   pvalue->contents.elem[9] = 0;

   pvalue->contents.elem[10] = 1;

   pvalue->contents.elem[11] = 1;

   pvalue->contents.elem[12] = 1;

   pvalue->contents.elem[13] = 1;

   pvalue->contents.elem[14] = 1;

   pvalue->contents.elem[15] = 0;

   pvalue->contents.elem[16] = 0;

   pvalue->contents.elem[17] = 1;

   pvalue->contents.elem[18] = 1;

   pvalue->contents.elem[19] = 1;

   pvalue->contents.elem[20] = 0;

   pvalue->contents.elem[21] = 0;

   pvalue->contents.elem[22] = 0;

   pvalue->contents.elem[23] = 1;

   pvalue->contents.elem[24] = 1;

   pvalue->contents.elem[25] = 1;

   pvalue->contents.elem[26] = 1;

   pvalue->contents.elem[27] = 1;

   pvalue->contents.elem[28] = 1;

   pvalue->contents.elem[29] = 1;

   pvalue->contents.elem[30] = 0;

   pvalue->contents.elem[31] = 0;

   return (pvalue);
}

TS24301IE_UEStatus* asn1Test_TS24301IE_UEStatus (OSCTXT* pctxt)
{
   TS24301IE_UEStatus* pvalue = rtxMemAllocType (pctxt, TS24301IE_UEStatus);
   asn1Init_TS24301IE_UEStatus (pvalue);

   pvalue->length = 146;

   pvalue->spare = 40;

   pvalue->n1RegStatus = 1;

   pvalue->s1RegStatus = 0;
   return (pvalue);
}

TS24301IE_AdditionalInfoReq*
    asn1Test_TS24301IE_AdditionalInfoReq (OSCTXT* pctxt)
{
   TS24301IE_AdditionalInfoReq* pvalue = rtxMemAllocType (pctxt, TS24301IE_AdditionalInfoReq);
   asn1Init_TS24301IE_AdditionalInfoReq (pvalue);

   pvalue->spare = 94;

   pvalue->dataRequested = 1;
   return (pvalue);
}

TS24301IE_CipherDataSet* asn1Test_TS24301IE_CipherDataSet (OSCTXT* pctxt)
{
   TS24301IE_CipherDataSet* pvalue = rtxMemAllocType (pctxt, TS24301IE_CipherDataSet);
   asn1Init_TS24301IE_CipherDataSet (pvalue);

   {
      static const OSOCTET testdata[] = { 
      0x04, 0xea, 0x45, 0x81, 0x6c, 0x7a, 0x06, 0xc5, 
      0x08, 0x1d, 0x5e, 0x5b, 0x7e, 0x66, 0x80, 0x34 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->cipherKey, 16, testdata, 16);
   }

   pvalue->spare = 5;

   pvalue->c0Len = 30;

   pvalue->c0.numocts = 10;
   pvalue->c0.data = (OSOCTET*) rtxMemAlloc (pctxt, 10);
   {
      static const OSOCTET testdata[] = {
      0xf5, 0x0e, 0x78, 0xbe, 0x66, 0xbc, 0x51, 0x7c, 
      0x37, 0xb1 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->c0.data, 10, testdata, 10);
   }

   pvalue->posSIBType.elem[0] = 1;

   pvalue->posSIBType.elem[1] = 0;

   pvalue->posSIBType.elem[2] = 0;

   pvalue->posSIBType.elem[3] = 0;

   pvalue->posSIBType.elem[4] = 1;

   pvalue->posSIBType.elem[5] = 0;

   pvalue->posSIBType.elem[6] = 1;

   pvalue->posSIBType.elem[7] = 1;

   pvalue->posSIBType.elem[8] = 1;

   pvalue->posSIBType.elem[9] = 0;

   pvalue->posSIBType.elem[10] = 0;

   pvalue->posSIBType.elem[11] = 1;

   pvalue->posSIBType.elem[12] = 1;

   pvalue->posSIBType.elem[13] = 1;

   pvalue->posSIBType.elem[14] = 1;

   pvalue->posSIBType.elem[15] = 0;

   pvalue->posSIBType.elem[16] = 1;

   pvalue->posSIBType.elem[17] = 0;

   pvalue->posSIBType.elem[18] = 0;

   pvalue->posSIBType.elem[19] = 0;

   pvalue->posSIBType.elem[20] = 1;

   pvalue->posSIBType.elem[21] = 1;

   pvalue->posSIBType.elem[22] = 0;

   pvalue->posSIBType.elem[23] = 0;

   pvalue->posSIBType.elem[24] = 1;

   pvalue->posSIBType.elem[25] = 0;

   pvalue->posSIBType.elem[26] = 0;

   pvalue->spare2 = 29;

   pvalue->validityStartTime.year = 24;

   pvalue->validityStartTime.month = 232;

   pvalue->validityStartTime.day = 198;

   pvalue->validityStartTime.hour = 234;

   pvalue->validityStartTime.minute = 59;

   pvalue->validityStartTime.second = 124;

   pvalue->validityStartTime.timezone = 168;

   pvalue->validityDuration = 4673;

   pvalue->taiList.length = 0; /* length will be calculated */

   pvalue->taiList.idents.n = 1;

   pvalue->taiList.idents.elem[0].spare = 0;

   pvalue->taiList.idents.elem[0].typeOfList = 1;

   pvalue->taiList.idents.elem[0].numElements = 11;

   switch (pvalue->taiList.idents.elem[0].typeOfList) {
      /* partTrkIdentList0 */
      case 0:

         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mcc, 4, "647", 3);
         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mnc, 4, "00", 3);

         pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.n = 2;
         {
            static const OSOCTET testdata[] = { 
            0xc5, 0x7e };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[0].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x4d, 0x95 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[1].data, 2, testdata, 2);
         }

         break;

      /* partTrkIdentList1 */
      case 1:

         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mcc, 4, "340", 3);
         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mnc, 4, "01", 3);

         {
            static const OSOCTET testdata[] = { 
            0xa6, 0x4b };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList1.tac.data, 2, testdata, 2);
         }
         break;

      /* partTrkIdentList2 */
      case 2:
         pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList2.n = 1;

         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mcc, 4, "294", 3);
         rtxStrncpy (pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mnc, 4, "02", 3);

         {
            static const OSOCTET testdata[] = { 
            0x34, 0xda };
            OSCRTLSAFEMEMCPY ((void*)pvalue->taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].tac.data, 2, testdata, 2);
         }

         break;

      default: break;
   }

   return (pvalue);
}

TS24301IE_CipherKeyData* asn1Test_TS24301IE_CipherKeyData (OSCTXT* pctxt)
{
   TS24301IE_CipherKeyData* pvalue = rtxMemAllocType (pctxt, TS24301IE_CipherKeyData);
   asn1Init_TS24301IE_CipherKeyData (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->dataSet.n = 1;

   {
      static const OSOCTET testdata[] = { 
      0x12, 0xb0, 0x5f, 0xc6, 0xa4, 0x23, 0xe1, 0x55, 
      0xb7, 0x79, 0x3e, 0xfd, 0x64, 0x7a, 0x7b, 0xe };
      OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].cipherKey, 16, testdata, 16);
   }

   pvalue->dataSet.elem[0].spare = 1;

   pvalue->dataSet.elem[0].c0Len = 25;

   pvalue->dataSet.elem[0].c0.numocts = 16;
   pvalue->dataSet.elem[0].c0.data = (OSOCTET*) rtxMemAlloc (pctxt, 16);
   {
      static const OSOCTET testdata[] = {
      0xb1, 0x21, 0x27, 0xb0, 0xed, 0x3c, 0x25, 0x15, 
      0x87, 0x90, 0x49, 0xe1, 0xa2, 0x79, 0x41, 0xe8 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].c0.data, 16, testdata, 16);
   }

   pvalue->dataSet.elem[0].posSIBType.elem[0] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[1] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[2] = 0;

   pvalue->dataSet.elem[0].posSIBType.elem[3] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[4] = 0;

   pvalue->dataSet.elem[0].posSIBType.elem[5] = 0;

   pvalue->dataSet.elem[0].posSIBType.elem[6] = 0;

   pvalue->dataSet.elem[0].posSIBType.elem[7] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[8] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[9] = 0;

   pvalue->dataSet.elem[0].posSIBType.elem[10] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[11] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[12] = 0;

   pvalue->dataSet.elem[0].posSIBType.elem[13] = 0;

   pvalue->dataSet.elem[0].posSIBType.elem[14] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[15] = 0;

   pvalue->dataSet.elem[0].posSIBType.elem[16] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[17] = 0;

   pvalue->dataSet.elem[0].posSIBType.elem[18] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[19] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[20] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[21] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[22] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[23] = 0;

   pvalue->dataSet.elem[0].posSIBType.elem[24] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[25] = 1;

   pvalue->dataSet.elem[0].posSIBType.elem[26] = 1;

   pvalue->dataSet.elem[0].spare2 = 12;

   pvalue->dataSet.elem[0].validityStartTime.year = 171;

   pvalue->dataSet.elem[0].validityStartTime.month = 40;

   pvalue->dataSet.elem[0].validityStartTime.day = 29;

   pvalue->dataSet.elem[0].validityStartTime.hour = 74;

   pvalue->dataSet.elem[0].validityStartTime.minute = 13;

   pvalue->dataSet.elem[0].validityStartTime.second = 103;

   pvalue->dataSet.elem[0].validityStartTime.timezone = 62;

   pvalue->dataSet.elem[0].validityDuration = 59710;

   pvalue->dataSet.elem[0].taiList.length = 0; /* length will be calculated */

   pvalue->dataSet.elem[0].taiList.idents.n = 1;

   pvalue->dataSet.elem[0].taiList.idents.elem[0].spare = 0;

   pvalue->dataSet.elem[0].taiList.idents.elem[0].typeOfList = 1;

   pvalue->dataSet.elem[0].taiList.idents.elem[0].numElements = 29;

   switch (pvalue->dataSet.elem[0].taiList.idents.elem[0].typeOfList) {
      /* partTrkIdentList0 */
      case 0:

         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mcc, 4, "310", 3);
         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.mcc_mnc.mnc, 4, "38", 3);

         pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.n = 4;
         {
            static const OSOCTET testdata[] = { 
            0x1e, 0xd6 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[0].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x8c, 0x17 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[1].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x1c, 0xa5 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[2].data, 2, testdata, 2);
         }

         {
            static const OSOCTET testdata[] = { 
            0x43, 0x81 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList0.tacs.elem[3].data, 2, testdata, 2);
         }

         break;

      /* partTrkIdentList1 */
      case 1:

         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mcc, 4, "340", 3);
         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList1.mcc_mnc.mnc, 4, "03", 3);

         {
            static const OSOCTET testdata[] = { 
            0x9f, 0xd4 };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList1.tac.data, 2, testdata, 2);
         }
         break;

      /* partTrkIdentList2 */
      case 2:
         pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList2.n = 1;

         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mcc, 4, "649", 3);
         rtxStrncpy (pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].mcc_mnc.mnc, 4, "01", 3);

         {
            static const OSOCTET testdata[] = { 
            0x21, 0x3e };
            OSCRTLSAFEMEMCPY ((void*)pvalue->dataSet.elem[0].taiList.idents.elem[0].elements.u.partTrkIdentList2.elem[0].tac.data, 2, testdata, 2);
         }

         break;

      default: break;
   }

   return (pvalue);
}

TS24301IE_N1UENetCapability*
    asn1Test_TS24301IE_N1UENetCapability (OSCTXT* pctxt)
{
   TS24301IE_N1UENetCapability* pvalue = rtxMemAllocType (pctxt, TS24301IE_N1UENetCapability);
   asn1Init_TS24301IE_N1UENetCapability (pvalue);

   pvalue->length = 231;

   pvalue->spare = 0;

   pvalue->pnbCIoT = 1;

   pvalue->upCIoT = 0;

   pvalue->hcCpCIoT = 1;

   pvalue->n3Data = 0;

   pvalue->cpCIoT = 0;
   return (pvalue);
}

TS24301IE_UERadioCapIdAvailability*
    asn1Test_TS24301IE_UERadioCapIdAvailability (OSCTXT* pctxt)
{
   TS24301IE_UERadioCapIdAvailability* pvalue = rtxMemAllocType (pctxt, TS24301IE_UERadioCapIdAvailability);
   asn1Init_TS24301IE_UERadioCapIdAvailability (pvalue);

   pvalue->spare = 0;

   pvalue->value = 4;
   return (pvalue);
}

TS24301IE_UERadioCapIdRequest*
    asn1Test_TS24301IE_UERadioCapIdRequest (OSCTXT* pctxt)
{
   TS24301IE_UERadioCapIdRequest* pvalue = rtxMemAllocType (pctxt, TS24301IE_UERadioCapIdRequest);
   asn1Init_TS24301IE_UERadioCapIdRequest (pvalue);

   pvalue->spare = 76;

   pvalue->urcid_A = 1;
   return (pvalue);
}

TS24301IE_UERadioCapId* asn1Test_TS24301IE_UERadioCapId (OSCTXT* pctxt)
{
   TS24301IE_UERadioCapId* pvalue = rtxMemAllocType (pctxt, TS24301IE_UERadioCapId);
   asn1Init_TS24301IE_UERadioCapId (pvalue);

   pvalue->length = 231;

   pvalue->capId.numocts = 10;
   pvalue->capId.data = (OSOCTET*) rtxMemAlloc (pctxt, 10);
   {
      static const OSOCTET testdata[] = {
      0x2c, 0x17, 0x95, 0xee, 0x6c, 0xb3, 0xc5, 0x79, 
      0x4a, 0x61 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->capId.data, 10, testdata, 10);
   }
   return (pvalue);
}

TS24301IE_UERadioCapIdDeletionInd*
    asn1Test_TS24301IE_UERadioCapIdDeletionInd (OSCTXT* pctxt)
{
   TS24301IE_UERadioCapIdDeletionInd* pvalue = rtxMemAllocType (pctxt, TS24301IE_UERadioCapIdDeletionInd);
   asn1Init_TS24301IE_UERadioCapIdDeletionInd (pvalue);

   pvalue->spare = 0;

   pvalue->deletionReq = 0;
   return (pvalue);
}

TS24301IE_WUSAssistInfoType*
    asn1Test_TS24301IE_WUSAssistInfoType (OSCTXT* pctxt)
{
   TS24301IE_WUSAssistInfoType* pvalue = rtxMemAllocType (pctxt, TS24301IE_WUSAssistInfoType);

   pvalue->infoType = TS24301IE_InformationType_itUEPagingProbInfo;

   pvalue->infoValue = 9;
   return (pvalue);
}

TS24301IE_WUSAssistanceInfo*
    asn1Test_TS24301IE_WUSAssistanceInfo (OSCTXT* pctxt)
{
   TS24301IE_WUSAssistanceInfo* pvalue = rtxMemAllocType (pctxt, TS24301IE_WUSAssistanceInfo);
   asn1Init_TS24301IE_WUSAssistanceInfo (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->types.n = 1;

   pvalue->types.elem[0].infoType = TS24301IE_InformationType_itUEPagingProbInfo;

   pvalue->types.elem[0].infoValue = 3;

   return (pvalue);
}

TS24301IE_APNAggMaxBitRateExt*
    asn1Test_TS24301IE_APNAggMaxBitRateExt (OSCTXT* pctxt)
{
   TS24301IE_APNAggMaxBitRateExt* pvalue = rtxMemAllocType (pctxt, TS24301IE_APNAggMaxBitRateExt);

   pvalue->apnAmbrforDL = 5;

   pvalue->apnAmbrforUL = 173;
   return (pvalue);
}

TS24301IE_APNAggMaxBitRate* asn1Test_TS24301IE_APNAggMaxBitRate (OSCTXT* pctxt)
{
   TS24301IE_APNAggMaxBitRate* pvalue = rtxMemAllocType (pctxt, TS24301IE_APNAggMaxBitRate);
   asn1Init_TS24301IE_APNAggMaxBitRate (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->apnAmbrforDL = 184;

   pvalue->apnAmbrforUL = 231;

   /* zero elements */
   return (pvalue);
}

TS24301IE_EPSQoSBitRates* asn1Test_TS24301IE_EPSQoSBitRates (OSCTXT* pctxt)
{
   TS24301IE_EPSQoSBitRates* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSQoSBitRates);

   pvalue->maxBitRateforUL = 207;

   pvalue->maxBitRateforDL = 118;

   pvalue->guarBitRateforUL = 80;

   pvalue->guarBitRateforDL = 130;
   return (pvalue);
}

TS24301IE_EPSQualityOfService*
    asn1Test_TS24301IE_EPSQualityOfService (OSCTXT* pctxt)
{
   TS24301IE_EPSQualityOfService* pvalue = rtxMemAllocType (pctxt, TS24301IE_EPSQualityOfService);
   asn1Init_TS24301IE_EPSQualityOfService (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->qci = 230;

   /* zero elements */
   return (pvalue);
}

TS24301IE_ESMInfoXferFlag* asn1Test_TS24301IE_ESMInfoXferFlag (OSCTXT* pctxt)
{
   TS24301IE_ESMInfoXferFlag* pvalue = rtxMemAllocType (pctxt, TS24301IE_ESMInfoXferFlag);
   asn1Init_TS24301IE_ESMInfoXferFlag (pvalue);

   pvalue->spare = 3;

   pvalue->eitValue = 0;
   return (pvalue);
}

TS24301IE_PDNAddress* asn1Test_TS24301IE_PDNAddress (OSCTXT* pctxt)
{
   TS24301IE_PDNAddress* pvalue = rtxMemAllocType (pctxt, TS24301IE_PDNAddress);
   asn1Init_TS24301IE_PDNAddress (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare = 29;

   pvalue->pdnTypeValue = TS24301IE_PDNTypeValue_ipv4;

   {
      static const OSOCTET testdata[] = { 
      0x96, 0x6d, 0x69, 0x1b };
      pvalue->pdnAddrInfo.numocts = 4;
      OSCRTLSAFEMEMCPY ((void*)pvalue->pdnAddrInfo.data, 4, testdata, 4);
   }
   return (pvalue);
}

TS24301IE_PDNType* asn1Test_TS24301IE_PDNType (OSCTXT* pctxt)
{
   TS24301IE_PDNType* pvalue = rtxMemAllocType (pctxt, TS24301IE_PDNType);
   asn1Init_TS24301IE_PDNType (pvalue);

   pvalue->spare = 0;

   pvalue->pdnTypeValue = TS24301IE_PDNTypeValue_ipv4;
   return (pvalue);
}

TS24301IE_ReattemptInd* asn1Test_TS24301IE_ReattemptInd (OSCTXT* pctxt)
{
   TS24301IE_ReattemptInd* pvalue = rtxMemAllocType (pctxt, TS24301IE_ReattemptInd);
   asn1Init_TS24301IE_ReattemptInd (pvalue);

   pvalue->spare = 42;

   pvalue->eplmNcValue = 0;

   pvalue->ratcValue = 1;
   return (pvalue);
}

TS24301IE_RemoteUECtxt* asn1Test_TS24301IE_RemoteUECtxt (OSCTXT* pctxt)
{
   TS24301IE_RemoteUECtxt* pvalue = rtxMemAllocType (pctxt, TS24301IE_RemoteUECtxt);
   asn1Init_TS24301IE_RemoteUECtxt (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->numUserIdents = 112;

   pvalue->userIdentLength = 35;

   /* zero elements */
   return (pvalue);
}

TS24301IE_RemoteUECtxtList* asn1Test_TS24301IE_RemoteUECtxtList (OSCTXT* pctxt)
{
   TS24301IE_RemoteUECtxtList* pvalue = rtxMemAllocType (pctxt, TS24301IE_RemoteUECtxtList);
   asn1Init_TS24301IE_RemoteUECtxtList (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->numRemUECtxts = 39;

   /* zero elements */

   pvalue->spare = 28;

   pvalue->addrType = TS24301IE_RemoteUEAddrType_remUENoIp;

   {
      static const OSOCTET testdata[] = { 
      0x7c, 0x56, 0xa1, 0xde, 0xf5, 0x30 };
      pvalue->addrInfo.numocts = 6;
      OSCRTLSAFEMEMCPY ((void*)pvalue->addrInfo.data, 6, testdata, 6);
   }
   return (pvalue);
}

TS24301IE_PKMFAddressType* asn1Test_TS24301IE_PKMFAddressType (OSCTXT* pctxt)
{
   TS24301IE_PKMFAddressType* pvalue = rtxMemAllocType (pctxt, TS24301IE_PKMFAddressType);
   asn1Init_TS24301IE_PKMFAddressType (pvalue);

   pvalue->spare = 22;

   pvalue->addrType = 4;

   {
      pvalue->addrInfo.numocts = 0;
   }
   return (pvalue);
}

TS24301IE_PKMFAddress* asn1Test_TS24301IE_PKMFAddress (OSCTXT* pctxt)
{
   TS24301IE_PKMFAddress* pvalue = rtxMemAllocType (pctxt, TS24301IE_PKMFAddress);
   asn1Init_TS24301IE_PKMFAddress (pvalue);

   pvalue->length = 0; /* length will be calculated */

   /* zero elements */
   return (pvalue);
}

TS24301IE_HdrCompressConfig*
    asn1Test_TS24301IE_HdrCompressConfig (OSCTXT* pctxt)
{
   TS24301IE_HdrCompressConfig* pvalue = rtxMemAllocType (pctxt, TS24301IE_HdrCompressConfig);
   asn1Init_TS24301IE_HdrCompressConfig (pvalue);

   pvalue->length = 0; /* length will be calculated */

   pvalue->spare1 = 0;

   pvalue->profile104 = 0;

   pvalue->profile103 = 0;

   pvalue->profile102 = 0;

   pvalue->profile006 = 0;

   pvalue->profile004 = 1;

   pvalue->profile003 = 1;

   pvalue->profile002 = 1;

   {
      static const OSOCTET testdata[] = { 
      0x52, 0x1a };
      OSCRTLSAFEMEMCPY ((void*)pvalue->maxCID, 2, testdata, 2);
   }

   pvalue->addlSetupType.numocts = 4;
   pvalue->addlSetupType.data = (OSOCTET*) rtxMemAlloc (pctxt, 4);
   {
      static const OSOCTET testdata[] = {
      0xe9, 0x87, 0x44, 0x5 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->addlSetupType.data, 4, testdata, 4);
   }

   {
      static const OSOCTET testdata[] = { 
      0xe0 };
      pvalue->addlSetupContainer.numocts = 1;
      OSCRTLSAFEMEMCPY ((void*)pvalue->addlSetupContainer.data, 1, testdata, 1);
   }
   return (pvalue);
}

TS24301IE_CtrlPlaneOnlyInd* asn1Test_TS24301IE_CtrlPlaneOnlyInd (OSCTXT* pctxt)
{
   TS24301IE_CtrlPlaneOnlyInd* pvalue = rtxMemAllocType (pctxt, TS24301IE_CtrlPlaneOnlyInd);
   asn1Init_TS24301IE_CtrlPlaneOnlyInd (pvalue);

   pvalue->spare4 = 0;

   pvalue->spare3 = 1;

   pvalue->spare2 = 0;

   pvalue->cpoiValue = 1;
   return (pvalue);
}

TS24301IE_ReleaseAssistInd* asn1Test_TS24301IE_ReleaseAssistInd (OSCTXT* pctxt)
{
   TS24301IE_ReleaseAssistInd* pvalue = rtxMemAllocType (pctxt, TS24301IE_ReleaseAssistInd);
   asn1Init_TS24301IE_ReleaseAssistInd (pvalue);

   pvalue->spare4 = 1;

   pvalue->spare3 = 0;

   pvalue->ddx = TS24301IE_ReleaseAssistInd_ddx_ddxNoInfo;
   return (pvalue);
}

TS24301IE_HdrCompressConfigStat*
    asn1Test_TS24301IE_HdrCompressConfigStat (OSCTXT* pctxt)
{
   TS24301IE_HdrCompressConfigStat* pvalue = rtxMemAllocType (pctxt, TS24301IE_HdrCompressConfigStat);

   pvalue->length = 0; /* length will be calculated */

   {
      static const OSOCTET testdata[] = { 
      0x4c, 0x1 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->ebi, 2, testdata, 2);
   }
   return (pvalue);
}

TS24301IE_ExtAPNAggMaxBitRate*
    asn1Test_TS24301IE_ExtAPNAggMaxBitRate (OSCTXT* pctxt)
{
   TS24301IE_ExtAPNAggMaxBitRate* pvalue = rtxMemAllocType (pctxt, TS24301IE_ExtAPNAggMaxBitRate);

   pvalue->extApnAmbrUnitForDL = 5;

   {
      static const OSOCTET testdata[] = { 
      0xed, 0xdf };
      OSCRTLSAFEMEMCPY ((void*)pvalue->extApnAmbrForDL, 2, testdata, 2);
   }

   pvalue->extApnAmbrUnitForUL = 122;

   {
      static const OSOCTET testdata[] = { 
      0x9d, 0xa1 };
      OSCRTLSAFEMEMCPY ((void*)pvalue->extApnAmbrForUL, 2, testdata, 2);
   }
   return (pvalue);
}

